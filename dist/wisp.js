require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"6TzXFU":[function(require,module,exports){
{
    var _ns_ = {
            id: 'wisp.analyzer',
            doc: void 0
        };
    var wisp_ast = require('./ast');
    var meta = wisp_ast.meta;
    var withMeta = wisp_ast.withMeta;
    var isSymbol = wisp_ast.isSymbol;
    var isKeyword = wisp_ast.isKeyword;
    var isQuote = wisp_ast.isQuote;
    var symbol = wisp_ast.symbol;
    var namespace = wisp_ast.namespace;
    var name = wisp_ast.name;
    var prStr = wisp_ast.prStr;
    var isUnquote = wisp_ast.isUnquote;
    var isUnquoteSplicing = wisp_ast.isUnquoteSplicing;
    var wisp_sequence = require('./sequence');
    var isList = wisp_sequence.isList;
    var list = wisp_sequence.list;
    var conj = wisp_sequence.conj;
    var partition = wisp_sequence.partition;
    var seq = wisp_sequence.seq;
    var isEmpty = wisp_sequence.isEmpty;
    var map = wisp_sequence.map;
    var vec = wisp_sequence.vec;
    var isEvery = wisp_sequence.isEvery;
    var concat = wisp_sequence.concat;
    var first = wisp_sequence.first;
    var second = wisp_sequence.second;
    var third = wisp_sequence.third;
    var rest = wisp_sequence.rest;
    var last = wisp_sequence.last;
    var butlast = wisp_sequence.butlast;
    var interleave = wisp_sequence.interleave;
    var cons = wisp_sequence.cons;
    var count = wisp_sequence.count;
    var some = wisp_sequence.some;
    var assoc = wisp_sequence.assoc;
    var reduce = wisp_sequence.reduce;
    var filter = wisp_sequence.filter;
    var isSeq = wisp_sequence.isSeq;
    var wisp_runtime = require('./runtime');
    var isNil = wisp_runtime.isNil;
    var isDictionary = wisp_runtime.isDictionary;
    var isVector = wisp_runtime.isVector;
    var keys = wisp_runtime.keys;
    var vals = wisp_runtime.vals;
    var isString = wisp_runtime.isString;
    var isNumber = wisp_runtime.isNumber;
    var isBoolean = wisp_runtime.isBoolean;
    var isDate = wisp_runtime.isDate;
    var isRePattern = wisp_runtime.isRePattern;
    var isEven = wisp_runtime.isEven;
    var isEqual = wisp_runtime.isEqual;
    var max = wisp_runtime.max;
    var dec = wisp_runtime.dec;
    var dictionary = wisp_runtime.dictionary;
    var subs = wisp_runtime.subs;
    var inc = wisp_runtime.inc;
    var dec = wisp_runtime.dec;
    var wisp_expander = require('./expander');
    var macroexpand = wisp_expander.macroexpand;
    var wisp_string = require('./string');
    var split = wisp_string.split;
    var join = wisp_string.join;
}
var syntaxError = exports.syntaxError = function syntaxError(message, form) {
        return function () {
            var metadataø1 = meta(form);
            var lineø1 = ((metadataø1 || 0)['start'] || 0)['line'];
            var uriø1 = (metadataø1 || 0)['uri'];
            var columnø1 = ((metadataø1 || 0)['start'] || 0)['column'];
            var errorø1 = SyntaxError('' + message + '\n' + 'Form: ' + prStr(form) + '\n' + 'URI: ' + uriø1 + '\n' + 'Line: ' + lineø1 + '\n' + 'Column: ' + columnø1);
            errorø1.lineNumber = lineø1;
            errorø1.line = lineø1;
            errorø1.columnNumber = columnø1;
            errorø1.column = columnø1;
            errorø1.fileName = uriø1;
            errorø1.uri = uriø1;
            return (function () {
                throw errorø1;
            })();
        }.call(this);
    };
var analyzeKeyword = exports.analyzeKeyword = function analyzeKeyword(env, form) {
        return {
            'op': 'constant',
            'form': form
        };
    };
var __specials__ = exports.__specials__ = {};
var installSpecial = exports.installSpecial = function installSpecial(op, analyzer) {
        return (__specials__ || 0)[name(op)] = analyzer;
    };
var analyzeSpecial = exports.analyzeSpecial = function analyzeSpecial(analyzer, env, form) {
        return function () {
            var metadataø1 = meta(form);
            var astø1 = analyzer(env, form);
            return conj({
                'start': (metadataø1 || 0)['start'],
                'end': (metadataø1 || 0)['end']
            }, astø1);
        }.call(this);
    };
var analyzeIf = exports.analyzeIf = function analyzeIf(env, form) {
        return function () {
            var formsø1 = rest(form);
            var testø1 = analyze(env, first(formsø1));
            var consequentø1 = analyze(env, second(formsø1));
            var alternateø1 = analyze(env, third(formsø1));
            count(formsø1) < 2 ? syntaxError('Malformed if expression, too few operands', form) : void 0;
            return {
                'op': 'if',
                'form': form,
                'test': testø1,
                'consequent': consequentø1,
                'alternate': alternateø1
            };
        }.call(this);
    };
installSpecial('if', analyzeIf);
var analyzeThrow = exports.analyzeThrow = function analyzeThrow(env, form) {
        return function () {
            var expressionø1 = analyze(env, second(form));
            return {
                'op': 'throw',
                'form': form,
                'throw': expressionø1
            };
        }.call(this);
    };
installSpecial('throw', analyzeThrow);
var analyzeTry = exports.analyzeTry = function analyzeTry(env, form) {
        return function () {
            var formsø1 = vec(rest(form));
            var tailø1 = last(formsø1);
            var finalizerFormø1 = isList(tailø1) && isEqual(symbol(void 0, 'finally'), first(tailø1)) ? rest(tailø1) : void 0;
            var finalizerø1 = finalizerFormø1 ? analyzeBlock(env, finalizerFormø1) : void 0;
            var bodyFormø1 = finalizerø1 ? butlast(formsø1) : formsø1;
            var tailø2 = last(bodyFormø1);
            var handlerFormø1 = isList(tailø2) && isEqual(symbol(void 0, 'catch'), first(tailø2)) ? rest(tailø2) : void 0;
            var handlerø1 = handlerFormø1 ? conj({ 'name': analyze(env, first(handlerFormø1)) }, analyzeBlock(env, rest(handlerFormø1))) : void 0;
            var bodyø1 = handlerFormø1 ? analyzeBlock(subEnv(env), butlast(bodyFormø1)) : analyzeBlock(subEnv(env), bodyFormø1);
            return {
                'op': 'try',
                'form': form,
                'body': bodyø1,
                'handler': handlerø1,
                'finalizer': finalizerø1
            };
        }.call(this);
    };
installSpecial('try', analyzeTry);
var analyzeSet = exports.analyzeSet = function analyzeSet(env, form) {
        return function () {
            var bodyø1 = rest(form);
            var leftø1 = first(bodyø1);
            var rightø1 = second(bodyø1);
            var targetø1 = isSymbol(leftø1) ? analyzeSymbol(env, leftø1) : isList(leftø1) ? analyzeList(env, leftø1) : 'else' ? leftø1 : void 0;
            var valueø1 = analyze(env, rightø1);
            return {
                'op': 'set!',
                'target': targetø1,
                'value': valueø1,
                'form': form
            };
        }.call(this);
    };
installSpecial('set!', analyzeSet);
var analyzeNew = exports.analyzeNew = function analyzeNew(env, form) {
        return function () {
            var bodyø1 = rest(form);
            var constructorø1 = analyze(env, first(bodyø1));
            var paramsø1 = vec(map(function ($1) {
                    return analyze(env, $1);
                }, rest(bodyø1)));
            return {
                'op': 'new',
                'constructor': constructorø1,
                'form': form,
                'params': paramsø1
            };
        }.call(this);
    };
installSpecial('new', analyzeNew);
var analyzeAget = exports.analyzeAget = function analyzeAget(env, form) {
        return function () {
            var bodyø1 = rest(form);
            var targetø1 = analyze(env, first(bodyø1));
            var attributeø1 = second(bodyø1);
            var fieldø1 = isQuote(attributeø1) && isSymbol(second(attributeø1)) && second(attributeø1);
            return isNil(attributeø1) ? syntaxError('Malformed aget expression expected (aget object member)', form) : {
                'op': 'member-expression',
                'computed': !fieldø1,
                'form': form,
                'target': targetø1,
                'property': fieldø1 ? conj(analyzeSpecial(analyzeIdentifier, env, fieldø1), { 'binding': void 0 }) : analyze(env, attributeø1)
            };
        }.call(this);
    };
installSpecial('aget', analyzeAget);
var parseDef = exports.parseDef = function parseDef() {
        switch (arguments.length) {
        case 1:
            var id = arguments[0];
            return { 'id': id };
        case 2:
            var id = arguments[0];
            var init = arguments[1];
            return {
                'id': id,
                'init': init
            };
        case 3:
            var id = arguments[0];
            var doc = arguments[1];
            var init = arguments[2];
            return {
                'id': id,
                'doc': doc,
                'init': init
            };
        default:
            throw RangeError('Wrong number of arguments passed');
        }
    };
var analyzeDef = exports.analyzeDef = function analyzeDef(env, form) {
        return function () {
            var paramsø1 = parseDef.apply(void 0, vec(rest(form)));
            var idø1 = (paramsø1 || 0)['id'];
            var metadataø1 = meta(idø1);
            var bindingø1 = analyzeSpecial(analyzeDeclaration, env, idø1);
            var initø1 = analyze(env, (paramsø1 || 0)['init']);
            var docø1 = (paramsø1 || 0)['doc'] || (metadataø1 || 0)['doc'];
            return {
                'op': 'def',
                'doc': docø1,
                'id': bindingø1,
                'init': initø1,
                'export': (env || 0)['top'] && !(metadataø1 || 0)['private'],
                'form': form
            };
        }.call(this);
    };
installSpecial('def', analyzeDef);
var analyzeDo = exports.analyzeDo = function analyzeDo(env, form) {
        return function () {
            var expressionsø1 = rest(form);
            var bodyø1 = analyzeBlock(env, expressionsø1);
            return conj(bodyø1, {
                'op': 'do',
                'form': form
            });
        }.call(this);
    };
installSpecial('do', analyzeDo);
var analyzeSymbol = exports.analyzeSymbol = function analyzeSymbol(env, form) {
        return function () {
            var formsø1 = split(name(form), '.');
            var metadataø1 = meta(form);
            var startø1 = (metadataø1 || 0)['start'];
            var endø1 = (metadataø1 || 0)['end'];
            var expansionø1 = count(formsø1) > 1 ? list(symbol(void 0, 'aget'), withMeta(symbol(first(formsø1)), conj(metadataø1, {
                    'start': startø1,
                    'end': {
                        'line': (endø1 || 0)['line'],
                        'column': 1 + (startø1 || 0)['column'] + count(first(formsø1))
                    }
                })), list(symbol(void 0, 'quote'), withMeta(symbol(join('.', rest(formsø1))), conj(metadataø1, {
                    'end': endø1,
                    'start': {
                        'line': (startø1 || 0)['line'],
                        'column': 1 + (startø1 || 0)['column'] + count(first(formsø1))
                    }
                })))) : void 0;
            return expansionø1 ? analyze(env, withMeta(expansionø1, meta(form))) : analyzeSpecial(analyzeIdentifier, env, form);
        }.call(this);
    };
var analyzeIdentifier = exports.analyzeIdentifier = function analyzeIdentifier(env, form) {
        return {
            'op': 'var',
            'type': 'identifier',
            'form': form,
            'start': (meta(form) || 0)['start'],
            'end': (meta(form) || 0)['end'],
            'binding': resolveBinding(env, form)
        };
    };
var unresolvedBinding = exports.unresolvedBinding = function unresolvedBinding(env, form) {
        return {
            'op': 'unresolved-binding',
            'type': 'unresolved-binding',
            'identifier': {
                'type': 'identifier',
                'form': symbol(namespace(form), name(form))
            },
            'start': (meta(form) || 0)['start'],
            'end': (meta(form) || 0)['end']
        };
    };
var resolveBinding = exports.resolveBinding = function resolveBinding(env, form) {
        return ((env || 0)['locals'] || 0)[name(form)] || ((env || 0)['enclosed'] || 0)[name(form)] || unresolvedBinding(env, form);
    };
var analyzeShadow = exports.analyzeShadow = function analyzeShadow(env, id) {
        return function () {
            var bindingø1 = resolveBinding(env, id);
            return {
                'depth': inc((bindingø1 || 0)['depth'] || 0),
                'shadow': bindingø1
            };
        }.call(this);
    };
var analyzeBinding = exports.analyzeBinding = function analyzeBinding(env, form) {
        return function () {
            var idø1 = first(form);
            var bodyø1 = second(form);
            return conj(analyzeShadow(env, idø1), {
                'op': 'binding',
                'type': 'binding',
                'id': idø1,
                'init': analyze(env, bodyø1),
                'form': form
            });
        }.call(this);
    };
var analyzeDeclaration = exports.analyzeDeclaration = function analyzeDeclaration(env, form) {
        !!(namespace(form) || 1 < count(split('.', '' + form))) ? (function () {
            throw Error('' + 'Assert failed: ' + '' + '(not (or (namespace form) (< 1 (count (split "." (str form))))))');
        })() : void 0;
        return conj(analyzeShadow(env, form), {
            'op': 'var',
            'type': 'identifier',
            'depth': 0,
            'id': form,
            'form': form
        });
    };
var analyzeParam = exports.analyzeParam = function analyzeParam(env, form) {
        return conj(analyzeShadow(env, form), {
            'op': 'param',
            'type': 'parameter',
            'id': form,
            'form': form,
            'start': (meta(form) || 0)['start'],
            'end': (meta(form) || 0)['end']
        });
    };
var withBinding = exports.withBinding = function withBinding(env, form) {
        return conj(env, {
            'locals': assoc((env || 0)['locals'], name((form || 0)['id']), form),
            'bindings': conj((env || 0)['bindings'], form)
        });
    };
var withParam = exports.withParam = function withParam(env, form) {
        return conj(withBinding(env, form), { 'params': conj((env || 0)['params'], form) });
    };
var subEnv = exports.subEnv = function subEnv(env) {
        return {
            'enclosed': conj({}, (env || 0)['enclosed'], (env || 0)['locals']),
            'locals': {},
            'bindings': [],
            'params': (env || 0)['params'] || []
        };
    };
var analyzeLet_ = exports.analyzeLet_ = function analyzeLet_(env, form, isLoop) {
        return function () {
            var expressionsø1 = rest(form);
            var bindingsø1 = first(expressionsø1);
            var bodyø1 = rest(expressionsø1);
            var isValidBindingsø1 = isVector(bindingsø1) && isEven(count(bindingsø1));
            var _ø1 = !isValidBindingsø1 ? (function () {
                    throw Error('' + 'Assert failed: ' + 'bindings must be vector of even number of elements' + 'valid-bindings?');
                })() : void 0;
            var scopeø1 = reduce(function ($1, $2) {
                    return withBinding($1, analyzeBinding($1, $2));
                }, subEnv(env), partition(2, bindingsø1));
            var bindingsø2 = (scopeø1 || 0)['bindings'];
            var expressionsø2 = analyzeBlock(isLoop ? conj(scopeø1, { 'params': bindingsø2 }) : scopeø1, bodyø1);
            return {
                'op': 'let',
                'form': form,
                'start': (meta(form) || 0)['start'],
                'end': (meta(form) || 0)['end'],
                'bindings': bindingsø2,
                'statements': (expressionsø2 || 0)['statements'],
                'result': (expressionsø2 || 0)['result']
            };
        }.call(this);
    };
var analyzeLet = exports.analyzeLet = function analyzeLet(env, form) {
        return analyzeLet_(env, form, false);
    };
installSpecial('let', analyzeLet);
var analyzeLoop = exports.analyzeLoop = function analyzeLoop(env, form) {
        return conj(analyzeLet_(env, form, true), { 'op': 'loop' });
    };
installSpecial('loop', analyzeLoop);
var analyzeRecur = exports.analyzeRecur = function analyzeRecur(env, form) {
        return function () {
            var paramsø1 = (env || 0)['params'];
            var formsø1 = vec(map(function ($1) {
                    return analyze(env, $1);
                }, rest(form)));
            return isEqual(count(paramsø1), count(formsø1)) ? {
                'op': 'recur',
                'form': form,
                'params': formsø1
            } : syntaxError('Recurs with wrong number of arguments', form);
        }.call(this);
    };
installSpecial('recur', analyzeRecur);
var analyzeQuotedList = exports.analyzeQuotedList = function analyzeQuotedList(form) {
        return {
            'op': 'list',
            'items': map(analyzeQuoted, vec(form)),
            'form': form,
            'start': (meta(form) || 0)['start'],
            'end': (meta(form) || 0)['end']
        };
    };
var analyzeQuotedVector = exports.analyzeQuotedVector = function analyzeQuotedVector(form) {
        return {
            'op': 'vector',
            'items': map(analyzeQuoted, form),
            'form': form,
            'start': (meta(form) || 0)['start'],
            'end': (meta(form) || 0)['end']
        };
    };
var analyzeQuotedDictionary = exports.analyzeQuotedDictionary = function analyzeQuotedDictionary(form) {
        return function () {
            var namesø1 = vec(map(analyzeQuoted, keys(form)));
            var valuesø1 = vec(map(analyzeQuoted, vals(form)));
            return {
                'op': 'dictionary',
                'form': form,
                'keys': namesø1,
                'values': valuesø1,
                'start': (meta(form) || 0)['start'],
                'end': (meta(form) || 0)['end']
            };
        }.call(this);
    };
var analyzeQuotedSymbol = exports.analyzeQuotedSymbol = function analyzeQuotedSymbol(form) {
        return {
            'op': 'symbol',
            'name': name(form),
            'namespace': namespace(form),
            'form': form
        };
    };
var analyzeQuotedKeyword = exports.analyzeQuotedKeyword = function analyzeQuotedKeyword(form) {
        return {
            'op': 'keyword',
            'name': name(form),
            'namespace': namespace(form),
            'form': form
        };
    };
var analyzeQuoted = exports.analyzeQuoted = function analyzeQuoted(form) {
        return isSymbol(form) ? analyzeQuotedSymbol(form) : isKeyword(form) ? analyzeQuotedKeyword(form) : isList(form) ? analyzeQuotedList(form) : isVector(form) ? analyzeQuotedVector(form) : isDictionary(form) ? analyzeQuotedDictionary(form) : 'else' ? {
            'op': 'constant',
            'form': form
        } : void 0;
    };
var analyzeQuote = exports.analyzeQuote = function analyzeQuote(env, form) {
        return analyzeQuoted(second(form));
    };
installSpecial('quote', analyzeQuote);
var analyzeStatement = exports.analyzeStatement = function analyzeStatement(env, form) {
        return function () {
            var statementsø1 = (env || 0)['statements'] || [];
            var bindingsø1 = (env || 0)['bindings'] || [];
            var statementø1 = analyze(conj(env, { 'statements': void 0 }), form);
            var opø1 = (statementø1 || 0)['op'];
            var defsø1 = isEqual(opø1, 'def') ? [(statementø1 || 0)['var']] : 'else' ? void 0 : void 0;
            return conj(env, {
                'statements': conj(statementsø1, statementø1),
                'bindings': concat(bindingsø1, defsø1)
            });
        }.call(this);
    };
var analyzeBlock = exports.analyzeBlock = function analyzeBlock(env, form) {
        return function () {
            var bodyø1 = count(form) > 1 ? reduce(analyzeStatement, env, butlast(form)) : void 0;
            var resultø1 = analyze(bodyø1 || env, last(form));
            return {
                'statements': (bodyø1 || 0)['statements'],
                'result': resultø1
            };
        }.call(this);
    };
var analyzeFnMethod = exports.analyzeFnMethod = function analyzeFnMethod(env, form) {
        return function () {
            var signatureø1 = isList(form) && isVector(first(form)) ? first(form) : syntaxError('Malformed fn overload form', form);
            var bodyø1 = rest(form);
            var variadicø1 = some(function ($1) {
                    return isEqual(symbol(void 0, '&'), $1);
                }, signatureø1);
            var paramsø1 = variadicø1 ? filter(function ($1) {
                    return !isEqual(symbol(void 0, '&'), $1);
                }, signatureø1) : signatureø1;
            var arityø1 = variadicø1 ? dec(count(paramsø1)) : count(paramsø1);
            var scopeø1 = reduce(function ($1, $2) {
                    return withParam($1, analyzeParam($1, $2));
                }, conj(env, { 'params': [] }), paramsø1);
            return conj(analyzeBlock(scopeø1, bodyø1), {
                'op': 'overload',
                'variadic': variadicø1,
                'arity': arityø1,
                'params': (scopeø1 || 0)['params'],
                'form': form
            });
        }.call(this);
    };
var analyzeFn = exports.analyzeFn = function analyzeFn(env, form) {
        return function () {
            var formsø1 = rest(form);
            var formsø2 = isSymbol(first(formsø1)) ? formsø1 : cons(void 0, formsø1);
            var idø1 = first(formsø2);
            var bindingø1 = idø1 ? analyzeSpecial(analyzeDeclaration, env, idø1) : void 0;
            var bodyø1 = rest(formsø2);
            var overloadsø1 = isVector(first(bodyø1)) ? list(bodyø1) : isList(first(bodyø1)) && isVector(first(first(bodyø1))) ? bodyø1 : 'else' ? syntaxError('' + 'Malformed fn expression, ' + 'parameter declaration (' + prStr(first(bodyø1)) + ') must be a vector', form) : void 0;
            var scopeø1 = bindingø1 ? withBinding(subEnv(env), bindingø1) : subEnv(env);
            var methodsø1 = map(function ($1) {
                    return analyzeFnMethod(scopeø1, $1);
                }, vec(overloadsø1));
            var arityø1 = max.apply(void 0, map(function ($1) {
                    return ($1 || 0)['arity'];
                }, methodsø1));
            var variadicø1 = some(function ($1) {
                    return ($1 || 0)['variadic'];
                }, methodsø1);
            return {
                'op': 'fn',
                'type': 'function',
                'id': bindingø1,
                'variadic': variadicø1,
                'methods': methodsø1,
                'form': form
            };
        }.call(this);
    };
installSpecial('fn', analyzeFn);
var parseReferences = exports.parseReferences = function parseReferences(forms) {
        return reduce(function (references, form) {
            return isSeq(form) ? assoc(references, name(first(form)), vec(rest(form))) : references;
        }, {}, forms);
    };
var parseRequire = exports.parseRequire = function parseRequire(form) {
        return function () {
            var requirementø1 = isSymbol(form) ? [form] : vec(form);
            var idø1 = first(requirementø1);
            var paramsø1 = dictionary.apply(void 0, rest(requirementø1));
            var renamesø1 = (paramsø1 || 0)['\uA789rename'];
            var namesø1 = (paramsø1 || 0)['\uA789refer'];
            var aliasø1 = (paramsø1 || 0)['\uA789as'];
            var referencesø1 = !isEmpty(namesø1) ? reduce(function (refers, reference) {
                    return conj(refers, {
                        'op': 'refer',
                        'form': reference,
                        'name': reference,
                        'rename': (renamesø1 || 0)[reference] || (renamesø1 || 0)[name(reference)],
                        'ns': idø1
                    });
                }, [], namesø1) : void 0;
            return {
                'op': 'require',
                'alias': aliasø1,
                'ns': idø1,
                'refer': referencesø1,
                'form': form
            };
        }.call(this);
    };
var analyzeNs = exports.analyzeNs = function analyzeNs(env, form) {
        return function () {
            var formsø1 = rest(form);
            var nameø1 = first(formsø1);
            var bodyø1 = rest(formsø1);
            var docø1 = isString(first(bodyø1)) ? first(bodyø1) : void 0;
            var referencesø1 = parseReferences(docø1 ? rest(bodyø1) : bodyø1);
            var requirementsø1 = (referencesø1 || 0)['require'] ? map(parseRequire, (referencesø1 || 0)['require']) : void 0;
            return {
                'op': 'ns',
                'name': nameø1,
                'doc': docø1,
                'require': requirementsø1 ? vec(requirementsø1) : void 0,
                'form': form
            };
        }.call(this);
    };
installSpecial('ns', analyzeNs);
var analyzeList = exports.analyzeList = function analyzeList(env, form) {
        return function () {
            var expansionø1 = macroexpand(form, env);
            var operatorø1 = first(form);
            var analyzerø1 = isSymbol(operatorø1) && (__specials__ || 0)[name(operatorø1)];
            return !(expansionø1 === form) ? analyze(env, expansionø1) : analyzerø1 ? analyzeSpecial(analyzerø1, env, expansionø1) : 'else' ? analyzeInvoke(env, expansionø1) : void 0;
        }.call(this);
    };
var analyzeVector = exports.analyzeVector = function analyzeVector(env, form) {
        return function () {
            var itemsø1 = vec(map(function ($1) {
                    return analyze(env, $1);
                }, form));
            return {
                'op': 'vector',
                'form': form,
                'items': itemsø1
            };
        }.call(this);
    };
var analyzeDictionary = exports.analyzeDictionary = function analyzeDictionary(env, form) {
        return function () {
            var namesø1 = vec(map(function ($1) {
                    return analyze(env, $1);
                }, keys(form)));
            var valuesø1 = vec(map(function ($1) {
                    return analyze(env, $1);
                }, vals(form)));
            return {
                'op': 'dictionary',
                'keys': namesø1,
                'values': valuesø1,
                'form': form
            };
        }.call(this);
    };
var analyzeInvoke = exports.analyzeInvoke = function analyzeInvoke(env, form) {
        return function () {
            var calleeø1 = analyze(env, first(form));
            var paramsø1 = vec(map(function ($1) {
                    return analyze(env, $1);
                }, rest(form)));
            return {
                'op': 'invoke',
                'callee': calleeø1,
                'params': paramsø1,
                'form': form
            };
        }.call(this);
    };
var analyzeConstant = exports.analyzeConstant = function analyzeConstant(env, form) {
        return {
            'op': 'constant',
            'form': form
        };
    };
var analyze = exports.analyze = function analyze() {
        switch (arguments.length) {
        case 1:
            var form = arguments[0];
            return analyze({
                'locals': {},
                'bindings': [],
                'top': true
            }, form);
        case 2:
            var env = arguments[0];
            var form = arguments[1];
            return isNil(form) ? analyzeConstant(env, form) : isSymbol(form) ? analyzeSymbol(env, form) : isList(form) ? isEmpty(form) ? analyzeQuoted(form) : analyzeList(env, form) : isDictionary(form) ? analyzeDictionary(env, form) : isVector(form) ? analyzeVector(env, form) : isKeyword(form) ? analyzeKeyword(env, form) : 'else' ? analyzeConstant(env, form) : void 0;
        default:
            throw RangeError('Wrong number of arguments passed');
        }
    };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFub255bW91cy53aXNwIl0sIm5hbWVzIjpbIl9uc18iLCJpZCIsImRvYyIsIm1ldGEiLCJ3aXRoTWV0YSIsImlzU3ltYm9sIiwiaXNLZXl3b3JkIiwiaXNRdW90ZSIsInN5bWJvbCIsIm5hbWVzcGFjZSIsIm5hbWUiLCJwclN0ciIsImlzVW5xdW90ZSIsImlzVW5xdW90ZVNwbGljaW5nIiwiaXNMaXN0IiwibGlzdCIsImNvbmoiLCJwYXJ0aXRpb24iLCJzZXEiLCJpc0VtcHR5IiwibWFwIiwidmVjIiwiaXNFdmVyeSIsImNvbmNhdCIsImZpcnN0Iiwic2Vjb25kIiwidGhpcmQiLCJyZXN0IiwibGFzdCIsImJ1dGxhc3QiLCJpbnRlcmxlYXZlIiwiY29ucyIsImNvdW50Iiwic29tZSIsImFzc29jIiwicmVkdWNlIiwiZmlsdGVyIiwiaXNTZXEiLCJpc05pbCIsImlzRGljdGlvbmFyeSIsImlzVmVjdG9yIiwia2V5cyIsInZhbHMiLCJpc1N0cmluZyIsImlzTnVtYmVyIiwiaXNCb29sZWFuIiwiaXNEYXRlIiwiaXNSZVBhdHRlcm4iLCJpc0V2ZW4iLCJpc0VxdWFsIiwibWF4IiwiZGVjIiwiZGljdGlvbmFyeSIsInN1YnMiLCJpbmMiLCJtYWNyb2V4cGFuZCIsInNwbGl0Iiwiam9pbiIsInN5bnRheEVycm9yIiwiZXhwb3J0cyIsIm1lc3NhZ2UiLCJmb3JtIiwibWV0YWRhdGHDuDEiLCJsaW5lw7gxIiwidXJpw7gxIiwiY29sdW1uw7gxIiwiZXJyb3LDuDEiLCJTeW50YXhFcnJvciIsImxpbmVOdW1iZXIiLCJsaW5lIiwiY29sdW1uTnVtYmVyIiwiY29sdW1uIiwiZmlsZU5hbWUiLCJ1cmkiLCJhbmFseXplS2V5d29yZCIsImVudiIsIl9fc3BlY2lhbHNfXyIsImluc3RhbGxTcGVjaWFsIiwib3AiLCJhbmFseXplciIsImFuYWx5emVTcGVjaWFsIiwiYXN0w7gxIiwiYW5hbHl6ZUlmIiwiZm9ybXPDuDEiLCJ0ZXN0w7gxIiwiYW5hbHl6ZSIsImNvbnNlcXVlbnTDuDEiLCJhbHRlcm5hdGXDuDEiLCJhbmFseXplVGhyb3ciLCJleHByZXNzaW9uw7gxIiwiYW5hbHl6ZVRyeSIsInRhaWzDuDEiLCJmaW5hbGl6ZXJGb3Jtw7gxIiwiZmluYWxpemVyw7gxIiwiYW5hbHl6ZUJsb2NrIiwiYm9keUZvcm3DuDEiLCJ0YWlsw7gyIiwiaGFuZGxlckZvcm3DuDEiLCJoYW5kbGVyw7gxIiwiYm9kecO4MSIsInN1YkVudiIsImFuYWx5emVTZXQiLCJsZWZ0w7gxIiwicmlnaHTDuDEiLCJ0YXJnZXTDuDEiLCJhbmFseXplU3ltYm9sIiwiYW5hbHl6ZUxpc3QiLCJ2YWx1ZcO4MSIsImFuYWx5emVOZXciLCJjb25zdHJ1Y3RvcsO4MSIsInBhcmFtc8O4MSIsIiQxIiwiYW5hbHl6ZUFnZXQiLCJhdHRyaWJ1dGXDuDEiLCJmaWVsZMO4MSIsImFuYWx5emVJZGVudGlmaWVyIiwicGFyc2VEZWYiLCJpbml0IiwiYW5hbHl6ZURlZiIsImlkw7gxIiwiYmluZGluZ8O4MSIsImFuYWx5emVEZWNsYXJhdGlvbiIsImluaXTDuDEiLCJkb2PDuDEiLCJhbmFseXplRG8iLCJleHByZXNzaW9uc8O4MSIsInN0YXJ0w7gxIiwiZW5kw7gxIiwiZXhwYW5zaW9uw7gxIiwicmVzb2x2ZUJpbmRpbmciLCJ1bnJlc29sdmVkQmluZGluZyIsImFuYWx5emVTaGFkb3ciLCJhbmFseXplQmluZGluZyIsImFuYWx5emVQYXJhbSIsIndpdGhCaW5kaW5nIiwid2l0aFBhcmFtIiwiYW5hbHl6ZUxldF8iLCJpc0xvb3AiLCJiaW5kaW5nc8O4MSIsImlzVmFsaWRCaW5kaW5nc8O4MSIsIl/DuDEiLCJzY29wZcO4MSIsIiQyIiwiYmluZGluZ3PDuDIiLCJleHByZXNzaW9uc8O4MiIsImFuYWx5emVMZXQiLCJhbmFseXplTG9vcCIsImFuYWx5emVSZWN1ciIsImFuYWx5emVRdW90ZWRMaXN0IiwiYW5hbHl6ZVF1b3RlZCIsImFuYWx5emVRdW90ZWRWZWN0b3IiLCJhbmFseXplUXVvdGVkRGljdGlvbmFyeSIsIm5hbWVzw7gxIiwidmFsdWVzw7gxIiwiYW5hbHl6ZVF1b3RlZFN5bWJvbCIsImFuYWx5emVRdW90ZWRLZXl3b3JkIiwiYW5hbHl6ZVF1b3RlIiwiYW5hbHl6ZVN0YXRlbWVudCIsInN0YXRlbWVudHPDuDEiLCJzdGF0ZW1lbnTDuDEiLCJvcMO4MSIsImRlZnPDuDEiLCJyZXN1bHTDuDEiLCJhbmFseXplRm5NZXRob2QiLCJzaWduYXR1cmXDuDEiLCJ2YXJpYWRpY8O4MSIsImFyaXR5w7gxIiwiYW5hbHl6ZUZuIiwiZm9ybXPDuDIiLCJvdmVybG9hZHPDuDEiLCJtZXRob2Rzw7gxIiwicGFyc2VSZWZlcmVuY2VzIiwiZm9ybXMiLCJyZWZlcmVuY2VzIiwicGFyc2VSZXF1aXJlIiwicmVxdWlyZW1lbnTDuDEiLCJyZW5hbWVzw7gxIiwiYWxpYXPDuDEiLCJyZWZlcmVuY2Vzw7gxIiwicmVmZXJzIiwicmVmZXJlbmNlIiwiYW5hbHl6ZU5zIiwibmFtZcO4MSIsInJlcXVpcmVtZW50c8O4MSIsIm9wZXJhdG9yw7gxIiwiYW5hbHl6ZXLDuDEiLCJhbmFseXplSW52b2tlIiwiYW5hbHl6ZVZlY3RvciIsIml0ZW1zw7gxIiwiYW5hbHl6ZURpY3Rpb25hcnkiLCJjYWxsZWXDuDEiLCJhbmFseXplQ29uc3RhbnQiXSwibWFwcGluZ3MiOiI7SUFBQSxJQUFDQSxJLEdBQUQ7QUFBQSxZQUFBQyxFLEVBQUksZUFBSjtBQUFBLFlBQUFDLEcsRUFBQSxLLENBQUE7QUFBQSxVOztRQUM4QkMsSUFBQSxHLFNBQUFBLEk7UUFBS0MsUUFBQSxHLFNBQUFBLFE7UUFBVUMsUUFBQSxHLFNBQUFBLFE7UUFBUUMsU0FBQSxHLFNBQUFBLFM7UUFDdkJDLE9BQUEsRyxTQUFBQSxPO1FBQU9DLE1BQUEsRyxTQUFBQSxNO1FBQU9DLFNBQUEsRyxTQUFBQSxTO1FBQVVDLElBQUEsRyxTQUFBQSxJO1FBQUtDLEtBQUEsRyxTQUFBQSxLO1FBQzdCQyxTQUFBLEcsU0FBQUEsUztRQUFTQyxpQkFBQSxHLFNBQUFBLGlCOztRQUNKQyxNQUFBLEcs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LENBSUdwSCxHQUpILEVBSU9kLElBSlAsRUFLRTtBQUFBO0FBQUEsWSxnQkFBQTtBQUFBLFksUUFDT0EsSUFEUDtBQUFBO0FBQUEsS0FMRixDO0FBUUEsSUFBTXdCLE9BQUEsR0FBQTFCLE9BQUEsQ0FBQTBCLE9BQUEsR0FBTixTQUFNQSxPQUFOLEc7OztnQkFrQkl4QixJQUFBLEc7WUFBTSxPQUFDd0IsT0FBRCxDQUFTO0FBQUEsZ0IsVUFBUyxFQUFUO0FBQUEsZ0IsWUFDVyxFQURYO0FBQUEsZ0IsV0FBQTtBQUFBLGFBQVQsRUFFcUJ4QixJQUZyQixFOztnQkFHTmMsR0FBQSxHO2dCQUFJZCxJQUFBLEc7WUFDTCxPQUFPdkIsS0FBRCxDQUFNdUIsSUFBTixDQUFOLEdBQW1Ca0ksZUFBRCxDQUFrQnBILEdBQWxCLEVBQXNCZCxJQUF0QixDQUFsQixHQUNPeEQsUUFBRCxDQUFTd0QsSUFBVCxDLEdBQWdCNEMsYUFBRCxDQUFnQjlCLEdBQWhCLEVBQW9CZCxJQUFwQixDLEdBQ2QvQyxNQUFELENBQU8rQyxJQUFQLEMsR0FBa0IxQyxPQUFELENBQVEwQyxJQUFSLENBQUosR0FDR3dGLGFBQUQsQ0FBZ0J4RixJQUFoQixDQURGLEdBRUc2QyxXQUFELENBQWMvQixHQUFkLEVBQWtCZCxJQUFsQixDLEdBQ2R0QixZQUFELENBQWFzQixJQUFiLEMsR0FBb0JnSSxpQkFBRCxDQUFvQmxILEdBQXBCLEVBQXdCZCxJQUF4QixDLEdBQ2xCckIsUUFBRCxDQUFTcUIsSUFBVCxDLEdBQWdCOEgsYUFBRCxDQUFnQmhILEdBQWhCLEVBQW9CZCxJQUFwQixDLEdBRWR2RCxTQUFELENBQVV1RCxJQUFWLEMsR0FBaUJhLGNBQUQsQ0FBaUJDLEdBQWpCLEVBQXFCZCxJQUFyQixDLFlBQ1RrSSxlQUFELENBQWtCcEgsR0FBbEIsRUFBc0JkLElBQXRCLEMsU0FUWixDOzs7O0tBdEJIIiwic291cmNlc0NvbnRlbnQiOlsiKG5zIHdpc3AuYW5hbHl6ZXJcbiAgKDpyZXF1aXJlIFt3aXNwLmFzdCA6cmVmZXIgW21ldGEgd2l0aC1tZXRhIHN5bWJvbD8ga2V5d29yZD9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1b3RlPyBzeW1ib2wgbmFtZXNwYWNlIG5hbWUgcHItc3RyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bnF1b3RlPyB1bnF1b3RlLXNwbGljaW5nP11dXG4gICAgICAgICAgICBbd2lzcC5zZXF1ZW5jZSA6cmVmZXIgW2xpc3Q/IGxpc3QgY29uaiBwYXJ0aXRpb24gc2VxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtcHR5PyBtYXAgdmVjIGV2ZXJ5PyBjb25jYXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3Qgc2Vjb25kIHRoaXJkIHJlc3QgbGFzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXRsYXN0IGludGVybGVhdmUgY29ucyBjb3VudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb21lIGFzc29jIHJlZHVjZSBmaWx0ZXIgc2VxP11dXG4gICAgICAgICAgICBbd2lzcC5ydW50aW1lIDpyZWZlciBbbmlsPyBkaWN0aW9uYXJ5PyB2ZWN0b3I/IGtleXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxzIHN0cmluZz8gbnVtYmVyPyBib29sZWFuP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGU/IHJlLXBhdHRlcm4/IGV2ZW4/ID0gbWF4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjIGRpY3Rpb25hcnkgc3VicyBpbmMgZGVjXV1cbiAgICAgICAgICAgIFt3aXNwLmV4cGFuZGVyIDpyZWZlciBbbWFjcm9leHBhbmRdXVxuICAgICAgICAgICAgW3dpc3Auc3RyaW5nIDpyZWZlciBbc3BsaXQgam9pbl1dKSlcblxuKGRlZm4gc3ludGF4LWVycm9yXG4gIFttZXNzYWdlIGZvcm1dXG4gIChsZXQgW21ldGFkYXRhIChtZXRhIGZvcm0pXG4gICAgICAgIGxpbmUgKDpsaW5lICg6c3RhcnQgbWV0YWRhdGEpKVxuICAgICAgICB1cmkgKDp1cmkgbWV0YWRhdGEpXG4gICAgICAgIGNvbHVtbiAoOmNvbHVtbiAoOnN0YXJ0IG1ldGFkYXRhKSlcbiAgICAgICAgZXJyb3IgKFN5bnRheEVycm9yIChzdHIgbWVzc2FnZSBcIlxcblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiRm9ybTogXCIgKHByLXN0ciBmb3JtKSBcIlxcblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiVVJJOiBcIiB1cmkgXCJcXG5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkxpbmU6IFwiIGxpbmUgXCJcXG5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkNvbHVtbjogXCIgY29sdW1uKSldXG4gICAgKHNldCEgZXJyb3IubGluZU51bWJlciBsaW5lKVxuICAgIChzZXQhIGVycm9yLmxpbmUgbGluZSlcbiAgICAoc2V0ISBlcnJvci5jb2x1bW5OdW1iZXIgY29sdW1uKVxuICAgIChzZXQhIGVycm9yLmNvbHVtbiBjb2x1bW4pXG4gICAgKHNldCEgZXJyb3IuZmlsZU5hbWUgdXJpKVxuICAgIChzZXQhIGVycm9yLnVyaSB1cmkpXG4gICAgKHRocm93IGVycm9yKSkpXG5cblxuKGRlZm4gYW5hbHl6ZS1rZXl3b3JkXG4gIFwiRXhhbXBsZTpcbiAgKGFuYWx5emUta2V5d29yZCB7fSA6Zm9vKSA9PiB7Om9wIDpjb25zdGFudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Zm9ybSAnOmZvb1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ZW52IHt9fVwiXG4gIFtlbnYgZm9ybV1cbiAgezpvcCA6Y29uc3RhbnRcbiAgIDpmb3JtIGZvcm19KVxuXG4oZGVmICoqc3BlY2lhbHMqKiB7fSlcblxuKGRlZm4gaW5zdGFsbC1zcGVjaWFsIVxuICBbb3AgYW5hbHl6ZXJdXG4gIChzZXQhIChnZXQgKipzcGVjaWFscyoqIChuYW1lIG9wKSkgYW5hbHl6ZXIpKVxuXG4oZGVmbiBhbmFseXplLXNwZWNpYWxcbiAgW2FuYWx5emVyIGVudiBmb3JtXVxuICAobGV0IFttZXRhZGF0YSAobWV0YSBmb3JtKVxuICAgICAgICBhc3QgKGFuYWx5emVyIGVudiBmb3JtKV1cbiAgICAoY29uaiB7OnN0YXJ0ICg6c3RhcnQgbWV0YWRhdGEpXG4gICAgICAgICAgIDplbmQgKDplbmQgbWV0YWRhdGEpfVxuICAgICAgICAgIGFzdCkpKVxuXG4oZGVmbiBhbmFseXplLWlmXG4gIFwiRXhhbXBsZTpcbiAgKGFuYWx5emUtaWYge30gJyhpZiBtb25kYXk/IDp5ZXAgOm5vcGUpKSA9PiB7Om9wIDppZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Zm9ybSAnKGlmIG1vbmRheT8gOnllcCA6bm9wZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOmVudiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6dGVzdCB7Om9wIDp2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpmb3JtICdtb25kYXk/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6aW5mbyBuaWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDplbnYge319XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpjb25zZXF1ZW50IHs6b3AgOmNvbnN0YW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Zm9ybSAnOnllcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOnR5cGUgOmtleXdvcmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDplbnYge319XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDphbHRlcm5hdGUgezpvcCA6Y29uc3RhbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOmZvcm0gJzpub3BlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDp0eXBlIDprZXl3b3JkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDplbnYge319fVwiXG4gIFtlbnYgZm9ybV1cbiAgKGxldCBbZm9ybXMgKHJlc3QgZm9ybSlcbiAgICAgICAgdGVzdCAoYW5hbHl6ZSBlbnYgKGZpcnN0IGZvcm1zKSlcbiAgICAgICAgY29uc2VxdWVudCAoYW5hbHl6ZSBlbnYgKHNlY29uZCBmb3JtcykpXG4gICAgICAgIGFsdGVybmF0ZSAoYW5hbHl6ZSBlbnYgKHRoaXJkIGZvcm1zKSldXG4gICAgKGlmICg8IChjb3VudCBmb3JtcykgMilcbiAgICAgIChzeW50YXgtZXJyb3IgXCJNYWxmb3JtZWQgaWYgZXhwcmVzc2lvbiwgdG9vIGZldyBvcGVyYW5kc1wiIGZvcm0pKVxuICAgIHs6b3AgOmlmXG4gICAgIDpmb3JtIGZvcm1cbiAgICAgOnRlc3QgdGVzdFxuICAgICA6Y29uc2VxdWVudCBjb25zZXF1ZW50XG4gICAgIDphbHRlcm5hdGUgYWx0ZXJuYXRlfSkpXG5cbihpbnN0YWxsLXNwZWNpYWwhIDppZiBhbmFseXplLWlmKVxuXG4oZGVmbiBhbmFseXplLXRocm93XG4gIFwiRXhhbXBsZTpcbiAgKGFuYWx5emUtdGhyb3cge30gJyh0aHJvdyAoRXJyb3IgOmJvb20pKSkgPT4gezpvcCA6dGhyb3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpmb3JtICcodGhyb3cgKEVycm9yIDpib29tKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDp0aHJvdyB7Om9wIDppbnZva2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOmNhbGxlZSB7Om9wIDp2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOmZvcm0gJ0Vycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDppbmZvIG5pbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ZW52IHt9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6cGFyYW1zIFt7Om9wIDpjb25zdGFudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOnR5cGUgOmtleXdvcmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpmb3JtICc6Ym9vbVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOmVudiB7fX1dfX1cIlxuICBbZW52IGZvcm1dXG4gIChsZXQgW2V4cHJlc3Npb24gKGFuYWx5emUgZW52IChzZWNvbmQgZm9ybSkpXVxuICAgIHs6b3AgOnRocm93XG4gICAgIDpmb3JtIGZvcm1cbiAgICAgOnRocm93IGV4cHJlc3Npb259KSlcblxuKGluc3RhbGwtc3BlY2lhbCEgOnRocm93IGFuYWx5emUtdGhyb3cpXG5cbihkZWZuIGFuYWx5emUtdHJ5XG4gIFtlbnYgZm9ybV1cbiAgKGxldCBbZm9ybXMgKHZlYyAocmVzdCBmb3JtKSlcblxuICAgICAgICA7OyBGaW5hbGx5XG4gICAgICAgIHRhaWwgKGxhc3QgZm9ybXMpXG4gICAgICAgIGZpbmFsaXplci1mb3JtIChpZiAoYW5kIChsaXN0PyB0YWlsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoPSAnZmluYWxseSAoZmlyc3QgdGFpbCkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgIChyZXN0IHRhaWwpKVxuICAgICAgICBmaW5hbGl6ZXIgKGlmIGZpbmFsaXplci1mb3JtXG4gICAgICAgICAgICAgICAgICAgIChhbmFseXplLWJsb2NrIGVudiBmaW5hbGl6ZXItZm9ybSkpXG5cbiAgICAgICAgOzsgY2F0Y2hcbiAgICAgICAgYm9keS1mb3JtIChpZiBmaW5hbGl6ZXJcbiAgICAgICAgICAgICAgICAgICAgKGJ1dGxhc3QgZm9ybXMpXG4gICAgICAgICAgICAgICAgICAgIGZvcm1zKVxuXG4gICAgICAgIHRhaWwgKGxhc3QgYm9keS1mb3JtKVxuICAgICAgICBoYW5kbGVyLWZvcm0gKGlmIChhbmQgKGxpc3Q/IHRhaWwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoPSAnY2F0Y2ggKGZpcnN0IHRhaWwpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgKHJlc3QgdGFpbCkpXG4gICAgICAgIGhhbmRsZXIgKGlmIGhhbmRsZXItZm9ybVxuICAgICAgICAgICAgICAgICAgKGNvbmogezpuYW1lIChhbmFseXplIGVudiAoZmlyc3QgaGFuZGxlci1mb3JtKSl9XG4gICAgICAgICAgICAgICAgICAgICAgICAoYW5hbHl6ZS1ibG9jayBlbnYgKHJlc3QgaGFuZGxlci1mb3JtKSkpKVxuXG4gICAgICAgIDs7IFRyeVxuICAgICAgICBib2R5IChpZiBoYW5kbGVyLWZvcm1cbiAgICAgICAgICAgICAgIChhbmFseXplLWJsb2NrIChzdWItZW52IGVudikgKGJ1dGxhc3QgYm9keS1mb3JtKSlcbiAgICAgICAgICAgICAgIChhbmFseXplLWJsb2NrIChzdWItZW52IGVudikgYm9keS1mb3JtKSldXG4gICAgezpvcCA6dHJ5XG4gICAgIDpmb3JtIGZvcm1cbiAgICAgOmJvZHkgYm9keVxuICAgICA6aGFuZGxlciBoYW5kbGVyXG4gICAgIDpmaW5hbGl6ZXIgZmluYWxpemVyfSkpXG5cbihpbnN0YWxsLXNwZWNpYWwhIDp0cnkgYW5hbHl6ZS10cnkpXG5cbihkZWZuIGFuYWx5emUtc2V0IVxuICBbZW52IGZvcm1dXG4gIChsZXQgW2JvZHkgKHJlc3QgZm9ybSlcbiAgICAgICAgbGVmdCAoZmlyc3QgYm9keSlcbiAgICAgICAgcmlnaHQgKHNlY29uZCBib2R5KVxuICAgICAgICB0YXJnZXQgKGNvbmQgKHN5bWJvbD8gbGVmdCkgKGFuYWx5emUtc3ltYm9sIGVudiBsZWZ0KVxuICAgICAgICAgICAgICAgICAgICAgKGxpc3Q/IGxlZnQpIChhbmFseXplLWxpc3QgZW52IGxlZnQpXG4gICAgICAgICAgICAgICAgICAgICA6ZWxzZSBsZWZ0KVxuICAgICAgICB2YWx1ZSAoYW5hbHl6ZSBlbnYgcmlnaHQpXVxuICAgIHs6b3AgOnNldCFcbiAgICAgOnRhcmdldCB0YXJnZXRcbiAgICAgOnZhbHVlIHZhbHVlXG4gICAgIDpmb3JtIGZvcm19KSlcbihpbnN0YWxsLXNwZWNpYWwhIDpzZXQhIGFuYWx5emUtc2V0ISlcblxuKGRlZm4gYW5hbHl6ZS1uZXdcbiAgW2VudiBmb3JtXVxuICAobGV0IFtib2R5IChyZXN0IGZvcm0pXG4gICAgICAgIGNvbnN0cnVjdG9yIChhbmFseXplIGVudiAoZmlyc3QgYm9keSkpXG4gICAgICAgIHBhcmFtcyAodmVjIChtYXAgIyhhbmFseXplIGVudiAlKSAocmVzdCBib2R5KSkpXVxuICAgIHs6b3AgOm5ld1xuICAgICA6Y29uc3RydWN0b3IgY29uc3RydWN0b3JcbiAgICAgOmZvcm0gZm9ybVxuICAgICA6cGFyYW1zIHBhcmFtc30pKVxuKGluc3RhbGwtc3BlY2lhbCEgOm5ldyBhbmFseXplLW5ldylcblxuKGRlZm4gYW5hbHl6ZS1hZ2V0XG4gIFtlbnYgZm9ybV1cbiAgKGxldCBbYm9keSAocmVzdCBmb3JtKVxuICAgICAgICB0YXJnZXQgKGFuYWx5emUgZW52IChmaXJzdCBib2R5KSlcbiAgICAgICAgYXR0cmlidXRlIChzZWNvbmQgYm9keSlcbiAgICAgICAgZmllbGQgKGFuZCAocXVvdGU/IGF0dHJpYnV0ZSlcbiAgICAgICAgICAgICAgICAgICAoc3ltYm9sPyAoc2Vjb25kIGF0dHJpYnV0ZSkpXG4gICAgICAgICAgICAgICAgICAgKHNlY29uZCBhdHRyaWJ1dGUpKV1cbiAgICAoaWYgKG5pbD8gYXR0cmlidXRlKVxuICAgICAgKHN5bnRheC1lcnJvciBcIk1hbGZvcm1lZCBhZ2V0IGV4cHJlc3Npb24gZXhwZWN0ZWQgKGFnZXQgb2JqZWN0IG1lbWJlcilcIlxuICAgICAgICAgICAgICAgICAgICBmb3JtKVxuICAgICAgezpvcCA6bWVtYmVyLWV4cHJlc3Npb25cbiAgICAgICA6Y29tcHV0ZWQgKG5vdCBmaWVsZClcbiAgICAgICA6Zm9ybSBmb3JtXG4gICAgICAgOnRhcmdldCB0YXJnZXRcbiAgICAgICA7OyBJZiBmaWVsZCBpcyBhIHF1b3RlZCBzeW1ib2wgdGhlcmUncyBubyBuZWVkIHRvIHJlc29sdmVcbiAgICAgICA7OyBpdCBmb3IgaW5mb1xuICAgICAgIDpwcm9wZXJ0eSAoaWYgZmllbGRcbiAgICAgICAgICAgICAgICAgICAoY29uaiAoYW5hbHl6ZS1zcGVjaWFsIGFuYWx5emUtaWRlbnRpZmllciBlbnYgZmllbGQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgezpiaW5kaW5nIG5pbH0pXG4gICAgICAgICAgICAgICAgICAgKGFuYWx5emUgZW52IGF0dHJpYnV0ZSkpfSkpKVxuKGluc3RhbGwtc3BlY2lhbCEgOmFnZXQgYW5hbHl6ZS1hZ2V0KVxuXG4oZGVmbiBwYXJzZS1kZWZcbiAgKFtpZF0gezppZCBpZH0pXG4gIChbaWQgaW5pdF0gezppZCBpZCA6aW5pdCBpbml0fSlcbiAgKFtpZCBkb2MgaW5pdF0gezppZCBpZCA6ZG9jIGRvYyA6aW5pdCBpbml0fSkpXG5cbihkZWZuIGFuYWx5emUtZGVmXG4gIFtlbnYgZm9ybV1cbiAgKGxldCBbcGFyYW1zIChhcHBseSBwYXJzZS1kZWYgKHZlYyAocmVzdCBmb3JtKSkpXG4gICAgICAgIGlkICg6aWQgcGFyYW1zKVxuICAgICAgICBtZXRhZGF0YSAobWV0YSBpZClcblxuICAgICAgICBiaW5kaW5nIChhbmFseXplLXNwZWNpYWwgYW5hbHl6ZS1kZWNsYXJhdGlvbiBlbnYgaWQpXG5cbiAgICAgICAgaW5pdCAoYW5hbHl6ZSBlbnYgKDppbml0IHBhcmFtcykpXG5cbiAgICAgICAgZG9jIChvciAoOmRvYyBwYXJhbXMpXG4gICAgICAgICAgICAgICAgKDpkb2MgbWV0YWRhdGEpKV1cbiAgICB7Om9wIDpkZWZcbiAgICAgOmRvYyBkb2NcbiAgICAgOmlkIGJpbmRpbmdcbiAgICAgOmluaXQgaW5pdFxuICAgICA6ZXhwb3J0IChhbmQgKDp0b3AgZW52KVxuICAgICAgICAgICAgICAgICAgKG5vdCAoOnByaXZhdGUgbWV0YWRhdGEpKSlcbiAgICAgOmZvcm0gZm9ybX0pKVxuKGluc3RhbGwtc3BlY2lhbCEgOmRlZiBhbmFseXplLWRlZilcblxuKGRlZm4gYW5hbHl6ZS1kb1xuICBbZW52IGZvcm1dXG4gIChsZXQgW2V4cHJlc3Npb25zIChyZXN0IGZvcm0pXG4gICAgICAgIGJvZHkgKGFuYWx5emUtYmxvY2sgZW52IGV4cHJlc3Npb25zKV1cbiAgICAoY29uaiBib2R5IHs6b3AgOmRvXG4gICAgICAgICAgICAgICAgOmZvcm0gZm9ybX0pKSlcbihpbnN0YWxsLXNwZWNpYWwhIDpkbyBhbmFseXplLWRvKVxuXG4oZGVmbiBhbmFseXplLXN5bWJvbFxuICBcIlN5bWJvbCBhbmFseXplciBhbHNvIGRvZXMgc3ludGF4IGRlc3VnYXJpbmcgZm9yIHRoZSBzeW1ib2xzXG4gIGxpa2UgZm9vLmJhci5iYXogcHJvZHVjaW5nIChhZ2V0IGZvbyAnYmFyLmJheikgZm9ybS4gVGhpcyBlbmFibGVzXG4gIHJlbmFtaW5nIG9mIHNoYWRvd2VkIHN5bWJvbHMuXCJcbiAgW2VudiBmb3JtXVxuICAobGV0IFtmb3JtcyAoc3BsaXQgKG5hbWUgZm9ybSkgXFwuKVxuICAgICAgICBtZXRhZGF0YSAobWV0YSBmb3JtKVxuICAgICAgICBzdGFydCAoOnN0YXJ0IG1ldGFkYXRhKVxuICAgICAgICBlbmQgKDplbmQgbWV0YWRhdGEpXG4gICAgICAgIGV4cGFuc2lvbiAoaWYgKD4gKGNvdW50IGZvcm1zKSAxKVxuICAgICAgICAgICAgICAgICAgIChsaXN0ICdhZ2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHdpdGgtbWV0YSAoc3ltYm9sIChmaXJzdCBmb3JtcykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoY29uaiBtZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgezpzdGFydCBzdGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDplbmQgezpsaW5lICg6bGluZSBlbmQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOmNvbHVtbiAoKyAxICg6Y29sdW1uIHN0YXJ0KSAoY291bnQgKGZpcnN0IGZvcm1zKSkpfX0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgIChsaXN0ICdxdW90ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh3aXRoLW1ldGEgKHN5bWJvbCAoam9pbiBcXC4gKHJlc3QgZm9ybXMpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjb25qIG1ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7OmVuZCBlbmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6c3RhcnQgezpsaW5lICg6bGluZSBzdGFydClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpjb2x1bW4gKCsgMSAoOmNvbHVtbiBzdGFydCkgKGNvdW50IChmaXJzdCBmb3JtcykpKX19KSkpKSldXG4gICAgKGlmIGV4cGFuc2lvblxuICAgICAgKGFuYWx5emUgZW52ICh3aXRoLW1ldGEgZXhwYW5zaW9uIChtZXRhIGZvcm0pKSlcbiAgICAgIChhbmFseXplLXNwZWNpYWwgYW5hbHl6ZS1pZGVudGlmaWVyIGVudiBmb3JtKSkpKVxuXG4oZGVmbiBhbmFseXplLWlkZW50aWZpZXJcbiAgW2VudiBmb3JtXVxuICB7Om9wIDp2YXJcbiAgIDp0eXBlIDppZGVudGlmaWVyXG4gICA6Zm9ybSBmb3JtXG4gICA6c3RhcnQgKDpzdGFydCAobWV0YSBmb3JtKSlcbiAgIDplbmQgKDplbmQgKG1ldGEgZm9ybSkpXG4gICA6YmluZGluZyAocmVzb2x2ZS1iaW5kaW5nIGVudiBmb3JtKX0pXG5cbihkZWZuIHVucmVzb2x2ZWQtYmluZGluZ1xuICBbZW52IGZvcm1dXG4gIHs6b3AgOnVucmVzb2x2ZWQtYmluZGluZ1xuICAgOnR5cGUgOnVucmVzb2x2ZWQtYmluZGluZ1xuICAgOmlkZW50aWZpZXIgezp0eXBlIDppZGVudGlmaWVyXG4gICAgICAgICAgICAgICAgOmZvcm0gKHN5bWJvbCAobmFtZXNwYWNlIGZvcm0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobmFtZSBmb3JtKSl9XG4gICA6c3RhcnQgKDpzdGFydCAobWV0YSBmb3JtKSlcbiAgIDplbmQgKDplbmQgKG1ldGEgZm9ybSkpfSlcblxuKGRlZm4gcmVzb2x2ZS1iaW5kaW5nXG4gIFtlbnYgZm9ybV1cbiAgKG9yIChnZXQgKDpsb2NhbHMgZW52KSAobmFtZSBmb3JtKSlcbiAgICAgIChnZXQgKDplbmNsb3NlZCBlbnYpIChuYW1lIGZvcm0pKVxuICAgICAgKHVucmVzb2x2ZWQtYmluZGluZyBlbnYgZm9ybSkpKVxuXG4oZGVmbiBhbmFseXplLXNoYWRvd1xuICBbZW52IGlkXVxuICAobGV0IFtiaW5kaW5nIChyZXNvbHZlLWJpbmRpbmcgZW52IGlkKV1cbiAgICB7OmRlcHRoIChpbmMgKG9yICg6ZGVwdGggYmluZGluZykgMCkpXG4gICAgIDpzaGFkb3cgYmluZGluZ30pKVxuXG4oZGVmbiBhbmFseXplLWJpbmRpbmdcbiAgW2VudiBmb3JtXVxuICAobGV0IFtpZCAoZmlyc3QgZm9ybSlcbiAgICAgICAgYm9keSAoc2Vjb25kIGZvcm0pXVxuICAgIChjb25qIChhbmFseXplLXNoYWRvdyBlbnYgaWQpXG4gICAgICAgICAgezpvcCA6YmluZGluZ1xuICAgICAgICAgICA6dHlwZSA6YmluZGluZ1xuICAgICAgICAgICA6aWQgaWRcbiAgICAgICAgICAgOmluaXQgKGFuYWx5emUgZW52IGJvZHkpXG4gICAgICAgICAgIDpmb3JtIGZvcm19KSkpXG5cbihkZWZuIGFuYWx5emUtZGVjbGFyYXRpb25cbiAgW2VudiBmb3JtXVxuICAoYXNzZXJ0IChub3QgKG9yIChuYW1lc3BhY2UgZm9ybSlcbiAgICAgICAgICAgICAgICAgICAoPCAxIChjb3VudCAoc3BsaXQgXFwuIChzdHIgZm9ybSkpKSkpKSlcbiAgKGNvbmogKGFuYWx5emUtc2hhZG93IGVudiBmb3JtKVxuICAgICAgICB7Om9wIDp2YXJcbiAgICAgICAgIDp0eXBlIDppZGVudGlmaWVyXG4gICAgICAgICA6ZGVwdGggMFxuICAgICAgICAgOmlkIGZvcm1cbiAgICAgICAgIDpmb3JtIGZvcm19KSlcblxuKGRlZm4gYW5hbHl6ZS1wYXJhbVxuICBbZW52IGZvcm1dXG4gIChjb25qIChhbmFseXplLXNoYWRvdyBlbnYgZm9ybSlcbiAgICAgICAgezpvcCA6cGFyYW1cbiAgICAgICAgIDp0eXBlIDpwYXJhbWV0ZXJcbiAgICAgICAgIDppZCBmb3JtXG4gICAgICAgICA6Zm9ybSBmb3JtXG4gICAgICAgICA6c3RhcnQgKDpzdGFydCAobWV0YSBmb3JtKSlcbiAgICAgICAgIDplbmQgKDplbmQgKG1ldGEgZm9ybSkpfSkpXG5cbihkZWZuIHdpdGgtYmluZGluZ1xuICBcIlJldHVybnMgZW5oYW5jZWQgZW52aXJvbm1lbnQgd2l0aCBhZGRpdGlvbmFsIGJpbmRpbmcgYWRkZWRcbiAgdG8gdGhlIDpiaW5kaW5ncyBhbmQgOnNjb3BlXCJcbiAgW2VudiBmb3JtXVxuICAoY29uaiBlbnYgezpsb2NhbHMgKGFzc29jICg6bG9jYWxzIGVudikgKG5hbWUgKDppZCBmb3JtKSkgZm9ybSlcbiAgICAgICAgICAgICA6YmluZGluZ3MgKGNvbmogKDpiaW5kaW5ncyBlbnYpIGZvcm0pfSkpXG5cbihkZWZuIHdpdGgtcGFyYW1cbiAgW2VudiBmb3JtXVxuICAoY29uaiAod2l0aC1iaW5kaW5nIGVudiBmb3JtKVxuICAgICAgICB7OnBhcmFtcyAoY29uaiAoOnBhcmFtcyBlbnYpIGZvcm0pfSkpXG5cbihkZWZuIHN1Yi1lbnZcbiAgW2Vudl1cbiAgezplbmNsb3NlZCAoY29uaiB7fVxuICAgICAgICAgICAgICAgICAgICg6ZW5jbG9zZWQgZW52KVxuICAgICAgICAgICAgICAgICAgICg6bG9jYWxzIGVudikpXG4gICA6bG9jYWxzIHt9XG4gICA6YmluZGluZ3MgW11cbiAgIDpwYXJhbXMgKG9yICg6cGFyYW1zIGVudikgW10pfSlcblxuXG4oZGVmbiBhbmFseXplLWxldCpcbiAgXCJUYWtlcyBsZXQgZm9ybSBhbmQgZW5oYW5jZXMgaXQncyBtZXRhZGF0YSB2aWEgYW5hbHl6ZWRcbiAgaW5mb1wiXG4gIFtlbnYgZm9ybSBpcy1sb29wXVxuICAobGV0IFtleHByZXNzaW9ucyAocmVzdCBmb3JtKVxuICAgICAgICBiaW5kaW5ncyAoZmlyc3QgZXhwcmVzc2lvbnMpXG4gICAgICAgIGJvZHkgKHJlc3QgZXhwcmVzc2lvbnMpXG5cbiAgICAgICAgdmFsaWQtYmluZGluZ3M/IChhbmQgKHZlY3Rvcj8gYmluZGluZ3MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIChldmVuPyAoY291bnQgYmluZGluZ3MpKSlcblxuICAgICAgICBfIChhc3NlcnQgdmFsaWQtYmluZGluZ3M/XG4gICAgICAgICAgICAgICAgICBcImJpbmRpbmdzIG11c3QgYmUgdmVjdG9yIG9mIGV2ZW4gbnVtYmVyIG9mIGVsZW1lbnRzXCIpXG5cbiAgICAgICAgc2NvcGUgKHJlZHVjZSAjKHdpdGgtYmluZGluZyAlMSAoYW5hbHl6ZS1iaW5kaW5nICUxICUyKSlcbiAgICAgICAgICAgICAgICAgICAgICAoc3ViLWVudiBlbnYpXG4gICAgICAgICAgICAgICAgICAgICAgKHBhcnRpdGlvbiAyIGJpbmRpbmdzKSlcblxuICAgICAgICBiaW5kaW5ncyAoOmJpbmRpbmdzIHNjb3BlKVxuXG4gICAgICAgIGV4cHJlc3Npb25zIChhbmFseXplLWJsb2NrIChpZiBpcy1sb29wXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNvbmogc2NvcGUgezpwYXJhbXMgYmluZGluZ3N9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5KV1cblxuICAgIHs6b3AgOmxldFxuICAgICA6Zm9ybSBmb3JtXG4gICAgIDpzdGFydCAoOnN0YXJ0IChtZXRhIGZvcm0pKVxuICAgICA6ZW5kICg6ZW5kIChtZXRhIGZvcm0pKVxuICAgICA6YmluZGluZ3MgYmluZGluZ3NcbiAgICAgOnN0YXRlbWVudHMgKDpzdGF0ZW1lbnRzIGV4cHJlc3Npb25zKVxuICAgICA6cmVzdWx0ICg6cmVzdWx0IGV4cHJlc3Npb25zKX0pKVxuXG4oZGVmbiBhbmFseXplLWxldFxuICBbZW52IGZvcm1dXG4gIChhbmFseXplLWxldCogZW52IGZvcm0gZmFsc2UpKVxuKGluc3RhbGwtc3BlY2lhbCEgOmxldCBhbmFseXplLWxldClcblxuKGRlZm4gYW5hbHl6ZS1sb29wXG4gIFtlbnYgZm9ybV1cbiAgKGNvbmogKGFuYWx5emUtbGV0KiBlbnYgZm9ybSB0cnVlKSB7Om9wIDpsb29wfSkpXG4oaW5zdGFsbC1zcGVjaWFsISA6bG9vcCBhbmFseXplLWxvb3ApXG5cblxuKGRlZm4gYW5hbHl6ZS1yZWN1clxuICBbZW52IGZvcm1dXG4gIChsZXQgW3BhcmFtcyAoOnBhcmFtcyBlbnYpXG4gICAgICAgIGZvcm1zICh2ZWMgKG1hcCAjKGFuYWx5emUgZW52ICUpIChyZXN0IGZvcm0pKSldXG5cbiAgICAoaWYgKD0gKGNvdW50IHBhcmFtcylcbiAgICAgICAgICAgKGNvdW50IGZvcm1zKSlcbiAgICAgIHs6b3AgOnJlY3VyXG4gICAgICAgOmZvcm0gZm9ybVxuICAgICAgIDpwYXJhbXMgZm9ybXN9XG4gICAgICAoc3ludGF4LWVycm9yIFwiUmVjdXJzIHdpdGggd3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50c1wiXG4gICAgICAgICAgICAgICAgICAgIGZvcm0pKSkpXG4oaW5zdGFsbC1zcGVjaWFsISA6cmVjdXIgYW5hbHl6ZS1yZWN1cilcblxuKGRlZm4gYW5hbHl6ZS1xdW90ZWQtbGlzdFxuICBbZm9ybV1cbiAgezpvcCA6bGlzdFxuICAgOml0ZW1zIChtYXAgYW5hbHl6ZS1xdW90ZWQgKHZlYyBmb3JtKSlcbiAgIDpmb3JtIGZvcm1cbiAgIDpzdGFydCAoOnN0YXJ0IChtZXRhIGZvcm0pKVxuICAgOmVuZCAoOmVuZCAobWV0YSBmb3JtKSl9KVxuXG4oZGVmbiBhbmFseXplLXF1b3RlZC12ZWN0b3JcbiAgW2Zvcm1dXG4gIHs6b3AgOnZlY3RvclxuICAgOml0ZW1zIChtYXAgYW5hbHl6ZS1xdW90ZWQgZm9ybSlcbiAgIDpmb3JtIGZvcm1cbiAgIDpzdGFydCAoOnN0YXJ0IChtZXRhIGZvcm0pKVxuICAgOmVuZCAoOmVuZCAobWV0YSBmb3JtKSl9KVxuXG4oZGVmbiBhbmFseXplLXF1b3RlZC1kaWN0aW9uYXJ5XG4gIFtmb3JtXVxuICAobGV0IFtuYW1lcyAodmVjIChtYXAgYW5hbHl6ZS1xdW90ZWQgKGtleXMgZm9ybSkpKVxuICAgICAgICB2YWx1ZXMgKHZlYyAobWFwIGFuYWx5emUtcXVvdGVkICh2YWxzIGZvcm0pKSldXG4gICAgezpvcCA6ZGljdGlvbmFyeVxuICAgICA6Zm9ybSBmb3JtXG4gICAgIDprZXlzIG5hbWVzXG4gICAgIDp2YWx1ZXMgdmFsdWVzXG4gICAgIDpzdGFydCAoOnN0YXJ0IChtZXRhIGZvcm0pKVxuICAgICA6ZW5kICg6ZW5kIChtZXRhIGZvcm0pKX0pKVxuXG4oZGVmbiBhbmFseXplLXF1b3RlZC1zeW1ib2xcbiAgW2Zvcm1dXG4gIHs6b3AgOnN5bWJvbFxuICAgOm5hbWUgKG5hbWUgZm9ybSlcbiAgIDpuYW1lc3BhY2UgKG5hbWVzcGFjZSBmb3JtKVxuICAgOmZvcm0gZm9ybX0pXG5cbihkZWZuIGFuYWx5emUtcXVvdGVkLWtleXdvcmRcbiBbZm9ybV1cbiAgezpvcCA6a2V5d29yZFxuICAgOm5hbWUgKG5hbWUgZm9ybSlcbiAgIDpuYW1lc3BhY2UgKG5hbWVzcGFjZSBmb3JtKVxuICAgOmZvcm0gZm9ybX0pXG5cbihkZWZuIGFuYWx5emUtcXVvdGVkXG4gIFtmb3JtXVxuICAoY29uZCAoc3ltYm9sPyBmb3JtKSAoYW5hbHl6ZS1xdW90ZWQtc3ltYm9sIGZvcm0pXG4gICAgICAgIChrZXl3b3JkPyBmb3JtKSAoYW5hbHl6ZS1xdW90ZWQta2V5d29yZCBmb3JtKVxuICAgICAgICAobGlzdD8gZm9ybSkgKGFuYWx5emUtcXVvdGVkLWxpc3QgZm9ybSlcbiAgICAgICAgKHZlY3Rvcj8gZm9ybSkgKGFuYWx5emUtcXVvdGVkLXZlY3RvciBmb3JtKVxuICAgICAgICAoZGljdGlvbmFyeT8gZm9ybSkgKGFuYWx5emUtcXVvdGVkLWRpY3Rpb25hcnkgZm9ybSlcbiAgICAgICAgOmVsc2UgezpvcCA6Y29uc3RhbnRcbiAgICAgICAgICAgICAgIDpmb3JtIGZvcm19KSlcblxuKGRlZm4gYW5hbHl6ZS1xdW90ZVxuICBcIkV4YW1wbGVzOlxuICAgKGFuYWx5emUtcXVvdGUge30gJyhxdW90ZSBmb28pKSA9PiB7Om9wIDpjb25zdGFudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOmZvcm0gJ2Zvb1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOmVudiBlbnZ9XCJcbiAgW2VudiBmb3JtXVxuICAoYW5hbHl6ZS1xdW90ZWQgKHNlY29uZCBmb3JtKSkpXG4oaW5zdGFsbC1zcGVjaWFsISA6cXVvdGUgYW5hbHl6ZS1xdW90ZSlcblxuKGRlZm4gYW5hbHl6ZS1zdGF0ZW1lbnRcbiAgW2VudiBmb3JtXVxuICAobGV0IFtzdGF0ZW1lbnRzIChvciAoOnN0YXRlbWVudHMgZW52KSBbXSlcbiAgICAgICAgYmluZGluZ3MgKG9yICg6YmluZGluZ3MgZW52KSBbXSlcbiAgICAgICAgc3RhdGVtZW50IChhbmFseXplIChjb25qIGVudiB7OnN0YXRlbWVudHMgbmlsfSkgZm9ybSlcbiAgICAgICAgb3AgKDpvcCBzdGF0ZW1lbnQpXG5cbiAgICAgICAgZGVmcyAoY29uZCAoPSBvcCA6ZGVmKSBbKDp2YXIgc3RhdGVtZW50KV1cbiAgICAgICAgICAgICAgICAgICA7OyAoPSBvcCA6bnMpICg6cmVxdWlyZW1lbnQgbm9kZSlcbiAgICAgICAgICAgICAgICAgICA6ZWxzZSBuaWwpXVxuXG4gICAgKGNvbmogZW52IHs6c3RhdGVtZW50cyAoY29uaiBzdGF0ZW1lbnRzIHN0YXRlbWVudClcbiAgICAgICAgICAgICAgIDpiaW5kaW5ncyAoY29uY2F0IGJpbmRpbmdzIGRlZnMpfSkpKVxuXG4oZGVmbiBhbmFseXplLWJsb2NrXG4gIFwiRXhhbXBsZXM6XG4gIChhbmFseXplLWJsb2NrIHt9ICcoKGZvbyBiYXIpKSkgPT4gezpzdGF0ZW1lbnRzIG5pbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6cmVzdWx0IHs6b3AgOmludm9rZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Zm9ybSAnKGZvbyBiYXIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDplbnYge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOmNhbGxlZSB7Om9wIDp2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOmZvcm0gJ2Zvb1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6aW5mbyBuaWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOmVudiB7fX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOnBhcmFtcyBbezpvcCA6dmFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Zm9ybSAnYmFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6aW5mbyBuaWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDplbnYge319XX1cbiAgKGFuYWx5emUtYmxvY2sge30gJygoYmVlcCBieilcbiAgICAgICAgICAgICAgICAgICAgICAoZm9vIGJhcikpKSA9PiB7OnN0YXRlbWVudHMgW3s6b3AgOmludm9rZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpmb3JtICcoYmVlcCBieilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ZW52IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOmNhbGxlZSB7Om9wIDp2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Zm9ybSAnYmVlcFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDppbmZvIG5pbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDplbnYge319XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOnBhcmFtcyBbezpvcCA6dmFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpmb3JtICdielxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6aW5mbyBuaWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOmVudiB7fX1dfV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOnJlc3VsdCB7Om9wIDppbnZva2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOmZvcm0gJyhmb28gYmFyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ZW52IHt9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpjYWxsZWUgezpvcCA6dmFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpmb3JtICdmb29cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOmluZm8gbmlsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDplbnYge319XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpwYXJhbXMgW3s6b3AgOnZhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOmZvcm0gJ2JhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOmluZm8gbmlsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ZW52IHt9fV19XCJcbiAgW2VudiBmb3JtXVxuICAobGV0IFtib2R5IChpZiAoPiAoY291bnQgZm9ybSkgMSlcbiAgICAgICAgICAgICAgIChyZWR1Y2UgYW5hbHl6ZS1zdGF0ZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgZW52XG4gICAgICAgICAgICAgICAgICAgICAgIChidXRsYXN0IGZvcm0pKSlcbiAgICAgICAgcmVzdWx0IChhbmFseXplIChvciBib2R5IGVudikgKGxhc3QgZm9ybSkpXVxuICAgIHs6c3RhdGVtZW50cyAoOnN0YXRlbWVudHMgYm9keSlcbiAgICAgOnJlc3VsdCByZXN1bHR9KSlcblxuKGRlZm4gYW5hbHl6ZS1mbi1tZXRob2RcbiAgXCJcbiAge30gLT4gJyhbeCB5XSAoKyB4IHkpKSAtPiB7OmVudiB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Zm9ybSAnKFt4IHldICgrIHggeSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDp2YXJpYWRpYyBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6YXJpdHkgMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6cGFyYW1zIFt7Om9wIDp2YXIgOmZvcm0gJ3h9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHs6b3AgOnZhciA6Zm9ybSAneX1dXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpzdGF0ZW1lbnRzIFtdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpyZXR1cm4gezpvcCA6aW52b2tlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpjYWxsZWUgezpvcCA6dmFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpmb3JtICcrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDplbnYgezpwYXJlbnQge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOmxvY2FscyB7eCB7Om5hbWUgJ3hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOnNoYWRvdyBuaWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOmxvY2FsIHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOnRhZyBuaWx9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgezpuYW1lICd5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpzaGFkb3cgbmlsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpsb2NhbCB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDp0YWcgbmlsfX19fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6cGFyYW1zIFt7Om9wIDp2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpmb3JtICd4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6aW5mbyBuaWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDp0YWcgbmlsfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Om9wIDp2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpmb3JtICd5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6aW5mbyBuaWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDp0YWcgbmlsfV19fVwiXG4gIFtlbnYgZm9ybV1cbiAgKGxldCBbc2lnbmF0dXJlIChpZiAoYW5kIChsaXN0PyBmb3JtKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKHZlY3Rvcj8gKGZpcnN0IGZvcm0pKSlcbiAgICAgICAgICAgICAgICAgICAgKGZpcnN0IGZvcm0pXG4gICAgICAgICAgICAgICAgICAgIChzeW50YXgtZXJyb3IgXCJNYWxmb3JtZWQgZm4gb3ZlcmxvYWQgZm9ybVwiIGZvcm0pKVxuICAgICAgICBib2R5IChyZXN0IGZvcm0pXG4gICAgICAgIDs7IElmIHBhcmFtIHNpZ25hdHVyZSBjb250YWlucyAmIGZuIGlzIHZhcmlhZGljLlxuICAgICAgICB2YXJpYWRpYyAoc29tZSAjKD0gJyYgJSkgc2lnbmF0dXJlKVxuXG4gICAgICAgIDs7IEFsbCBuYW1lZCBwYXJhbXMgb2YgdGhlIGZuLlxuICAgICAgICBwYXJhbXMgKGlmIHZhcmlhZGljXG4gICAgICAgICAgICAgICAgIChmaWx0ZXIgIyhub3QgKD0gJyYgJSkpIHNpZ25hdHVyZSlcbiAgICAgICAgICAgICAgICAgc2lnbmF0dXJlKVxuXG4gICAgICAgIDs7IE51bWJlciBvZiBwYXJhbWV0ZXJzIGZpeGVkIHBhcmFtZXRlcnMgZm4gdGFrZXMuXG4gICAgICAgIGFyaXR5IChpZiB2YXJpYWRpY1xuICAgICAgICAgICAgICAgIChkZWMgKGNvdW50IHBhcmFtcykpXG4gICAgICAgICAgICAgICAgKGNvdW50IHBhcmFtcykpXG5cbiAgICAgICAgOzsgQW5hbHl6ZSBwYXJhbWV0ZXJzIGluIGNvcnJlc3BvbmRlbmNlIHRvIGVudmlyb25tZW50XG4gICAgICAgIDs7IGxvY2FscyB0byBpZGVudGlmeSBiaW5kaW5nIHNoYWRvd2luZy5cbiAgICAgICAgc2NvcGUgKHJlZHVjZSAjKHdpdGgtcGFyYW0gJTEgKGFuYWx5emUtcGFyYW0gJTEgJTIpKVxuICAgICAgICAgICAgICAgICAgICAgIChjb25qIGVudiB7OnBhcmFtcyBbXX0pXG4gICAgICAgICAgICAgICAgICAgICAgcGFyYW1zKV1cbiAgICAoY29uaiAoYW5hbHl6ZS1ibG9jayBzY29wZSBib2R5KVxuICAgICAgICAgIHs6b3AgOm92ZXJsb2FkXG4gICAgICAgICAgIDp2YXJpYWRpYyB2YXJpYWRpY1xuICAgICAgICAgICA6YXJpdHkgYXJpdHlcbiAgICAgICAgICAgOnBhcmFtcyAoOnBhcmFtcyBzY29wZSlcbiAgICAgICAgICAgOmZvcm0gZm9ybX0pKSlcblxuXG4oZGVmbiBhbmFseXplLWZuXG4gIFtlbnYgZm9ybV1cbiAgKGxldCBbZm9ybXMgKHJlc3QgZm9ybSlcbiAgICAgICAgOzsgTm9ybWFsaXplIGZuIGZvcm0gc28gdGhhdCBpdCBjb250YWlucyBuYW1lXG4gICAgICAgIDs7ICcoZm4gW3hdIHgpIC0+ICcoZm4gbmlsIFt4XSB4KVxuICAgICAgICBmb3JtcyAoaWYgKHN5bWJvbD8gKGZpcnN0IGZvcm1zKSlcbiAgICAgICAgICAgICAgICBmb3Jtc1xuICAgICAgICAgICAgICAgIChjb25zIG5pbCBmb3JtcykpXG5cbiAgICAgICAgaWQgKGZpcnN0IGZvcm1zKVxuICAgICAgICBiaW5kaW5nIChpZiBpZCAoYW5hbHl6ZS1zcGVjaWFsIGFuYWx5emUtZGVjbGFyYXRpb24gZW52IGlkKSlcblxuICAgICAgICBib2R5IChyZXN0IGZvcm1zKVxuXG4gICAgICAgIDs7IE1ha2Ugc3VyZSB0aGF0IGZuIGRlZmluaXRpb24gaXMgc3RydWN1dGVyZWRcbiAgICAgICAgOzsgaW4gbWV0aG9kIG92ZXJsb2FkIHN0eWxlOlxuICAgICAgICA7OyAoZm4gYSBbeF0geSkgLT4gKChbeF0geSkpXG4gICAgICAgIDs7IChmbiBhIChbeF0geSkpIC0+ICgoW3hdIHkpKVxuICAgICAgICBvdmVybG9hZHMgKGNvbmQgKHZlY3Rvcj8gKGZpcnN0IGJvZHkpKSAobGlzdCBib2R5KVxuICAgICAgICAgICAgICAgICAgICAgICAgKGFuZCAobGlzdD8gKGZpcnN0IGJvZHkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodmVjdG9yPyAoZmlyc3QgKGZpcnN0IGJvZHkpKSkpIGJvZHlcbiAgICAgICAgICAgICAgICAgICAgICAgIDplbHNlIChzeW50YXgtZXJyb3IgKHN0ciBcIk1hbGZvcm1lZCBmbiBleHByZXNzaW9uLCBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicGFyYW1ldGVyIGRlY2xhcmF0aW9uIChcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwci1zdHIgKGZpcnN0IGJvZHkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiKSBtdXN0IGJlIGEgdmVjdG9yXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm0pKVxuXG4gICAgICAgIHNjb3BlIChpZiBiaW5kaW5nXG4gICAgICAgICAgICAgICAgKHdpdGgtYmluZGluZyAoc3ViLWVudiBlbnYpIGJpbmRpbmcpXG4gICAgICAgICAgICAgICAgKHN1Yi1lbnYgZW52KSlcblxuICAgICAgICBtZXRob2RzIChtYXAgIyhhbmFseXplLWZuLW1ldGhvZCBzY29wZSAlKVxuICAgICAgICAgICAgICAgICAgICAgKHZlYyBvdmVybG9hZHMpKVxuXG4gICAgICAgIGFyaXR5IChhcHBseSBtYXggKG1hcCAjKDphcml0eSAlKSBtZXRob2RzKSlcbiAgICAgICAgdmFyaWFkaWMgKHNvbWUgIyg6dmFyaWFkaWMgJSkgbWV0aG9kcyldXG4gICAgezpvcCA6Zm5cbiAgICAgOnR5cGUgOmZ1bmN0aW9uXG4gICAgIDppZCBiaW5kaW5nXG4gICAgIDp2YXJpYWRpYyB2YXJpYWRpY1xuICAgICA6bWV0aG9kcyBtZXRob2RzXG4gICAgIDpmb3JtIGZvcm19KSlcbihpbnN0YWxsLXNwZWNpYWwhIDpmbiBhbmFseXplLWZuKVxuXG4oZGVmbiBwYXJzZS1yZWZlcmVuY2VzXG4gIFwiVGFrZXMgcGFydCBvZiBuYW1lc3BhY2UgZGVmaW5pdGlvbiBhbmQgY3JlYXRlcyBoYXNoXG4gIG9mIHJlZmVyZW5jZSBmb3Jtc1wiXG4gIFtmb3Jtc11cbiAgKHJlZHVjZSAoZm4gW3JlZmVyZW5jZXMgZm9ybV1cbiAgICAgICAgICAgIDs7IElmIG5vdCBhIHZlY3RvciB0aGFuIGl0J3Mgbm90IGEgcmVmZXJlbmNlXG4gICAgICAgICAgICA7OyBmb3JtIHRoYXQgd2lzcCB1bmRlcnN0YW5kcyBzbyBqdXN0IHNraXAgaXQuXG4gICAgICAgICAgICAoaWYgKHNlcT8gZm9ybSlcbiAgICAgICAgICAgICAgKGFzc29jIHJlZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAobmFtZSAoZmlyc3QgZm9ybSkpXG4gICAgICAgICAgICAgICAgKHZlYyAocmVzdCBmb3JtKSkpXG4gICAgICAgICAgICAgIHJlZmVyZW5jZXMpKVxuICAgICAgICAgIHt9XG4gICAgICAgICAgZm9ybXMpKVxuXG4oZGVmbiBwYXJzZS1yZXF1aXJlXG4gIFtmb3JtXVxuICAobGV0IFs7OyByZXF1aXJlIGZvcm0gbWF5IGJlIGVpdGhlciB2ZWN0b3Igd2l0aCBpZCBpbiB0aGVcbiAgICAgICAgOzsgaGVhZCBvciBqdXN0IGFuIGlkIHN5bWJvbC4gbm9ybWFsaXppbmcgdG8gYSB2ZWN0b3JcbiAgICAgICAgcmVxdWlyZW1lbnQgKGlmIChzeW1ib2w/IGZvcm0pIFtmb3JtXSAodmVjIGZvcm0pKVxuICAgICAgICBpZCAoZmlyc3QgcmVxdWlyZW1lbnQpXG4gICAgICAgIDs7IGJ1bmNoIG9mIGRpcmVjdGl2ZXMgbWF5IGZvbGxvdyByZXF1aXJlIGZvcm0gYnV0IHRoZXlcbiAgICAgICAgOzsgYWxsIGNvbWUgaW4gcGFpcnMuIHdpc3Agc3VwcG9ydHMgZm9sbG93aW5nIHBhaXJzOlxuICAgICAgICA7OyA6YXMgZm9vXG4gICAgICAgIDs7IDpyZWZlciBbZm9vIGJhcl1cbiAgICAgICAgOzsgOnJlbmFtZSB7Zm9vIGJhcn1cbiAgICAgICAgOzsgam9pbiB0aGVzZSBwYWlycyBpbiBhIGhhc2ggZm9yIGtleSBiYXNlZCBhY2Nlc3MuXG4gICAgICAgIHBhcmFtcyAoYXBwbHkgZGljdGlvbmFyeSAocmVzdCByZXF1aXJlbWVudCkpXG4gICAgICAgIHJlbmFtZXMgKGdldCBwYXJhbXMgJzpyZW5hbWUpXG4gICAgICAgIG5hbWVzIChnZXQgcGFyYW1zICc6cmVmZXIpXG4gICAgICAgIGFsaWFzIChnZXQgcGFyYW1zICc6YXMpXG4gICAgICAgIHJlZmVyZW5jZXMgKGlmIChub3QgKGVtcHR5PyBuYW1lcykpXG4gICAgICAgICAgICAgICAgICAgICAocmVkdWNlIChmbiBbcmVmZXJzIHJlZmVyZW5jZV1cbiAgICAgICAgICAgICAgICAgICAgICAoY29uaiByZWZlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Om9wIDpyZWZlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Zm9ybSByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOm5hbWUgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDs7IExvb2sgdXAgYnkgcmVmZXJlbmNlIHN5bWJvbCBhbmQgYnkgc3ltYm9sXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOzsgYml0IGluIGEgZnV6eiByaWdodCBub3cuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpyZW5hbWUgKG9yIChnZXQgcmVuYW1lcyByZWZlcmVuY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChnZXQgcmVuYW1lcyAobmFtZSByZWZlcmVuY2UpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOm5zIGlkfSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzKSldXG4gICAgezpvcCA6cmVxdWlyZVxuICAgICA6YWxpYXMgYWxpYXNcbiAgICAgOm5zIGlkXG4gICAgIDpyZWZlciByZWZlcmVuY2VzXG4gICAgIDpmb3JtIGZvcm19KSlcblxuKGRlZm4gYW5hbHl6ZS1uc1xuICBbZW52IGZvcm1dXG4gIChsZXQgW2Zvcm1zIChyZXN0IGZvcm0pXG4gICAgICAgIG5hbWUgKGZpcnN0IGZvcm1zKVxuICAgICAgICBib2R5IChyZXN0IGZvcm1zKVxuICAgICAgICA7OyBPcHRpb25hbCBkb2NzdHJpbmcgdGhhdCBmb2xsb3dzIG5hbWUgc3ltYm9sXG4gICAgICAgIGRvYyAoaWYgKHN0cmluZz8gKGZpcnN0IGJvZHkpKSAoZmlyc3QgYm9keSkpXG4gICAgICAgIDs7IElmIHNlY29uZCBmb3JtIGlzIG5vdCBhIHN0cmluZyB0aGFuIHRyZWF0IGl0XG4gICAgICAgIDs7IGFzIHJlZ3VsYXIgcmVmZXJlbmNlIGZvcm1cbiAgICAgICAgcmVmZXJlbmNlcyAocGFyc2UtcmVmZXJlbmNlcyAoaWYgZG9jXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocmVzdCBib2R5KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keSkpXG4gICAgICAgIHJlcXVpcmVtZW50cyAoaWYgKDpyZXF1aXJlIHJlZmVyZW5jZXMpXG4gICAgICAgICAgICAgICAgICAgICAgIChtYXAgcGFyc2UtcmVxdWlyZSAoOnJlcXVpcmUgcmVmZXJlbmNlcykpKV1cbiAgICB7Om9wIDpuc1xuICAgICA6bmFtZSBuYW1lXG4gICAgIDpkb2MgZG9jXG4gICAgIDpyZXF1aXJlIChpZiByZXF1aXJlbWVudHNcbiAgICAgICAgICAgICAgICAodmVjIHJlcXVpcmVtZW50cykpXG4gICAgIDpmb3JtIGZvcm19KSlcbihpbnN0YWxsLXNwZWNpYWwhIDpucyBhbmFseXplLW5zKVxuXG5cbihkZWZuIGFuYWx5emUtbGlzdFxuICBcIlRha2VzIGZvcm0gb2YgbGlzdCB0eXBlIGFuZCBwZXJmb3JtcyBhIG1hY3JvZXhwYW5zaW9ucyB1bnRpbFxuICBmdWxseSBleHBhbmRlZC4gSWYgZXhwYW5zaW9uIGlzIGRpZmZlcmVudCBmcm9tIGEgZ2l2ZW4gZm9ybSB0aGVuXG4gIGV4cGFuZGVkIGZvcm0gaXMgaGFuZGVkIGJhY2sgdG8gYW5hbHl6ZXIuIElmIGZvcm0gaXMgc3BlY2lhbCBsaWtlXG4gIGRlZiwgZm4sIGxldC4uLiB0aGFuIGFzc29jaWF0ZWQgaXMgZGlzcGF0Y2hlZCwgb3RoZXJ3aXNlIGZvcm0gaXNcbiAgYW5hbHl6ZWQgYXMgaW52b2tlIGV4cHJlc3Npb24uXCJcbiAgW2VudiBmb3JtXVxuICAobGV0IFtleHBhbnNpb24gKG1hY3JvZXhwYW5kIGZvcm0gZW52KVxuICAgICAgICA7OyBTcGVjaWFsIG9wZXJhdG9ycyBtdXN0IGJlIHN5bWJvbHMgYW5kIHN0b3JlZCBpbiB0aGVcbiAgICAgICAgOzsgKipzcGVjaWFscyoqIGhhc2ggYnkgb3BlcmF0b3IgbmFtZS5cbiAgICAgICAgb3BlcmF0b3IgKGZpcnN0IGZvcm0pXG4gICAgICAgIGFuYWx5emVyIChhbmQgKHN5bWJvbD8gb3BlcmF0b3IpXG4gICAgICAgICAgICAgICAgICAgICAgKGdldCAqKnNwZWNpYWxzKiogKG5hbWUgb3BlcmF0b3IpKSldXG4gICAgOzsgSWYgZm9ybSBpcyBleHBhbmRlZCBwYXNzIGl0IGJhY2sgdG8gYW5hbHl6ZSBzaW5jZSBpdCBtYXkgbm9cbiAgICA7OyBsb25nZXIgYmUgYSBsaXN0LiBPdGhlcndpc2UgZWl0aGVyIGFuYWx5emUgYXMgYSBzcGVjaWFsIGZvcm1cbiAgICA7OyAoaWYgaXQncyBzdWNoKSBvciBhcyBmdW5jdGlvbiBpbnZva2F0aW9uIGZvcm0uXG4gICAgKGNvbmQgKG5vdCAoaWRlbnRpY2FsPyBleHBhbnNpb24gZm9ybSkpIChhbmFseXplIGVudiBleHBhbnNpb24pXG4gICAgICAgICAgYW5hbHl6ZXIgKGFuYWx5emUtc3BlY2lhbCBhbmFseXplciBlbnYgZXhwYW5zaW9uKVxuICAgICAgICAgIDplbHNlIChhbmFseXplLWludm9rZSBlbnYgZXhwYW5zaW9uKSkpKVxuXG4oZGVmbiBhbmFseXplLXZlY3RvclxuICBbZW52IGZvcm1dXG4gIChsZXQgW2l0ZW1zICh2ZWMgKG1hcCAjKGFuYWx5emUgZW52ICUpIGZvcm0pKV1cbiAgICB7Om9wIDp2ZWN0b3JcbiAgICAgOmZvcm0gZm9ybVxuICAgICA6aXRlbXMgaXRlbXN9KSlcblxuKGRlZm4gYW5hbHl6ZS1kaWN0aW9uYXJ5XG4gIFtlbnYgZm9ybV1cbiAgKGxldCBbbmFtZXMgKHZlYyAobWFwICMoYW5hbHl6ZSBlbnYgJSkgKGtleXMgZm9ybSkpKVxuICAgICAgICB2YWx1ZXMgKHZlYyAobWFwICMoYW5hbHl6ZSBlbnYgJSkgKHZhbHMgZm9ybSkpKV1cbiAgICB7Om9wIDpkaWN0aW9uYXJ5XG4gICAgIDprZXlzIG5hbWVzXG4gICAgIDp2YWx1ZXMgdmFsdWVzXG4gICAgIDpmb3JtIGZvcm19KSlcblxuKGRlZm4gYW5hbHl6ZS1pbnZva2VcbiAgXCJSZXR1cm5zIG5vZGUgb2YgOmludm9rZSB0eXBlLCByZXByZXNlbnRpbmcgYSBmdW5jdGlvbiBjYWxsLiBJblxuICBhZGRpdGlvbiB0byByZWd1bGFyIHByb3BlcnRpZXMgdGhpcyBub2RlIGNvbnRhaW5zIDpjYWxsZWUgbWFwcGVkXG4gIHRvIGEgbm9kZSB0aGF0IGlzIGJlaW5nIGludm9rZWQgYW5kIDpwYXJhbXMgdGhhdCBpcyBhbiB2ZWN0b3Igb2ZcbiAgcGFyYW10ZXIgZXhwcmVzc2lvbnMgdGhhdCA6Y2FsbGVlIGlzIGludm9rZWQgd2l0aC5cIlxuICBbZW52IGZvcm1dXG4gIChsZXQgW2NhbGxlZSAoYW5hbHl6ZSBlbnYgKGZpcnN0IGZvcm0pKVxuICAgICAgICBwYXJhbXMgKHZlYyAobWFwICMoYW5hbHl6ZSBlbnYgJSkgKHJlc3QgZm9ybSkpKV1cbiAgICB7Om9wIDppbnZva2VcbiAgICAgOmNhbGxlZSBjYWxsZWVcbiAgICAgOnBhcmFtcyBwYXJhbXNcbiAgICAgOmZvcm0gZm9ybX0pKVxuXG4oZGVmbiBhbmFseXplLWNvbnN0YW50XG4gIFwiUmV0dXJucyBhIG5vZGUgcmVwcmVzZW50aW5nIGEgY29udHN0YW50IHZhbHVlIHdoaWNoIGlzXG4gIG1vc3QgY2VydGFpbmx5IGEgcHJpbWl0aXZlIHZhbHVlIGxpdGVyYWwgdGhpcyBmb3JtIGNhbnRhaW5zXG4gIG5vIGV4dHJhIGluZm9ybWF0aW9uLlwiXG4gIFtlbnYgZm9ybV1cbiAgezpvcCA6Y29uc3RhbnRcbiAgIDpmb3JtIGZvcm19KVxuXG4oZGVmbiBhbmFseXplXG4gIFwiVGFrZXMgYSBoYXNoIHJlcHJlc2VudGluZyBhIGdpdmVuIGVudmlyb25tZW50IGFuZCBgZm9ybWAgdG8gYmVcbiAgYW5hbHl6ZWQuIEVudmlyb25tZW50IG1heSBjb250YWluIGZvbGxvd2luZyBlbnRyaWVzOlxuXG4gIDpsb2NhbHMgIC0gSGFzaCBvZiB0aGUgZ2l2ZW4gZW52aXJvbm1lbnRzIGJpbmRpbmdzIG1hcHBlZHkgYnkgYmluZGluZyBuYW1lLlxuICA6Y29udGV4dCAtIE9uZSBvZiB0aGUgZm9sbG93aW5nIDpzdGF0ZW1lbnQsIDpleHByZXNzaW9uLCA6cmV0dXJuLiBUaGF0XG4gICAgICAgICAgICAgaW5mb3JtYXRpb24gaXMgaW5jbHVkZWQgaW4gcmVzdWx0aW5nIG5vZGVzIGFuZCBpcyBtZWFudCBmb3JcbiAgICAgICAgICAgICB3cml0ZXIgdGhhdCBtYXkgb3V0cHV0IGRpZmZlcmVudCBmb3JtcyBiYXNlZCBvbiBjb250ZXh0LlxuICA6bnMgICAgICAtIE5hbWVzcGFjZSBvZiB0aGUgZm9ybXMgYmVpbmcgYW5hbHl6ZWQuXG5cbiAgQW5hbHl6ZXIgcGVyZm9ybXMgYWxsIHRoZSBtYWNybyAmIHN5bnRheCBleHBhbnNpb25zIGFuZCB0cmFuc2Zvcm1zIGZvcm1cbiAgaW50byBBU1Qgbm9kZSBvZiBhbiBleHByZXNzaW9uLiBFYWNoIHN1Y2ggbm9kZSBjb250YWlucyBhdCBsZWFzdCBmb2xsb3dpbmdcbiAgcHJvcGVydGllczpcblxuICA6b3AgICAtIE9wZXJhdGlvbiB0eXBlIG9mIHRoZSBleHByZXNzaW9uLlxuICA6Zm9ybSAtIEdpdmVuIGZvcm0uXG5cbiAgQmFzZWQgb24gOm9wIG5vZGUgbWF5IGNvbnRhaW4gZGlmZmVyZW50IHNldCBvZiBwcm9wZXJ0aWVzLlwiXG4gIChbZm9ybV0gKGFuYWx5emUgezpsb2NhbHMge31cbiAgICAgICAgICAgICAgICAgICAgOmJpbmRpbmdzIFtdXG4gICAgICAgICAgICAgICAgICAgIDp0b3AgdHJ1ZX0gZm9ybSkpXG4gIChbZW52IGZvcm1dXG4gICAoY29uZCAobmlsPyBmb3JtKSAoYW5hbHl6ZS1jb25zdGFudCBlbnYgZm9ybSlcbiAgICAgICAgIChzeW1ib2w/IGZvcm0pIChhbmFseXplLXN5bWJvbCBlbnYgZm9ybSlcbiAgICAgICAgIChsaXN0PyBmb3JtKSAoaWYgKGVtcHR5PyBmb3JtKVxuICAgICAgICAgICAgICAgICAgICAgICAgKGFuYWx5emUtcXVvdGVkIGZvcm0pXG4gICAgICAgICAgICAgICAgICAgICAgICAoYW5hbHl6ZS1saXN0IGVudiBmb3JtKSlcbiAgICAgICAgIChkaWN0aW9uYXJ5PyBmb3JtKSAoYW5hbHl6ZS1kaWN0aW9uYXJ5IGVudiBmb3JtKVxuICAgICAgICAgKHZlY3Rvcj8gZm9ybSkgKGFuYWx5emUtdmVjdG9yIGVudiBmb3JtKVxuICAgICAgICAgOyhzZXQ/IGZvcm0pIChhbmFseXplLXNldCBlbnYgZm9ybSBuYW1lKVxuICAgICAgICAgKGtleXdvcmQ/IGZvcm0pIChhbmFseXplLWtleXdvcmQgZW52IGZvcm0pXG4gICAgICAgICA6ZWxzZSAoYW5hbHl6ZS1jb25zdGFudCBlbnYgZm9ybSkpKSlcbiJdfQ==

},{"./ast":"ReP8Ll","./expander":"RaoPh2","./runtime":"wcC2X1","./sequence":"Mdzbzt","./string":"31fh9Q"}],"wisp/analyzer":[function(require,module,exports){
module.exports=require('6TzXFU');
},{}],"wisp/ast":[function(require,module,exports){
module.exports=require('ReP8Ll');
},{}],"ReP8Ll":[function(require,module,exports){
{
    var _ns_ = {
            id: 'wisp.ast',
            doc: void 0
        };
    var wisp_sequence = require('./sequence');
    var isList = wisp_sequence.isList;
    var isSequential = wisp_sequence.isSequential;
    var first = wisp_sequence.first;
    var second = wisp_sequence.second;
    var count = wisp_sequence.count;
    var last = wisp_sequence.last;
    var map = wisp_sequence.map;
    var vec = wisp_sequence.vec;
    var repeat = wisp_sequence.repeat;
    var wisp_string = require('./string');
    var split = wisp_string.split;
    var join = wisp_string.join;
    var wisp_runtime = require('./runtime');
    var isNil = wisp_runtime.isNil;
    var isVector = wisp_runtime.isVector;
    var isNumber = wisp_runtime.isNumber;
    var isString = wisp_runtime.isString;
    var isBoolean = wisp_runtime.isBoolean;
    var isObject = wisp_runtime.isObject;
    var isDate = wisp_runtime.isDate;
    var isRePattern = wisp_runtime.isRePattern;
    var isDictionary = wisp_runtime.isDictionary;
    var str = wisp_runtime.str;
    var inc = wisp_runtime.inc;
    var subs = wisp_runtime.subs;
    var isEqual = wisp_runtime.isEqual;
}
var withMeta = exports.withMeta = function withMeta(value, metadata) {
        Object.defineProperty(value, 'metadata', {
            'value': metadata,
            'configurable': true
        });
        return value;
    };
var meta = exports.meta = function meta(value) {
        return isNil(value) ? void 0 : value.metadata;
    };
var __nsSeparator__ = exports.__nsSeparator__ = '\u2044';
var Symbol = function Symbol(namespace, name) {
    this.namespace = namespace;
    this.name = name;
    return this;
};
Symbol.type = 'wisp.symbol';
Symbol.prototype.type = Symbol.type;
Symbol.prototype.toString = function () {
    return function () {
        var prefixø1 = '' + '\uFEFF' + '\'';
        var nsø1 = namespace(this);
        return nsø1 ? '' + prefixø1 + nsø1 + '/' + name(this) : '' + prefixø1 + name(this);
    }.call(this);
};
var symbol = exports.symbol = function symbol(ns, id) {
        return isSymbol(ns) ? ns : isKeyword(ns) ? new Symbol(namespace(ns), name(ns)) : isNil(id) ? new Symbol(void 0, ns) : 'else' ? new Symbol(ns, id) : void 0;
    };
var isSymbol = exports.isSymbol = function isSymbol(x) {
        return isString(x) && '\uFEFF' === x[0] && '\'' === x[1] || x && Symbol.type === x.type;
    };
var isKeyword = exports.isKeyword = function isKeyword(x) {
        return isString(x) && count(x) > 1 && first(x) === '\uA789';
    };
var keyword = exports.keyword = function keyword(ns, id) {
        return isKeyword(ns) ? ns : isSymbol(ns) ? '' + '\uA789' + name(ns) : isNil(id) ? '' + '\uA789' + ns : isNil(ns) ? '' + '\uA789' + id : 'else' ? '' + '\uA789' + ns + __nsSeparator__ + id : void 0;
    };
var keywordName = function keywordName(value) {
    return last(split(subs(value, 1), __nsSeparator__));
};
var symbolName = function symbolName(value) {
    return value.name || last(split(subs(value, 2), __nsSeparator__));
};
var name = exports.name = function name(value) {
        return isSymbol(value) ? symbolName(value) : isKeyword(value) ? keywordName(value) : isString(value) ? value : 'else' ? (function () {
            throw new TypeError('' + 'Doesn\'t support name: ' + value);
        })() : void 0;
    };
var keywordNamespace = function keywordNamespace(x) {
    return function () {
        var partsø1 = split(subs(x, 1), __nsSeparator__);
        return count(partsø1) > 1 ? partsø1[0] : void 0;
    }.call(this);
};
var symbolNamespace = function symbolNamespace(x) {
    return function () {
        var partsø1 = isString(x) ? split(subs(x, 1), __nsSeparator__) : [
                x.namespace,
                x.name
            ];
        return count(partsø1) > 1 ? partsø1[0] : void 0;
    }.call(this);
};
var namespace = exports.namespace = function namespace(x) {
        return isSymbol(x) ? symbolNamespace(x) : isKeyword(x) ? keywordNamespace(x) : 'else' ? (function () {
            throw new TypeError('' + 'Doesn\'t supports namespace: ' + x);
        })() : void 0;
    };
var gensym = exports.gensym = function gensym(prefix) {
        return symbol('' + (isNil(prefix) ? 'G__' : prefix) + (gensym.base = gensym.base + 1));
    };
gensym.base = 0;
var isUnquote = exports.isUnquote = function isUnquote(form) {
        return isList(form) && isEqual(first(form), symbol(void 0, 'unquote'));
    };
var isUnquoteSplicing = exports.isUnquoteSplicing = function isUnquoteSplicing(form) {
        return isList(form) && isEqual(first(form), symbol(void 0, 'unquote-splicing'));
    };
var isQuote = exports.isQuote = function isQuote(form) {
        return isList(form) && isEqual(first(form), symbol(void 0, 'quote'));
    };
var isSyntaxQuote = exports.isSyntaxQuote = function isSyntaxQuote(form) {
        return isList(form) && isEqual(first(form), symbol(void 0, 'syntax-quote'));
    };
var normalize = function normalize(n, len) {
    return function loop() {
        var recur = loop;
        var nsø1 = '' + n;
        do {
            recur = count(nsø1) < len ? (loop[0] = '' + '0' + nsø1, loop) : nsø1;
        } while (nsø1 = loop[0], recur === loop);
        return recur;
    }.call(this);
};
var quoteString = exports.quoteString = function quoteString(s) {
        s = join('\\"', split(s, '"'));
        s = join('\\\\', split(s, '\\'));
        s = join('\\b', split(s, '\b'));
        s = join('\\f', split(s, '\f'));
        s = join('\\n', split(s, '\n'));
        s = join('\\r', split(s, '\r'));
        s = join('\\t', split(s, '\t'));
        return '' + '"' + s + '"';
    };
var prStr = exports.prStr = function prStr(x, offset) {
        return function () {
            var offsetø2 = offset || 0;
            return isNil(x) ? 'nil' : isKeyword(x) ? namespace(x) ? '' + ':' + namespace(x) + '/' + name(x) : '' + ':' + name(x) : isSymbol(x) ? namespace(x) ? '' + namespace(x) + '/' + name(x) : name(x) : isString(x) ? quoteString(x) : isDate(x) ? '' + '#inst "' + x.getUTCFullYear() + '-' + normalize(inc(x.getUTCMonth()), 2) + '-' + normalize(x.getUTCDate(), 2) + 'T' + normalize(x.getUTCHours(), 2) + ':' + normalize(x.getUTCMinutes(), 2) + ':' + normalize(x.getUTCSeconds(), 2) + '.' + normalize(x.getUTCMilliseconds(), 3) + '-' + '00:00"' : isVector(x) ? '' + '[' + join('' + '\n ' + join(repeat(inc(offsetø2), ' ')), map(function ($1) {
                return prStr($1, inc(offsetø2));
            }, vec(x))) + ']' : isDictionary(x) ? '' + '{' + join('' + ',\n' + join(repeat(inc(offsetø2), ' ')), map(function (pair) {
                return function () {
                    var indentø1 = join(repeat(offsetø2, ' '));
                    var keyø1 = prStr(first(pair), inc(offsetø2));
                    var valueø1 = prStr(second(pair), 2 + offsetø2 + count(keyø1));
                    return '' + keyø1 + ' ' + valueø1;
                }.call(this);
            }, x)) + '}' : isSequential(x) ? '' + '(' + join(' ', map(function ($1) {
                return prStr($1, inc(offsetø2));
            }, vec(x))) + ')' : isRePattern(x) ? '' + '#"' + join('\\/', split(x.source, '/')) + '"' : 'else' ? '' + x : void 0;
        }.call(this);
    };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFub255bW91cy53aXNwIl0sIm5hbWVzIjpbIl9uc18iLCJpZCIsImRvYyIsImlzTGlzdCIsImlzU2VxdWVudGlhbCIsImZpcnN0Iiwic2Vjb25kIiwiY291bnQiLCJsYXN0IiwibWFwIiwidmVjIiwicmVwZWF0Iiwic3BsaXQiLCJqb2luIiwiaXNOaWwiLCJpc1ZlY3RvciIsImlzTnVtYmVyIiwiaXNTdHJpbmciLCJpc0Jvb2xlYW4iLCJpc09iamVjdCIsImlzRGF0ZSIsImlzUmVQYXR0ZXJuIiwiaXNEaWN0aW9uYXJ5Iiwic3RyIiwiaW5jIiwic3VicyIsImlzRXF1YWwiLCJ3aXRoTWV0YSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1ldGFkYXRhIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJtZXRhIiwiX19uc1NlcGFyYXRvcl9fIiwiU3ltYm9sIiwibmFtZXNwYWNlIiwibmFtZSIsInRoaXMiLCJ0eXBlIiwicHJvdG90eXBlLnR5cGUiLCJwcm90b3R5cGUudG9TdHJpbmciLCJwcmVmaXjDuDEiLCJuc8O4MSIsInN5bWJvbCIsIm5zIiwiaXNTeW1ib2wiLCJpc0tleXdvcmQiLCJ4Iiwia2V5d29yZCIsImtleXdvcmROYW1lIiwic3ltYm9sTmFtZSIsImtleXdvcmROYW1lc3BhY2UiLCJwYXJ0c8O4MSIsInN5bWJvbE5hbWVzcGFjZSIsImdlbnN5bSIsInByZWZpeCIsImJhc2UiLCJpc1VucXVvdGUiLCJmb3JtIiwiaXNVbnF1b3RlU3BsaWNpbmciLCJpc1F1b3RlIiwiaXNTeW50YXhRdW90ZSIsIm5vcm1hbGl6ZSIsIm4iLCJsZW4iLCJxdW90ZVN0cmluZyIsInMiLCJwclN0ciIsIm9mZnNldCIsIm9mZnNldMO4MiIsImdldFVUQ0Z1bGxZZWFyIiwiZ2V0VVRDTW9udGgiLCJnZXRVVENEYXRlIiwiZ2V0VVRDSG91cnMiLCJnZXRVVENNaW51dGVzIiwiZ2V0VVRDU2Vjb25kcyIsImdldFVUQ01pbGxpc2Vjb25kcyIsIiQxIiwicGFpciIsImluZGVudMO4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LEdBQ3BCNUMsWUFBRCxDQUFhNEMsQ0FBYixDLFFBQXFCLEcsR0FBS25DLElBQUQsQ0FBTSxHQUFOLEVBQVdKLEdBQUQsQ0FBSyxVQUFTcUUsRUFBVCxFO3VCQUFFVixLLENBQU9VLEUsRUFBR3RELEdBQUQsQ0FBSzhDLFFBQUwsQzthQUFoQixFQUNNNUQsR0FBRCxDQUFLc0MsQ0FBTCxDQURMLENBQVYsQ0FBVCxHQUNrQyxHLEdBQ2pEM0IsV0FBRCxDQUFhMkIsQ0FBYixDLFFBQXFCLEksR0FBT25DLElBQUQsQ0FBTSxLQUFOLEVBQWFELEtBQUQsQ0FBaUJvQyxDQUFWLENBQUdtQyxNQUFWLEVBQW9CLEdBQXBCLENBQVosQ0FBWCxHQUFpRCxHLGNBQzNELEdBQUtuQyxDLFNBbkNqQixDQURJO0FBQUEsUyxLQUFOLEMsSUFBQTtBQUFBLEtBRkYiLCJzb3VyY2VzQ29udGVudCI6WyIobnMgd2lzcC5hc3RcbiAgKDpyZXF1aXJlIFt3aXNwLnNlcXVlbmNlIDpyZWZlciBbbGlzdD8gc2VxdWVudGlhbD8gZmlyc3Qgc2Vjb25kIGNvdW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3QgbWFwIHZlYyByZXBlYXRdXVxuICAgICAgICAgICAgW3dpc3Auc3RyaW5nIDpyZWZlciBbc3BsaXQgam9pbl1dXG4gICAgICAgICAgICBbd2lzcC5ydW50aW1lIDpyZWZlciBbbmlsPyB2ZWN0b3I/IG51bWJlcj8gc3RyaW5nPyBib29sZWFuP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdD8gZGF0ZT8gcmUtcGF0dGVybj8gZGljdGlvbmFyeT9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHIgaW5jIHN1YnMgPV1dKSlcblxuKGRlZm4gd2l0aC1tZXRhXG4gIFwiUmV0dXJucyBpZGVudGljYWwgdmFsdWUgd2l0aCBnaXZlbiBtZXRhZGF0YSBhc3NvY2lhdGVkIHRvIGl0LlwiXG4gIFt2YWx1ZSBtZXRhZGF0YV1cbiAgKC5kZWZpbmVQcm9wZXJ0eSBPYmplY3QgdmFsdWUgXCJtZXRhZGF0YVwiIHs6dmFsdWUgbWV0YWRhdGEgOmNvbmZpZ3VyYWJsZSB0cnVlfSlcbiAgdmFsdWUpXG5cbihkZWZuIG1ldGFcbiAgXCJSZXR1cm5zIHRoZSBtZXRhZGF0YSBvZiB0aGUgZ2l2ZW4gdmFsdWUgb3IgbmlsIGlmIHRoZXJlIGlzIG5vIG1ldGFkYXRhLlwiXG4gIFt2YWx1ZV1cbiAgKGlmIChuaWw/IHZhbHVlKSBuaWwgKC4tbWV0YWRhdGEgdmFsdWUpKSlcblxuKGRlZiAqKm5zLXNlcGFyYXRvcioqIFwiXFx1MjA0NFwiKVxuXG4oZGVmbi0gU3ltYm9sXG4gIFwiVHlwZSBmb3IgdGhlIHN5bWJvbHNcIlxuICBbbmFtZXNwYWNlIG5hbWVdXG4gIChzZXQhICguLW5hbWVzcGFjZSB0aGlzKSBuYW1lc3BhY2UpXG4gIChzZXQhICguLW5hbWUgdGhpcykgbmFtZSlcbiAgdGhpcylcbihzZXQhIFN5bWJvbC50eXBlIFwid2lzcC5zeW1ib2xcIilcbihzZXQhIFN5bWJvbC5wcm90b3R5cGUudHlwZSBTeW1ib2wudHlwZSlcbihzZXQhIFN5bWJvbC5wcm90b3R5cGUudG8tc3RyaW5nXG4gICAgICAoZm4gW11cbiAgICAgICAgKGxldCBbcHJlZml4IChzdHIgXCJcXHVGRUZGXCIgXCInXCIpXG4gICAgICAgICAgICAgIG5zIChuYW1lc3BhY2UgdGhpcyldXG4gICAgICAgICAgKGlmIG5zXG4gICAgICAgICAgICAoc3RyIHByZWZpeCBucyBcIi9cIiAobmFtZSB0aGlzKSlcbiAgICAgICAgICAgIChzdHIgcHJlZml4IChuYW1lIHRoaXMpKSkpKSlcblxuKGRlZm4gc3ltYm9sXG4gIFwiUmV0dXJucyBhIFN5bWJvbCB3aXRoIHRoZSBnaXZlbiBuYW1lc3BhY2UgYW5kIG5hbWUuXCJcbiAgW25zIGlkXVxuICAoY29uZFxuICAgKHN5bWJvbD8gbnMpIG5zXG4gICAoa2V5d29yZD8gbnMpIChTeW1ib2wuIChuYW1lc3BhY2UgbnMpIChuYW1lIG5zKSlcbiAgIChuaWw/IGlkKSAoU3ltYm9sLiBuaWwgbnMpXG4gICA6ZWxzZSAoU3ltYm9sLiBucyBpZCkpKVxuXG4oZGVmbiBeYm9vbGVhbiBzeW1ib2w/IFt4XVxuICAob3IgKGFuZCAoc3RyaW5nPyB4KVxuICAgICAgICAgICAoaWRlbnRpY2FsPyBcIlxcdUZFRkZcIiAoYWdldCB4IDApKVxuICAgICAgICAgICAoaWRlbnRpY2FsPyBcIidcIiAoYWdldCB4IDEpKSlcbiAgICAgIChhbmQgeFxuICAgICAgICAgICAoaWRlbnRpY2FsPyBTeW1ib2wudHlwZSB4LnR5cGUpKSkpXG5cbihkZWZuIF5ib29sZWFuIGtleXdvcmQ/IFt4XVxuICAoYW5kIChzdHJpbmc/IHgpXG4gICAgICAgKD4gKGNvdW50IHgpIDEpXG4gICAgICAgKGlkZW50aWNhbD8gKGZpcnN0IHgpIFwiXFx1QTc4OVwiKSkpXG5cbihkZWZuIGtleXdvcmRcbiAgXCJSZXR1cm5zIGEgS2V5d29yZCB3aXRoIHRoZSBnaXZlbiBuYW1lc3BhY2UgYW5kIG5hbWUuIERvIG5vdCB1c2UgOlxuICBpbiB0aGUga2V5d29yZCBzdHJpbmdzLCBpdCB3aWxsIGJlIGFkZGVkIGF1dG9tYXRpY2FsbHkuXCJcbiAgW25zIGlkXVxuICAoY29uZCAoa2V5d29yZD8gbnMpIG5zXG4gICAgICAgIChzeW1ib2w/IG5zKSAoc3RyIFwiXFx1QTc4OVwiIChuYW1lIG5zKSlcbiAgICAgICAgKG5pbD8gaWQpIChzdHIgXCJcXHVBNzg5XCIgbnMpXG4gICAgICAgIChuaWw/IG5zKSAoc3RyIFwiXFx1QTc4OVwiIGlkKVxuICAgICAgICA6ZWxzZSAoc3RyIFwiXFx1QTc4OVwiIG5zICoqbnMtc2VwYXJhdG9yKiogaWQpKSlcblxuKGRlZm4tIGtleXdvcmQtbmFtZVxuICBbdmFsdWVdXG4gIChsYXN0IChzcGxpdCAoc3VicyB2YWx1ZSAxKSAqKm5zLXNlcGFyYXRvcioqKSkpXG5cbihkZWZuLSBzeW1ib2wtbmFtZVxuICBbdmFsdWVdXG4gIChvciAoLi1uYW1lIHZhbHVlKVxuICAgICAgKGxhc3QgKHNwbGl0IChzdWJzIHZhbHVlIDIpICoqbnMtc2VwYXJhdG9yKiopKSkpXG5cbihkZWZuIG5hbWVcbiAgXCJSZXR1cm5zIHRoZSBuYW1lIFN0cmluZyBvZiBhIHN0cmluZywgc3ltYm9sIG9yIGtleXdvcmQuXCJcbiAgW3ZhbHVlXVxuICAoY29uZCAoc3ltYm9sPyB2YWx1ZSkgKHN5bWJvbC1uYW1lIHZhbHVlKVxuICAgICAgICAoa2V5d29yZD8gdmFsdWUpIChrZXl3b3JkLW5hbWUgdmFsdWUpXG4gICAgICAgIChzdHJpbmc/IHZhbHVlKSB2YWx1ZVxuICAgICAgICA6ZWxzZSAodGhyb3cgKFR5cGVFcnJvci4gKHN0ciBcIkRvZXNuJ3Qgc3VwcG9ydCBuYW1lOiBcIiB2YWx1ZSkpKSkpXG5cbihkZWZuLSBrZXl3b3JkLW5hbWVzcGFjZVxuICBbeF1cbiAgKGxldCBbcGFydHMgKHNwbGl0IChzdWJzIHggMSkgKipucy1zZXBhcmF0b3IqKildXG4gICAgKGlmICg+IChjb3VudCBwYXJ0cykgMSkgKGFnZXQgcGFydHMgMCkpKSlcblxuKGRlZm4tIHN5bWJvbC1uYW1lc3BhY2VcbiAgW3hdXG4gIChsZXQgW3BhcnRzIChpZiAoc3RyaW5nPyB4KVxuICAgICAgICAgICAgICAgIChzcGxpdCAoc3VicyB4IDEpICoqbnMtc2VwYXJhdG9yKiopXG4gICAgICAgICAgICAgICAgWyguLW5hbWVzcGFjZSB4KSAoLi1uYW1lIHgpXSldXG4gICAgKGlmICg+IChjb3VudCBwYXJ0cykgMSkgKGFnZXQgcGFydHMgMCkpKSlcblxuKGRlZm4gbmFtZXNwYWNlXG4gIFwiUmV0dXJucyB0aGUgbmFtZXNwYWNlIFN0cmluZyBvZiBhIHN5bWJvbCBvciBrZXl3b3JkLCBvciBuaWwgaWYgbm90IHByZXNlbnQuXCJcbiAgW3hdXG4gIChjb25kIChzeW1ib2w/IHgpIChzeW1ib2wtbmFtZXNwYWNlIHgpXG4gICAgICAgIChrZXl3b3JkPyB4KSAoa2V5d29yZC1uYW1lc3BhY2UgeClcbiAgICAgICAgOmVsc2UgKHRocm93IChUeXBlRXJyb3IuIChzdHIgXCJEb2Vzbid0IHN1cHBvcnRzIG5hbWVzcGFjZTogXCIgeCkpKSkpXG5cbihkZWZuIGdlbnN5bVxuICBcIlJldHVybnMgYSBuZXcgc3ltYm9sIHdpdGggYSB1bmlxdWUgbmFtZS4gSWYgYSBwcmVmaXggc3RyaW5nIGlzXG4gIHN1cHBsaWVkLCB0aGUgbmFtZSBpcyBwcmVmaXgjIHdoZXJlICMgaXMgc29tZSB1bmlxdWUgbnVtYmVyLiBJZlxuICBwcmVmaXggaXMgbm90IHN1cHBsaWVkLCB0aGUgcHJlZml4IGlzICdHX18nLlwiXG4gIFtwcmVmaXhdXG4gIChzeW1ib2wgKHN0ciAoaWYgKG5pbD8gcHJlZml4KSBcIkdfX1wiIHByZWZpeClcbiAgICAgICAgICAgICAgIChzZXQhIGdlbnN5bS5iYXNlICgrIGdlbnN5bS5iYXNlIDEpKSkpKVxuKHNldCEgZ2Vuc3ltLmJhc2UgMClcblxuXG4oZGVmbiBeYm9vbGVhbiB1bnF1b3RlP1xuICBcIlJldHVybnMgdHJ1ZSBpZiBpdCdzIHVucXVvdGUgZm9ybTogfmZvb1wiXG4gIFtmb3JtXVxuICAoYW5kIChsaXN0PyBmb3JtKSAoPSAoZmlyc3QgZm9ybSkgJ3VucXVvdGUpKSlcblxuKGRlZm4gXmJvb2xlYW4gdW5xdW90ZS1zcGxpY2luZz9cbiAgXCJSZXR1cm5zIHRydWUgaWYgaXQncyB1bnF1b3RlLXNwbGljaW5nIGZvcm06IH5AZm9vXCJcbiAgW2Zvcm1dXG4gIChhbmQgKGxpc3Q/IGZvcm0pICg9IChmaXJzdCBmb3JtKSAndW5xdW90ZS1zcGxpY2luZykpKVxuXG4oZGVmbiBeYm9vbGVhbiBxdW90ZT9cbiAgXCJSZXR1cm5zIHRydWUgaWYgaXQncyBxdW90ZSBmb3JtOiAnZm9vICcoZm9vKVwiXG4gIFtmb3JtXVxuICAoYW5kIChsaXN0PyBmb3JtKSAoPSAoZmlyc3QgZm9ybSkgJ3F1b3RlKSkpXG5cbihkZWZuIF5ib29sZWFuIHN5bnRheC1xdW90ZT9cbiAgXCJSZXR1cm5zIHRydWUgaWYgaXQncyBzeW50YXggcXVvdGUgZm9ybTogYGZvbyBgKGZvbylcIlxuICBbZm9ybV1cbiAgKGFuZCAobGlzdD8gZm9ybSkgKD0gKGZpcnN0IGZvcm0pICdzeW50YXgtcXVvdGUpKSlcblxuKGRlZm4tIG5vcm1hbGl6ZSBbbiBsZW5dXG4gIChsb29wIFtucyAoc3RyIG4pXVxuICAgIChpZiAoPCAoY291bnQgbnMpIGxlbilcbiAgICAgIChyZWN1ciAoc3RyIFwiMFwiIG5zKSlcbiAgICAgIG5zKSkpXG5cbihkZWZuIHF1b3RlLXN0cmluZ1xuICBbc11cbiAgKHNldCEgcyAoam9pbiBcIlxcXFxcXFwiXCIgKHNwbGl0IHMgXCJcXFwiXCIpKSlcbiAgKHNldCEgcyAoam9pbiBcIlxcXFxcXFxcXCIgKHNwbGl0IHMgXCJcXFxcXCIpKSlcbiAgKHNldCEgcyAoam9pbiBcIlxcXFxiXCIgKHNwbGl0IHMgXCJcXGJcIikpKVxuICAoc2V0ISBzIChqb2luIFwiXFxcXGZcIiAoc3BsaXQgcyBcIlxcZlwiKSkpXG4gIChzZXQhIHMgKGpvaW4gXCJcXFxcblwiIChzcGxpdCBzIFwiXFxuXCIpKSlcbiAgKHNldCEgcyAoam9pbiBcIlxcXFxyXCIgKHNwbGl0IHMgXCJcXHJcIikpKVxuICAoc2V0ISBzIChqb2luIFwiXFxcXHRcIiAoc3BsaXQgcyBcIlxcdFwiKSkpXG4gIChzdHIgXCJcXFwiXCIgcyBcIlxcXCJcIikpXG5cbihkZWZuIF5zdHJpbmcgcHItc3RyXG4gIFt4IG9mZnNldF1cbiAgKGxldCBbb2Zmc2V0IChvciBvZmZzZXQgMCldXG4gICAgKGNvbmQgKG5pbD8geCkgXCJuaWxcIlxuICAgICAgICAgIChrZXl3b3JkPyB4KSAoaWYgKG5hbWVzcGFjZSB4KVxuICAgICAgICAgICAgICAgICAgICAgICAgIChzdHIgXCI6XCIgKG5hbWVzcGFjZSB4KSBcIi9cIiAobmFtZSB4KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAoc3RyIFwiOlwiIChuYW1lIHgpKSlcbiAgICAgICAgICAoc3ltYm9sPyB4KSAoaWYgKG5hbWVzcGFjZSB4KVxuICAgICAgICAgICAgICAgICAgICAgICAgKHN0ciAobmFtZXNwYWNlIHgpIFwiL1wiIChuYW1lIHgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgKG5hbWUgeCkpXG4gICAgICAgICAgKHN0cmluZz8geCkgKHF1b3RlLXN0cmluZyB4KVxuICAgICAgICAgIChkYXRlPyB4KSAoc3RyIFwiI2luc3QgXFxcIlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgKC5nZXRVVENGdWxsWWVhciB4KSBcIi1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgIChub3JtYWxpemUgKGluYyAoLmdldFVUQ01vbnRoIHgpKSAyKSBcIi1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgIChub3JtYWxpemUgKC5nZXRVVENEYXRlIHgpIDIpIFwiVFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgKG5vcm1hbGl6ZSAoLmdldFVUQ0hvdXJzIHgpIDIpIFwiOlwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgKG5vcm1hbGl6ZSAoLmdldFVUQ01pbnV0ZXMgeCkgMikgXCI6XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAobm9ybWFsaXplICguZ2V0VVRDU2Vjb25kcyB4KSAyKSBcIi5cIlxuICAgICAgICAgICAgICAgICAgICAgICAgIChub3JtYWxpemUgKC5nZXRVVENNaWxsaXNlY29uZHMgeCkgMykgXCItXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICBcIjAwOjAwXFxcIlwiKVxuICAgICAgICAgICh2ZWN0b3I/IHgpIChzdHIgXCJbXCIgKGpvaW4gKHN0ciBcIlxcbiBcIiAoam9pbiAocmVwZWF0IChpbmMgb2Zmc2V0KSBcIiBcIikpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtYXAgIyhwci1zdHIgJSAoaW5jIG9mZnNldCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodmVjIHgpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXVwiKVxuICAgICAgICAgIChkaWN0aW9uYXJ5PyB4KSAoc3RyIFwie1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGpvaW4gKHN0ciBcIixcXG5cIiAoam9pbiAocmVwZWF0IChpbmMgb2Zmc2V0KSBcIiBcIikpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtYXAgKGZuIFtwYWlyXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobGV0IFtpbmRlbnQgKGpvaW4gKHJlcGVhdCBvZmZzZXQgXCIgXCIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkgKHByLXN0ciAoZmlyc3QgcGFpcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGluYyBvZmZzZXQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSAocHItc3RyIChzZWNvbmQgcGFpcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKyAyIG9mZnNldCAoY291bnQga2V5KSkpXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzdHIga2V5IFwiIFwiIHZhbHVlKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIn1cIilcbiAgICAgICAgICAoc2VxdWVudGlhbD8geCkgKHN0ciBcIihcIiAoam9pbiBcIiBcIiAobWFwICMocHItc3RyICUgKGluYyBvZmZzZXQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodmVjIHgpKSkgXCIpXCIpXG4gICAgICAgICAgKHJlLXBhdHRlcm4/IHgpIChzdHIgXCIjXFxcIlwiIChqb2luIFwiXFxcXC9cIiAoc3BsaXQgKC4tc291cmNlIHgpIFwiL1wiKSkgXCJcXFwiXCIpXG4gICAgICAgICAgOmVsc2UgKHN0ciB4KSkpKVxuIl19

},{"./runtime":"wcC2X1","./sequence":"Mdzbzt","./string":"31fh9Q"}],5:[function(require,module,exports){
{
    var _ns_ = {
            id: 'wisp.backend.escodegen.generator',
            doc: void 0
        };
    var wisp_reader = require('./../../reader');
    var readString = wisp_reader.readFromString;
    var read_ = wisp_reader.read_;
    var wisp_ast = require('./../../ast');
    var meta = wisp_ast.meta;
    var withMeta = wisp_ast.withMeta;
    var isSymbol = wisp_ast.isSymbol;
    var symbol = wisp_ast.symbol;
    var isKeyword = wisp_ast.isKeyword;
    var keyword = wisp_ast.keyword;
    var namespace = wisp_ast.namespace;
    var isUnquote = wisp_ast.isUnquote;
    var isUnquoteSplicing = wisp_ast.isUnquoteSplicing;
    var isQuote = wisp_ast.isQuote;
    var isSyntaxQuote = wisp_ast.isSyntaxQuote;
    var name = wisp_ast.name;
    var gensym = wisp_ast.gensym;
    var prStr = wisp_ast.prStr;
    var wisp_sequence = require('./../../sequence');
    var isEmpty = wisp_sequence.isEmpty;
    var count = wisp_sequence.count;
    var isList = wisp_sequence.isList;
    var list = wisp_sequence.list;
    var first = wisp_sequence.first;
    var second = wisp_sequence.second;
    var third = wisp_sequence.third;
    var rest = wisp_sequence.rest;
    var cons = wisp_sequence.cons;
    var conj = wisp_sequence.conj;
    var butlast = wisp_sequence.butlast;
    var reverse = wisp_sequence.reverse;
    var reduce = wisp_sequence.reduce;
    var vec = wisp_sequence.vec;
    var last = wisp_sequence.last;
    var map = wisp_sequence.map;
    var filter = wisp_sequence.filter;
    var take = wisp_sequence.take;
    var concat = wisp_sequence.concat;
    var partition = wisp_sequence.partition;
    var repeat = wisp_sequence.repeat;
    var interleave = wisp_sequence.interleave;
    var wisp_runtime = require('./../../runtime');
    var isOdd = wisp_runtime.isOdd;
    var isDictionary = wisp_runtime.isDictionary;
    var dictionary = wisp_runtime.dictionary;
    var merge = wisp_runtime.merge;
    var keys = wisp_runtime.keys;
    var vals = wisp_runtime.vals;
    var isContainsVector = wisp_runtime.isContainsVector;
    var mapDictionary = wisp_runtime.mapDictionary;
    var isString = wisp_runtime.isString;
    var isNumber = wisp_runtime.isNumber;
    var isVector = wisp_runtime.isVector;
    var isBoolean = wisp_runtime.isBoolean;
    var subs = wisp_runtime.subs;
    var reFind = wisp_runtime.reFind;
    var isTrue = wisp_runtime.isTrue;
    var isFalse = wisp_runtime.isFalse;
    var isNil = wisp_runtime.isNil;
    var isRePattern = wisp_runtime.isRePattern;
    var inc = wisp_runtime.inc;
    var dec = wisp_runtime.dec;
    var str = wisp_runtime.str;
    var char = wisp_runtime.char;
    var int = wisp_runtime.int;
    var isEqual = wisp_runtime.isEqual;
    var isStrictEqual = wisp_runtime.isStrictEqual;
    var wisp_string = require('./../../string');
    var split = wisp_string.split;
    var join = wisp_string.join;
    var upperCase = wisp_string.upperCase;
    var replace = wisp_string.replace;
    var wisp_expander = require('./../../expander');
    var installMacro = wisp_expander.installMacro;
    var wisp_analyzer = require('./../../analyzer');
    var emptyEnv = wisp_analyzer.emptyEnv;
    var analyze = wisp_analyzer.analyze;
    var analyze_ = wisp_analyzer.analyze_;
    var wisp_backend_escodegen_writer = require('./writer');
    var write = wisp_backend_escodegen_writer.write;
    var compile = wisp_backend_escodegen_writer.compile;
    var write_ = wisp_backend_escodegen_writer.write_;
    var escodegen = require('escodegen');
    var generate_ = escodegen.generate;
    var base64Encode = require('base64-encode');
    var btoa = base64Encode;
    var fs = require('fs');
    var readFileSync = fs.readFileSync;
    var writeFileSync = fs.writeFileSync;
    var path = require('path');
    var basename = path.basename;
    var dirname = path.dirname;
    var joinPath = path.join;
}
var generate = exports.generate = function generate(options) {
        var nodes = Array.prototype.slice.call(arguments, 1);
        return function () {
            var astø1 = write_.apply(void 0, nodes);
            var outputø1 = generate_(astø1, {
                    'file': (options || 0)['output-uri'],
                    'sourceContent': (options || 0)['source'],
                    'sourceMap': (options || 0)['source-uri'],
                    'sourceMapRoot': (options || 0)['source-root'],
                    'sourceMapWithCode': true
                });
            (outputø1 || 0)['map'].setSourceContent((options || 0)['source-uri'], (options || 0)['source']);
            return {
                'code': (options || 0)['no-map'] ? (outputø1 || 0)['code'] : '' + (outputø1 || 0)['code'] + '\n//# sourceMappingURL=' + 'data:application/json;base64,' + btoa('' + (outputø1 || 0)['map']) + '\n',
                'source-map': (outputø1 || 0)['map'],
                'js-ast': astø1
            };
        }.call(this);
    };
var expandDefmacro = exports.expandDefmacro = function expandDefmacro(_andForm, id) {
        var body = Array.prototype.slice.call(arguments, 2);
        return function () {
            var fnø1 = withMeta(list.apply(void 0, [symbol(void 0, 'defn')].concat([id], vec(body))), meta(_andForm));
            var formø1 = list.apply(void 0, [symbol(void 0, 'do')].concat([fnø1], [id]));
            var astø1 = analyze(formø1);
            var codeø1 = compile(astø1);
            var macroø1 = eval(codeø1);
            installMacro(id, macroø1);
            return void 0;
        }.call(this);
    };
installMacro(symbol(void 0, 'defmacro'), withMeta(expandDefmacro, { 'implicit': ['&form'] }));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFub255bW91cy53aXNwIl0sIm5hbWVzIjpbIl9uc18iLCJpZCIsImRvYyIsInJlYWRTdHJpbmciLCJyZWFkRnJvbVN0cmluZyIsInJlYWRfIiwibWV0YSIsIndpdGhNZXRhIiwiaXNTeW1ib2wiLCJzeW1ib2wiLCJpc0tleXdvcmQiLCJrZXl3b3JkIiwibmFtZXNwYWNlIiwiaXNVbnF1b3RlIiwiaXNVbnF1b3RlU3BsaWNpbmciLCJpc1F1b3RlIiwiaXNTeW50YXhRdW90ZSIsIm5hbWUiLCJnZW5zeW0iLCJwclN0ciIsImlzRW1wdHkiLCJjb3VudCIsImlzTGlzdCIsImxpc3QiLCJmaXJzdCIsInNlY29uZCIsInRoaXJkIiwicmVzdCIsImNvbnMiLCJjb25qIiwiYnV0bGFzdCIsInJldmVyc2UiLCJyZWR1Y2UiLCJ2ZWMiLCJsYXN0IiwibWFwIiwiZmlsdGVyIiwidGFrZSIsImNvbmNhdCIsInBhcnRpdGlvbiIsInJlcGVhdCIsImludGVybGVhdmUiLCJpc09kZCIsImlzRGljdGlvbmFyeSIsImRpY3Rpb25hcnkiLCJtZXJnZSIsImtleXMiLCJ2YWxzIiwiaXNDb250YWluc1ZlY3RvciIsIm1hcERpY3Rpb25hcnkiLCJpc1N0cmluZyIsImlzTnVtYmVyIiwiaXNWZWN0b3IiLCJpc0Jvb2xlYW4iLCJzdWJzIiwicmVGaW5kIiwiaXNUcnVlIiwiaXNGYWxzZSIsImlzTmlsIiwiaXNSZVBhdHRlcm4iLCJpbmMiLCJkZWMiLCJzdHIiLCJjaGFyIiwiaW50IiwiaXNFcXVhbCIsImlzU3RyaWN0RXF1YWwiLCJzcGxpdCIsImpvaW4iLCJ1cHBlckNhc2UiLCJyZXBsYWNlIiwiaW5zdGFsbE1hY3JvIiwiZW1wdHlFbnYiLCJhbmFseXplIiwiYW5hbHl6ZV8iLCJ3cml0ZSIsImNvbXBpbGUiLCJ3cml0ZV8iLCJnZW5lcmF0ZV8iLCJnZW5lcmF0ZSIsInJlYWRGaWxlU3luYyIsIndyaXRlRmlsZVN5bmMiLCJiYXNlbmFtZSIsImRpcm5hbWUiLCJqb2luUGF0aCIsImV4cG9ydHMiLCJvcHRpb25zIiwibm9kZXMiLCJhc3TDuDEiLCJvdXRwdXTDuDEiLCJzZXRTb3VyY2VDb250ZW50IiwiYnRvYSIsImV4cGFuZERlZm1hY3JvIiwiX2FuZEZvcm0iLCJib2R5IiwiZm7DuDEiLCJmb3Jtw7gxIiwiY29kZcO4MSIsIm1hY3Jvw7gxIiwiZXZhbCJdLCJtYXBwaW5ncyI6IjtJQUFBLElBQUNBLEksR0FBRDtBQUFBLFlBQUFDLEUsRUFBSSxrQ0FBSjtBQUFBLFlBQUFDLEcsRUFBQSxLLENBQUE7QUFBQSxVOztRQUVtREMsVUFBQSxHLFlBRGxCQyxjO1FBQWlCQyxLQUFBLEcsWUFBQUEsSzs7UUFFcEJDLElBQUEsRyxTQUFBQSxJO1FBQUtDLFFBQUEsRyxTQUFBQSxRO1FBQVVDLFFBQUEsRyxTQUFBQSxRO1FBQVFDLE1BQUEsRyxTQUFBQSxNO1FBQU9DLFNBQUEsRyxTQUFBQSxTO1FBQVNDLE9BQUEsRyxTQUFBQSxPO1FBQ3ZDQyxTQUFBLEcsU0FBQUEsUztRQUFVQyxTQUFBLEcsU0FBQUEsUztRQUFTQyxpQkFBQSxHLFNBQUFBLGlCO1FBQWtCQyxPQUFBLEcsU0FBQUEsTztRQUNyQ0MsYUFBQSxHLFNBQUFBLGE7UUFBY0MsSUFBQSxHLFNBQUFBLEk7UUFBS0MsTUFBQSxHLFNBQUFBLE07UUFBT0MsS0FBQSxHLFNBQUFBLEs7O1FBQ3JCQyxPQUFBLEcsY0FBQUEsTztRQUFPQyxLQUFBLEcsY0FBQUEsSztRQUFNQyxNQUFBLEcsY0FBQUEsTTtRQUFNQyxJQUFBLEcsY0FBQUEsSTtRQUFLQyxLQUFBLEcsY0FBQUEsSztRQUFNQyxNQUFBLEcsY0FBQUEsTTtRQUFPQyxLQUFBLEcsY0FBQUEsSztRQUNyQ0MsSUFBQSxHLGNBQUFBLEk7UUFBS0MsSUFBQSxHLGNBQUFBLEk7UUFBS0MsSUFBQSxHLGNBQUFBLEk7UUFBS0MsT0FBQSxHLGNBQUFBLE87UUFBUUMsT0FBQSxHLGNBQUFBLE87UUFBUUMsTUFBQSxHLGNBQUFBLE07UUFBT0MsR0FBQSxHLGNBQUFBLEc7UUFDdENDLElBQUEsRyxj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LElBQU1JLGNBQUEsR0FBQVAsT0FBQSxDQUFBTyxjQUFBLEdBQU4sU0FBTUEsY0FBTixDQUlHQyxRQUpILEVBSVM1RixFQUpULEU7WUFJYzZGLElBQUEsRztRQUNaLE87WUFBTSxJQUFBQyxJLEdBQUl4RixRQUFELEMsVUFBVyxDLE1BQUEsRSxPQUFFLEMsTUFBQSxFLE1BQUEsQyxVQUFNTixFLE9BQUs2RixJLEVBQWIsQ0FBWCxFQUErQnhGLElBQUQsQ0FBTXVGLFFBQU4sQ0FBOUIsQ0FBSCxDO1lBQ0EsSUFBQUcsTSxhQUFLLEMsTUFBQSxFLE9BQUUsQyxNQUFBLEUsSUFBQSxDLFVBQUlELEksSUFBSTlGLEUsRUFBVixDQUFMLEM7WUFDQSxJQUFBdUYsSyxHQUFLZixPQUFELENBQVN1QixNQUFULENBQUosQztZQUNBLElBQUFDLE0sR0FBTXJCLE9BQUQsQ0FBU1ksS0FBVCxDQUFMLEM7WUFDQSxJQUFBVSxPLEdBQU9DLElBQUQsQ0FBTUYsTUFBTixDQUFOLEM7WUFDSDFCLFlBQUQsQ0FBZ0J0RSxFQUFoQixFQUFtQmlHLE9BQW5CLEU7O2NBTEYsQyxJQUFBLEU7S0FMRixDO0FBWUMzQixZQUFELEMsTUFBaUIsQyxNQUFBLEUsVUFBQSxDQUFqQixFQUEyQmhFLFFBQUQsQ0FBV3FGLGNBQVgsRUFBMkIsRSxZQUFXLEMsT0FBQSxDQUFYLEVBQTNCLENBQTFCIiwic291cmNlc0NvbnRlbnQiOlsiKG5zIHdpc3AuYmFja2VuZC5lc2NvZGVnZW4uZ2VuZXJhdG9yXG4gICg6cmVxdWlyZSBbd2lzcC5yZWFkZXIgOnJlZmVyIFtyZWFkLWZyb20tc3RyaW5nIHJlYWQqXVxuICAgICAgICAgICAgICAgICAgICAgICAgIDpyZW5hbWUge3JlYWQtZnJvbS1zdHJpbmcgcmVhZC1zdHJpbmd9XVxuICAgICAgICAgICAgW3dpc3AuYXN0IDpyZWZlciBbbWV0YSB3aXRoLW1ldGEgc3ltYm9sPyBzeW1ib2wga2V5d29yZD8ga2V5d29yZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZXNwYWNlIHVucXVvdGU/IHVucXVvdGUtc3BsaWNpbmc/IHF1b3RlP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ludGF4LXF1b3RlPyBuYW1lIGdlbnN5bSBwci1zdHJdXVxuICAgICAgICAgICAgW3dpc3Auc2VxdWVuY2UgOnJlZmVyIFtlbXB0eT8gY291bnQgbGlzdD8gbGlzdCBmaXJzdCBzZWNvbmQgdGhpcmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdCBjb25zIGNvbmogYnV0bGFzdCByZXZlcnNlIHJlZHVjZSB2ZWNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdCBtYXAgZmlsdGVyIHRha2UgY29uY2F0IHBhcnRpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBlYXQgaW50ZXJsZWF2ZV1dXG4gICAgICAgICAgICBbd2lzcC5ydW50aW1lIDpyZWZlciBbb2RkPyBkaWN0aW9uYXJ5PyBkaWN0aW9uYXJ5IG1lcmdlIGtleXMgdmFsc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5zLXZlY3Rvcj8gbWFwLWRpY3Rpb25hcnkgc3RyaW5nP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bWJlcj8gdmVjdG9yPyBib29sZWFuPyBzdWJzIHJlLWZpbmQgdHJ1ZT9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZT8gbmlsPyByZS1wYXR0ZXJuPyBpbmMgZGVjIHN0ciBjaGFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ID0gPT1dXVxuICAgICAgICAgICAgW3dpc3Auc3RyaW5nIDpyZWZlciBbc3BsaXQgam9pbiB1cHBlci1jYXNlIHJlcGxhY2VdXVxuICAgICAgICAgICAgW3dpc3AuZXhwYW5kZXIgOnJlZmVyIFtpbnN0YWxsLW1hY3JvIV1dXG4gICAgICAgICAgICBbd2lzcC5hbmFseXplciA6cmVmZXIgW2VtcHR5LWVudiBhbmFseXplIGFuYWx5emUqXV1cbiAgICAgICAgICAgIFt3aXNwLmJhY2tlbmQuZXNjb2RlZ2VuLndyaXRlciA6cmVmZXIgW3dyaXRlIGNvbXBpbGUgd3JpdGUqXV1cblxuICAgICAgICAgICAgW2VzY29kZWdlbiA6cmVmZXIgW2dlbmVyYXRlXSA6cmVuYW1lIHtnZW5lcmF0ZSBnZW5lcmF0ZSp9XVxuICAgICAgICAgICAgW2Jhc2U2NC1lbmNvZGUgOmFzIGJ0b2FdXG4gICAgICAgICAgICBbZnMgOnJlZmVyIFtyZWFkLWZpbGUtc3luYyB3cml0ZS1maWxlLXN5bmNdXVxuICAgICAgICAgICAgW3BhdGggOnJlZmVyIFtiYXNlbmFtZSBkaXJuYW1lIGpvaW5dXG4gICAgICAgICAgICAgICAgICA6cmVuYW1lIHtqb2luIGpvaW4tcGF0aH1dKSlcblxuKGRlZm4gZ2VuZXJhdGVcbiAgW29wdGlvbnMgJiBub2Rlc11cbiAgKGxldCBbYXN0IChhcHBseSB3cml0ZSogbm9kZXMpXG5cbiAgICAgICAgb3V0cHV0IChnZW5lcmF0ZSogYXN0IHs6ZmlsZSAoOm91dHB1dC11cmkgb3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6c291cmNlQ29udGVudCAoOnNvdXJjZSBvcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpzb3VyY2VNYXAgKDpzb3VyY2UtdXJpIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOnNvdXJjZU1hcFJvb3QgKDpzb3VyY2Utcm9vdCBvcHRpb25zKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpzb3VyY2VNYXBXaXRoQ29kZSB0cnVlfSldXG5cbiAgICA7OyBXb3JrYXJvdW5kIHRoZSBmYWN0IHRoYXQgZXNjb2RlZ2VuIGRvZXMgbm90IHlldCBpbmNsdWRlcyBzb3VyY2VcbiAgICAoLnNldFNvdXJjZUNvbnRlbnQgKDptYXAgb3V0cHV0KVxuICAgICAgICAgICAgICAgICAgICAgICAoOnNvdXJjZS11cmkgb3B0aW9ucylcbiAgICAgICAgICAgICAgICAgICAgICAgKDpzb3VyY2Ugb3B0aW9ucykpXG5cbiAgICB7OmNvZGUgKGlmICg6bm8tbWFwIG9wdGlvbnMpXG4gICAgICAgICAgICAgKDpjb2RlIG91dHB1dClcbiAgICAgICAgICAgICAoc3RyICg6Y29kZSBvdXRwdXQpXG4gICAgICAgICAgICAgICAgICBcIlxcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVwiXG4gICAgICAgICAgICAgICAgICBcImRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCJcbiAgICAgICAgICAgICAgICAgIChidG9hIChzdHIgKDptYXAgb3V0cHV0KSkpXG4gICAgICAgICAgICAgICAgICBcIlxcblwiKSlcbiAgICAgOnNvdXJjZS1tYXAgKDptYXAgb3V0cHV0KVxuICAgICA6anMtYXN0IGFzdH0pKVxuXG5cbihkZWZuIGV4cGFuZC1kZWZtYWNyb1xuICBcIkxpa2UgZGVmbiwgYnV0IHRoZSByZXN1bHRpbmcgZnVuY3Rpb24gbmFtZSBpcyBkZWNsYXJlZCBhcyBhXG4gIG1hY3JvIGFuZCB3aWxsIGJlIHVzZWQgYXMgYSBtYWNybyBieSB0aGUgY29tcGlsZXIgd2hlbiBpdCBpc1xuICBjYWxsZWQuXCJcbiAgWyZmb3JtIGlkICYgYm9keV1cbiAgKGxldCBbZm4gKHdpdGgtbWV0YSBgKGRlZm4gfmlkIH5AYm9keSkgKG1ldGEgJmZvcm0pKVxuICAgICAgICBmb3JtIGAoZG8gfmZuIH5pZClcbiAgICAgICAgYXN0IChhbmFseXplIGZvcm0pXG4gICAgICAgIGNvZGUgKGNvbXBpbGUgYXN0KVxuICAgICAgICBtYWNybyAoZXZhbCBjb2RlKV1cbiAgICAoaW5zdGFsbC1tYWNybyEgaWQgbWFjcm8pXG4gICAgbmlsKSlcbihpbnN0YWxsLW1hY3JvISAnZGVmbWFjcm8gKHdpdGgtbWV0YSBleHBhbmQtZGVmbWFjcm8gezppbXBsaWNpdCBbOiZmb3JtXX0pKVxuIl19

},{"./../../analyzer":"6TzXFU","./../../ast":"ReP8Ll","./../../expander":"RaoPh2","./../../reader":"vmsNNR","./../../runtime":"wcC2X1","./../../sequence":"Mdzbzt","./../../string":"31fh9Q","./writer":6,"base64-encode":16,"escodegen":22,"fs":18,"path":19}],6:[function(require,module,exports){
{
    var _ns_ = {
            id: 'wisp.backend.escodegen.writer',
            doc: void 0
        };
    var wisp_reader = require('./../../reader');
    var readFromString = wisp_reader.readFromString;
    var wisp_ast = require('./../../ast');
    var meta = wisp_ast.meta;
    var withMeta = wisp_ast.withMeta;
    var isSymbol = wisp_ast.isSymbol;
    var symbol = wisp_ast.symbol;
    var isKeyword = wisp_ast.isKeyword;
    var keyword = wisp_ast.keyword;
    var namespace = wisp_ast.namespace;
    var isUnquote = wisp_ast.isUnquote;
    var isUnquoteSplicing = wisp_ast.isUnquoteSplicing;
    var isQuote = wisp_ast.isQuote;
    var isSyntaxQuote = wisp_ast.isSyntaxQuote;
    var name = wisp_ast.name;
    var gensym = wisp_ast.gensym;
    var prStr = wisp_ast.prStr;
    var wisp_sequence = require('./../../sequence');
    var isEmpty = wisp_sequence.isEmpty;
    var count = wisp_sequence.count;
    var isList = wisp_sequence.isList;
    var list = wisp_sequence.list;
    var first = wisp_sequence.first;
    var second = wisp_sequence.second;
    var third = wisp_sequence.third;
    var rest = wisp_sequence.rest;
    var cons = wisp_sequence.cons;
    var conj = wisp_sequence.conj;
    var butlast = wisp_sequence.butlast;
    var reverse = wisp_sequence.reverse;
    var reduce = wisp_sequence.reduce;
    var vec = wisp_sequence.vec;
    var last = wisp_sequence.last;
    var map = wisp_sequence.map;
    var filter = wisp_sequence.filter;
    var take = wisp_sequence.take;
    var concat = wisp_sequence.concat;
    var partition = wisp_sequence.partition;
    var repeat = wisp_sequence.repeat;
    var interleave = wisp_sequence.interleave;
    var assoc = wisp_sequence.assoc;
    var wisp_runtime = require('./../../runtime');
    var isOdd = wisp_runtime.isOdd;
    var isDictionary = wisp_runtime.isDictionary;
    var dictionary = wisp_runtime.dictionary;
    var merge = wisp_runtime.merge;
    var keys = wisp_runtime.keys;
    var vals = wisp_runtime.vals;
    var isContainsVector = wisp_runtime.isContainsVector;
    var mapDictionary = wisp_runtime.mapDictionary;
    var isString = wisp_runtime.isString;
    var isNumber = wisp_runtime.isNumber;
    var isVector = wisp_runtime.isVector;
    var isBoolean = wisp_runtime.isBoolean;
    var subs = wisp_runtime.subs;
    var reFind = wisp_runtime.reFind;
    var isTrue = wisp_runtime.isTrue;
    var isFalse = wisp_runtime.isFalse;
    var isNil = wisp_runtime.isNil;
    var isRePattern = wisp_runtime.isRePattern;
    var inc = wisp_runtime.inc;
    var dec = wisp_runtime.dec;
    var str = wisp_runtime.str;
    var char = wisp_runtime.char;
    var int = wisp_runtime.int;
    var isEqual = wisp_runtime.isEqual;
    var isStrictEqual = wisp_runtime.isStrictEqual;
    var wisp_string = require('./../../string');
    var split = wisp_string.split;
    var join = wisp_string.join;
    var upperCase = wisp_string.upperCase;
    var replace = wisp_string.replace;
    var triml = wisp_string.triml;
    var wisp_expander = require('./../../expander');
    var installMacro = wisp_expander.installMacro;
    var escodegen = require('escodegen');
    var generate = escodegen.generate;
}
var __uniqueChar__ = exports.__uniqueChar__ = '\xF8';
var toCamelJoin = exports.toCamelJoin = function toCamelJoin(prefix, key) {
        return '' + prefix + (!isEmpty(prefix) && !isEmpty(key) ? '' + upperCase((key || 0)[0]) + subs(key, 1) : key);
    };
var toPrivatePrefix = exports.toPrivatePrefix = function toPrivatePrefix(id) {
        return function () {
            var spaceDelimitedø1 = join(' ', split(id, /-/));
            var leftTrimmedø1 = triml(spaceDelimitedø1);
            var nø1 = count(id) - count(leftTrimmedø1);
            return nø1 > 0 ? '' + join('_', repeat(inc(nø1), '')) + subs(id, nø1) : id;
        }.call(this);
    };
var translateIdentifierWord = exports.translateIdentifierWord = function translateIdentifierWord(form) {
        var id = name(form);
        id = id === '*' ? 'multiply' : id === '/' ? 'divide' : id === '+' ? 'sum' : id === '-' ? 'subtract' : id === '=' ? 'equal?' : id === '==' ? 'strict-equal?' : id === '<=' ? 'not-greater-than' : id === '>=' ? 'not-less-than' : id === '>' ? 'greater-than' : id === '<' ? 'less-than' : id === '->' ? 'thread-first' : 'else' ? id : void 0;
        id = join('_', split(id, '*'));
        id = join('_', split(id, '.'));
        id = subs(id, 0, 2) === '->' ? subs(join('-to-', split(id, '->')), 1) : join('-to-', split(id, '->'));
        id = join(split(id, '!'));
        id = join('$', split(id, '%'));
        id = join('-equal-', split(id, '='));
        id = join('-plus-', split(id, '+'));
        id = join('-and-', split(id, '&'));
        id = last(id) === '?' ? '' + 'is-' + subs(id, 0, dec(count(id))) : id;
        id = toPrivatePrefix(id);
        id = reduce(toCamelJoin, '', split(id, '-'));
        return id;
    };
var translateIdentifier = exports.translateIdentifier = function translateIdentifier(form) {
        return function () {
            var nsø1 = namespace(form);
            return '' + (nsø1 && !isEqual(nsø1, 'js') ? '' + translateIdentifierWord(namespace(form)) + '.' : '') + join('.', map(translateIdentifierWord, split(name(form), '.')));
        }.call(this);
    };
var errorArgCount = exports.errorArgCount = function errorArgCount(callee, n) {
        return (function () {
            throw SyntaxError('' + 'Wrong number of arguments (' + n + ') passed to: ' + callee);
        })();
    };
var inheritLocation = exports.inheritLocation = function inheritLocation(body) {
        return function () {
            var startø1 = ((first(body) || 0)['loc'] || 0)['start'];
            var endø1 = ((last(body) || 0)['loc'] || 0)['end'];
            return !(isNil(startø1) || isNil(endø1)) ? {
                'start': startø1,
                'end': endø1
            } : void 0;
        }.call(this);
    };
var writeLocation = exports.writeLocation = function writeLocation(form, original) {
        return function () {
            var dataø1 = meta(form);
            var inheritedø1 = meta(original);
            var startø1 = (form || 0)['start'] || (dataø1 || 0)['start'] || (inheritedø1 || 0)['start'];
            var endø1 = (form || 0)['end'] || (dataø1 || 0)['end'] || (inheritedø1 || 0)['end'];
            return !isNil(startø1) ? {
                'loc': {
                    'start': {
                        'line': inc((startø1 || 0)['line']),
                        'column': (startø1 || 0)['column']
                    },
                    'end': {
                        'line': inc((endø1 || 0)['line']),
                        'column': (endø1 || 0)['column']
                    }
                }
            } : {};
        }.call(this);
    };
var __writers__ = exports.__writers__ = {};
var installWriter = exports.installWriter = function installWriter(op, writer) {
        return (__writers__ || 0)[op] = writer;
    };
var writeOp = exports.writeOp = function writeOp(op, form) {
        return function () {
            var writerø1 = (__writers__ || 0)[op];
            !writerø1 ? (function () {
                throw Error('' + 'Assert failed: ' + ('' + 'Unsupported operation: ' + op) + 'writer');
            })() : void 0;
            return conj(writeLocation((form || 0)['form'], (form || 0)['original-form']), writerø1(form));
        }.call(this);
    };
var __specials__ = exports.__specials__ = {};
var installSpecial = exports.installSpecial = function installSpecial(op, writer) {
        return (__specials__ || 0)[name(op)] = writer;
    };
var writeSpecial = exports.writeSpecial = function writeSpecial(writer, form) {
        return conj(writeLocation((form || 0)['form'], (form || 0)['original-form']), writer.apply(void 0, (form || 0)['params']));
    };
var writeNil = exports.writeNil = function writeNil(form) {
        return {
            'type': 'UnaryExpression',
            'operator': 'void',
            'argument': {
                'type': 'Literal',
                'value': 0
            },
            'prefix': true
        };
    };
installWriter('nil', writeNil);
var writeLiteral = exports.writeLiteral = function writeLiteral(form) {
        return {
            'type': 'Literal',
            'value': form
        };
    };
var writeList = exports.writeList = function writeList(form) {
        return {
            'type': 'CallExpression',
            'callee': write({
                'op': 'var',
                'form': symbol(void 0, 'list')
            }),
            'arguments': map(write, (form || 0)['items'])
        };
    };
installWriter('list', writeList);
var writeSymbol = exports.writeSymbol = function writeSymbol(form) {
        return {
            'type': 'CallExpression',
            'callee': write({
                'op': 'var',
                'form': symbol(void 0, 'symbol')
            }),
            'arguments': [
                writeConstant((form || 0)['namespace']),
                writeConstant((form || 0)['name'])
            ]
        };
    };
installWriter('symbol', writeSymbol);
var writeConstant = exports.writeConstant = function writeConstant(form) {
        return isNil(form) ? writeNil(form) : isKeyword(form) ? writeLiteral(namespace(form) ? '' + namespace(form) + '/' + name(form) : name(form)) : isNumber(form) ? writeNumber(form.valueOf()) : isString(form) ? writeString(form) : 'else' ? writeLiteral(form) : void 0;
    };
installWriter('constant', function ($1) {
    return writeConstant(($1 || 0)['form']);
});
var writeString = exports.writeString = function writeString(form) {
        return {
            'type': 'Literal',
            'value': '' + form
        };
    };
var writeNumber = exports.writeNumber = function writeNumber(form) {
        return form < 0 ? {
            'type': 'UnaryExpression',
            'operator': '-',
            'prefix': true,
            'argument': writeNumber(form * -1)
        } : writeLiteral(form);
    };
var writeKeyword = exports.writeKeyword = function writeKeyword(form) {
        return {
            'type': 'Literal',
            'value': (form || 0)['form']
        };
    };
installWriter('keyword', writeKeyword);
var toIdentifier = exports.toIdentifier = function toIdentifier(form) {
        return {
            'type': 'Identifier',
            'name': translateIdentifier(form)
        };
    };
var writeBindingVar = exports.writeBindingVar = function writeBindingVar(form) {
        return function () {
            var baseIdø1 = (form || 0)['id'];
            var resolvedIdø1 = (form || 0)['shadow'] ? symbol(void 0, '' + translateIdentifier(baseIdø1) + __uniqueChar__ + (form || 0)['depth']) : baseIdø1;
            return conj(toIdentifier(resolvedIdø1), writeLocation(baseIdø1));
        }.call(this);
    };
var writeVar = exports.writeVar = function writeVar(node) {
        return isEqual('binding', ((node || 0)['binding'] || 0)['type']) ? conj(writeBindingVar((node || 0)['binding']), writeLocation((node || 0)['form'])) : conj(writeLocation((node || 0)['form']), toIdentifier((node || 0)['form']));
    };
installWriter('var', writeVar);
installWriter('param', writeVar);
var writeInvoke = exports.writeInvoke = function writeInvoke(form) {
        return {
            'type': 'CallExpression',
            'callee': write((form || 0)['callee']),
            'arguments': map(write, (form || 0)['params'])
        };
    };
installWriter('invoke', writeInvoke);
var writeVector = exports.writeVector = function writeVector(form) {
        return {
            'type': 'ArrayExpression',
            'elements': map(write, (form || 0)['items'])
        };
    };
installWriter('vector', writeVector);
var writeDictionary = exports.writeDictionary = function writeDictionary(form) {
        return function () {
            var propertiesø1 = partition(2, interleave((form || 0)['keys'], (form || 0)['values']));
            return {
                'type': 'ObjectExpression',
                'properties': map(function (pair) {
                    return function () {
                        var keyø1 = first(pair);
                        var valueø1 = second(pair);
                        return {
                            'kind': 'init',
                            'type': 'Property',
                            'key': isEqual('symbol', (keyø1 || 0)['op']) ? writeConstant('' + (keyø1 || 0)['form']) : write(keyø1),
                            'value': write(valueø1)
                        };
                    }.call(this);
                }, propertiesø1)
            };
        }.call(this);
    };
installWriter('dictionary', writeDictionary);
var writeExport = exports.writeExport = function writeExport(form) {
        return write({
            'op': 'set!',
            'target': {
                'op': 'member-expression',
                'computed': false,
                'target': {
                    'op': 'var',
                    'form': withMeta(symbol(void 0, 'exports'), meta(((form || 0)['id'] || 0)['form']))
                },
                'property': (form || 0)['id'],
                'form': ((form || 0)['id'] || 0)['form']
            },
            'value': (form || 0)['init'],
            'form': ((form || 0)['id'] || 0)['form']
        });
    };
var writeDef = exports.writeDef = function writeDef(form) {
        return conj({
            'type': 'VariableDeclaration',
            'kind': 'var',
            'declarations': [conj({
                    'type': 'VariableDeclarator',
                    'id': write((form || 0)['id']),
                    'init': conj((form || 0)['export'] ? writeExport(form) : write((form || 0)['init']))
                }, writeLocation(((form || 0)['id'] || 0)['form']))]
        }, writeLocation((form || 0)['form'], (form || 0)['original-form']));
    };
installWriter('def', writeDef);
var writeBinding = exports.writeBinding = function writeBinding(form) {
        return function () {
            var idø1 = writeBindingVar(form);
            var initø1 = write((form || 0)['init']);
            return {
                'type': 'VariableDeclaration',
                'kind': 'var',
                'loc': inheritLocation([
                    idø1,
                    initø1
                ]),
                'declarations': [{
                        'type': 'VariableDeclarator',
                        'id': idø1,
                        'init': initø1
                    }]
            };
        }.call(this);
    };
installWriter('binding', writeBinding);
var writeThrow = exports.writeThrow = function writeThrow(form) {
        return toExpression(conj({
            'type': 'ThrowStatement',
            'argument': write((form || 0)['throw'])
        }, writeLocation((form || 0)['form'], (form || 0)['original-form'])));
    };
installWriter('throw', writeThrow);
var writeNew = exports.writeNew = function writeNew(form) {
        return {
            'type': 'NewExpression',
            'callee': write((form || 0)['constructor']),
            'arguments': map(write, (form || 0)['params'])
        };
    };
installWriter('new', writeNew);
var writeSet = exports.writeSet = function writeSet(form) {
        return {
            'type': 'AssignmentExpression',
            'operator': '=',
            'left': write((form || 0)['target']),
            'right': write((form || 0)['value'])
        };
    };
installWriter('set!', writeSet);
var writeAget = exports.writeAget = function writeAget(form) {
        return {
            'type': 'MemberExpression',
            'computed': (form || 0)['computed'],
            'object': write((form || 0)['target']),
            'property': write((form || 0)['property'])
        };
    };
installWriter('member-expression', writeAget);
var __statements__ = exports.__statements__ = {
        'EmptyStatement': true,
        'BlockStatement': true,
        'ExpressionStatement': true,
        'IfStatement': true,
        'LabeledStatement': true,
        'BreakStatement': true,
        'ContinueStatement': true,
        'SwitchStatement': true,
        'ReturnStatement': true,
        'ThrowStatement': true,
        'TryStatement': true,
        'WhileStatement': true,
        'DoWhileStatement': true,
        'ForStatement': true,
        'ForInStatement': true,
        'ForOfStatement': true,
        'LetStatement': true,
        'VariableDeclaration': true,
        'FunctionDeclaration': true
    };
var writeStatement = exports.writeStatement = function writeStatement(form) {
        return toStatement(write(form));
    };
var toStatement = exports.toStatement = function toStatement(node) {
        return (__statements__ || 0)[(node || 0)['type']] ? node : {
            'type': 'ExpressionStatement',
            'expression': node,
            'loc': (node || 0)['loc']
        };
    };
var toReturn = exports.toReturn = function toReturn(form) {
        return conj({
            'type': 'ReturnStatement',
            'argument': write(form)
        }, writeLocation((form || 0)['form'], (form || 0)['original-form']));
    };
var writeBody = exports.writeBody = function writeBody(form) {
        return function () {
            var statementsø1 = map(writeStatement, (form || 0)['statements'] || []);
            var resultø1 = (form || 0)['result'] ? toReturn((form || 0)['result']) : void 0;
            return resultø1 ? conj(statementsø1, resultø1) : statementsø1;
        }.call(this);
    };
var toBlock = exports.toBlock = function toBlock(body) {
        return isVector(body) ? {
            'type': 'BlockStatement',
            'body': body,
            'loc': inheritLocation(body)
        } : {
            'type': 'BlockStatement',
            'body': [body],
            'loc': (body || 0)['loc']
        };
    };
var toExpression = exports.toExpression = function toExpression() {
        var body = Array.prototype.slice.call(arguments, 0);
        return {
            'type': 'CallExpression',
            'arguments': [],
            'loc': inheritLocation(body),
            'callee': toSequence([{
                    'type': 'FunctionExpression',
                    'id': void 0,
                    'params': [],
                    'defaults': [],
                    'expression': false,
                    'generator': false,
                    'rest': void 0,
                    'body': toBlock(body)
                }])
        };
    };
var writeDo = exports.writeDo = function writeDo(form) {
        return (meta(first((form || 0)['form'])) || 0)['block'] ? toBlock(writeBody(conj(form, {
            'result': void 0,
            'statements': conj((form || 0)['statements'], (form || 0)['result'])
        }))) : toExpression.apply(void 0, writeBody(form));
    };
installWriter('do', writeDo);
var writeIf = exports.writeIf = function writeIf(form) {
        return {
            'type': 'ConditionalExpression',
            'test': write((form || 0)['test']),
            'consequent': write((form || 0)['consequent']),
            'alternate': write((form || 0)['alternate'])
        };
    };
installWriter('if', writeIf);
var writeTry = exports.writeTry = function writeTry(form) {
        return function () {
            var handlerø1 = (form || 0)['handler'];
            var finalizerø1 = (form || 0)['finalizer'];
            return toExpression(conj({
                'type': 'TryStatement',
                'guardedHandlers': [],
                'block': toBlock(writeBody((form || 0)['body'])),
                'handlers': handlerø1 ? [{
                        'type': 'CatchClause',
                        'param': write((handlerø1 || 0)['name']),
                        'body': toBlock(writeBody(handlerø1))
                    }] : [],
                'finalizer': finalizerø1 ? toBlock(writeBody(finalizerø1)) : !handlerø1 ? toBlock([]) : 'else' ? void 0 : void 0
            }, writeLocation((form || 0)['form'], (form || 0)['original-form'])));
        }.call(this);
    };
installWriter('try', writeTry);
var writeBindingValue = function writeBindingValue(form) {
    return write((form || 0)['init']);
};
var writeBindingParam = function writeBindingParam(form) {
    return writeVar({ 'form': (form || 0)['name'] });
};
var writeBinding = exports.writeBinding = function writeBinding(form) {
        return write({
            'op': 'def',
            'var': form,
            'init': (form || 0)['init'],
            'form': form
        });
    };
var writeLet = exports.writeLet = function writeLet(form) {
        return function () {
            var bodyø1 = conj(form, { 'statements': vec(concat((form || 0)['bindings'], (form || 0)['statements'])) });
            return toIife(toBlock(writeBody(bodyø1)));
        }.call(this);
    };
installWriter('let', writeLet);
var toRebind = exports.toRebind = function toRebind(form) {
        return function loop() {
            var recur = loop;
            var resultø1 = [];
            var bindingsø1 = (form || 0)['bindings'];
            do {
                recur = isEmpty(bindingsø1) ? resultø1 : (loop[0] = conj(resultø1, {
                    'type': 'AssignmentExpression',
                    'operator': '=',
                    'left': writeBindingVar(first(bindingsø1)),
                    'right': {
                        'type': 'MemberExpression',
                        'computed': true,
                        'object': {
                            'type': 'Identifier',
                            'name': 'loop'
                        },
                        'property': {
                            'type': 'Literal',
                            'value': count(resultø1)
                        }
                    }
                }), loop[1] = rest(bindingsø1), loop);
            } while (resultø1 = loop[0], bindingsø1 = loop[1], recur === loop);
            return recur;
        }.call(this);
    };
var toSequence = exports.toSequence = function toSequence(expressions) {
        return {
            'type': 'SequenceExpression',
            'expressions': expressions
        };
    };
var toIife = exports.toIife = function toIife(body, id) {
        return {
            'type': 'CallExpression',
            'arguments': [{ 'type': 'ThisExpression' }],
            'callee': {
                'type': 'MemberExpression',
                'computed': false,
                'object': {
                    'type': 'FunctionExpression',
                    'id': id,
                    'params': [],
                    'defaults': [],
                    'expression': false,
                    'generator': false,
                    'rest': void 0,
                    'body': body
                },
                'property': {
                    'type': 'Identifier',
                    'name': 'call'
                }
            }
        };
    };
var toLoopInit = exports.toLoopInit = function toLoopInit() {
        return {
            'type': 'VariableDeclaration',
            'kind': 'var',
            'declarations': [{
                    'type': 'VariableDeclarator',
                    'id': {
                        'type': 'Identifier',
                        'name': 'recur'
                    },
                    'init': {
                        'type': 'Identifier',
                        'name': 'loop'
                    }
                }]
        };
    };
var toDoWhile = exports.toDoWhile = function toDoWhile(body, test) {
        return {
            'type': 'DoWhileStatement',
            'body': body,
            'test': test
        };
    };
var toSetRecur = exports.toSetRecur = function toSetRecur(form) {
        return {
            'type': 'AssignmentExpression',
            'operator': '=',
            'left': {
                'type': 'Identifier',
                'name': 'recur'
            },
            'right': write(form)
        };
    };
var toLoop = exports.toLoop = function toLoop(form) {
        return toSequence(conj(toRebind(form), {
            'type': 'BinaryExpression',
            'operator': '===',
            'left': {
                'type': 'Identifier',
                'name': 'recur'
            },
            'right': {
                'type': 'Identifier',
                'name': 'loop'
            }
        }));
    };
var writeLoop = exports.writeLoop = function writeLoop(form) {
        return function () {
            var statementsø1 = (form || 0)['statements'];
            var resultø1 = (form || 0)['result'];
            var bindingsø1 = (form || 0)['bindings'];
            var loopBodyø1 = conj(map(writeStatement, statementsø1), toStatement(toSetRecur(resultø1)));
            var bodyø1 = concat([toLoopInit()], map(write, bindingsø1), [toDoWhile(toBlock(vec(loopBodyø1)), toLoop(form))], [{
                        'type': 'ReturnStatement',
                        'argument': {
                            'type': 'Identifier',
                            'name': 'recur'
                        }
                    }]);
            return toIife(toBlock(vec(bodyø1)), symbol(void 0, 'loop'));
        }.call(this);
    };
installWriter('loop', writeLoop);
var toRecur = exports.toRecur = function toRecur(form) {
        return function loop() {
            var recur = loop;
            var resultø1 = [];
            var paramsø1 = (form || 0)['params'];
            do {
                recur = isEmpty(paramsø1) ? resultø1 : (loop[0] = conj(resultø1, {
                    'type': 'AssignmentExpression',
                    'operator': '=',
                    'right': write(first(paramsø1)),
                    'left': {
                        'type': 'MemberExpression',
                        'computed': true,
                        'object': {
                            'type': 'Identifier',
                            'name': 'loop'
                        },
                        'property': {
                            'type': 'Literal',
                            'value': count(resultø1)
                        }
                    }
                }), loop[1] = rest(paramsø1), loop);
            } while (resultø1 = loop[0], paramsø1 = loop[1], recur === loop);
            return recur;
        }.call(this);
    };
var writeRecur = exports.writeRecur = function writeRecur(form) {
        return toSequence(conj(toRecur(form), {
            'type': 'Identifier',
            'name': 'loop'
        }));
    };
installWriter('recur', writeRecur);
var fallbackOverload = exports.fallbackOverload = function fallbackOverload() {
        return {
            'type': 'SwitchCase',
            'test': void 0,
            'consequent': [{
                    'type': 'ThrowStatement',
                    'argument': {
                        'type': 'CallExpression',
                        'callee': {
                            'type': 'Identifier',
                            'name': 'RangeError'
                        },
                        'arguments': [{
                                'type': 'Literal',
                                'value': 'Wrong number of arguments passed'
                            }]
                    }
                }]
        };
    };
var spliceBinding = exports.spliceBinding = function spliceBinding(form) {
        return {
            'op': 'def',
            'id': last((form || 0)['params']),
            'init': {
                'op': 'invoke',
                'callee': {
                    'op': 'var',
                    'form': symbol(void 0, 'Array.prototype.slice.call')
                },
                'params': [
                    {
                        'op': 'var',
                        'form': symbol(void 0, 'arguments')
                    },
                    {
                        'op': 'constant',
                        'form': (form || 0)['arity'],
                        'type': 'number'
                    }
                ]
            }
        };
    };
var writeOverloadingParams = exports.writeOverloadingParams = function writeOverloadingParams(params) {
        return reduce(function (forms, param) {
            return conj(forms, {
                'op': 'def',
                'id': param,
                'init': {
                    'op': 'member-expression',
                    'computed': true,
                    'target': {
                        'op': 'var',
                        'form': symbol(void 0, 'arguments')
                    },
                    'property': {
                        'op': 'constant',
                        'type': 'number',
                        'form': count(forms)
                    }
                }
            });
        }, [], params);
    };
var writeOverloadingFn = exports.writeOverloadingFn = function writeOverloadingFn(form) {
        return function () {
            var overloadsø1 = map(writeFnOverload, (form || 0)['methods']);
            return {
                'params': [],
                'body': toBlock({
                    'type': 'SwitchStatement',
                    'discriminant': {
                        'type': 'MemberExpression',
                        'computed': false,
                        'object': {
                            'type': 'Identifier',
                            'name': 'arguments'
                        },
                        'property': {
                            'type': 'Identifier',
                            'name': 'length'
                        }
                    },
                    'cases': (form || 0)['variadic'] ? overloadsø1 : conj(overloadsø1, fallbackOverload())
                })
            };
        }.call(this);
    };
var writeFnOverload = exports.writeFnOverload = function writeFnOverload(form) {
        return function () {
            var paramsø1 = (form || 0)['params'];
            var bindingsø1 = (form || 0)['variadic'] ? conj(writeOverloadingParams(butlast(paramsø1)), spliceBinding(form)) : writeOverloadingParams(paramsø1);
            var statementsø1 = vec(concat(bindingsø1, (form || 0)['statements']));
            return {
                'type': 'SwitchCase',
                'test': !(form || 0)['variadic'] ? {
                    'type': 'Literal',
                    'value': (form || 0)['arity']
                } : void 0,
                'consequent': writeBody(conj(form, { 'statements': statementsø1 }))
            };
        }.call(this);
    };
var writeSimpleFn = exports.writeSimpleFn = function writeSimpleFn(form) {
        return function () {
            var methodø1 = first((form || 0)['methods']);
            var paramsø1 = (methodø1 || 0)['variadic'] ? butlast((methodø1 || 0)['params']) : (methodø1 || 0)['params'];
            var bodyø1 = (methodø1 || 0)['variadic'] ? conj(methodø1, { 'statements': vec(cons(spliceBinding(methodø1), (methodø1 || 0)['statements'])) }) : methodø1;
            return {
                'params': map(writeVar, paramsø1),
                'body': toBlock(writeBody(bodyø1))
            };
        }.call(this);
    };
var resolve = exports.resolve = function resolve(from, to) {
        return function () {
            var requirerø1 = split(name(from), '.');
            var requirementø1 = split(name(to), '.');
            var isRelativeø1 = !(name(from) === name(to)) && first(requirerø1) === first(requirementø1);
            return isRelativeø1 ? function loop() {
                var recur = loop;
                var fromø2 = requirerø1;
                var toø2 = requirementø1;
                do {
                    recur = first(fromø2) === first(toø2) ? (loop[0] = rest(fromø2), loop[1] = rest(toø2), loop) : join('/', concat(['.'], repeat(dec(count(fromø2)), '..'), toø2));
                } while (fromø2 = loop[0], toø2 = loop[1], recur === loop);
                return recur;
            }.call(this) : join('/', requirementø1);
        }.call(this);
    };
var idToNs = exports.idToNs = function idToNs(id) {
        return symbol(void 0, join('*', split(name(id), '.')));
    };
var writeRequire = exports.writeRequire = function writeRequire(form, requirer) {
        return function () {
            var nsBindingø1 = {
                    'op': 'def',
                    'id': {
                        'op': 'var',
                        'type': 'identifier',
                        'form': idToNs((form || 0)['ns'])
                    },
                    'init': {
                        'op': 'invoke',
                        'callee': {
                            'op': 'var',
                            'type': 'identifier',
                            'form': symbol(void 0, 'require')
                        },
                        'params': [{
                                'op': 'constant',
                                'form': resolve(requirer, (form || 0)['ns'])
                            }]
                    }
                };
            var nsAliasø1 = (form || 0)['alias'] ? {
                    'op': 'def',
                    'id': {
                        'op': 'var',
                        'type': 'identifier',
                        'form': idToNs((form || 0)['alias'])
                    },
                    'init': (nsBindingø1 || 0)['id']
                } : void 0;
            var referencesø1 = reduce(function (references, form) {
                    return conj(references, {
                        'op': 'def',
                        'id': {
                            'op': 'var',
                            'type': 'identifier',
                            'form': (form || 0)['rename'] || (form || 0)['name']
                        },
                        'init': {
                            'op': 'member-expression',
                            'computed': false,
                            'target': (nsBindingø1 || 0)['id'],
                            'property': {
                                'op': 'var',
                                'type': 'identifier',
                                'form': (form || 0)['name']
                            }
                        }
                    });
                }, [], (form || 0)['refer']);
            return vec(cons(nsBindingø1, nsAliasø1 ? cons(nsAliasø1, referencesø1) : referencesø1));
        }.call(this);
    };
var writeNs = exports.writeNs = function writeNs(form) {
        return function () {
            var nodeø1 = (form || 0)['form'];
            var requirerø1 = (form || 0)['name'];
            var nsBindingø1 = {
                    'op': 'def',
                    'original-form': nodeø1,
                    'id': {
                        'op': 'var',
                        'type': 'identifier',
                        'original-form': first(nodeø1),
                        'form': symbol(void 0, '*ns*')
                    },
                    'init': {
                        'op': 'dictionary',
                        'form': nodeø1,
                        'keys': [
                            {
                                'op': 'var',
                                'type': 'identifier',
                                'original-form': nodeø1,
                                'form': symbol(void 0, 'id')
                            },
                            {
                                'op': 'var',
                                'type': 'identifier',
                                'original-form': nodeø1,
                                'form': symbol(void 0, 'doc')
                            }
                        ],
                        'values': [
                            {
                                'op': 'constant',
                                'type': 'identifier',
                                'original-form': (form || 0)['name'],
                                'form': name((form || 0)['name'])
                            },
                            {
                                'op': 'constant',
                                'original-form': nodeø1,
                                'form': (form || 0)['doc']
                            }
                        ]
                    }
                };
            var requirementsø1 = vec(concat.apply(void 0, map(function ($1) {
                    return writeRequire($1, requirerø1);
                }, (form || 0)['require'])));
            return toBlock(map(write, vec(cons(nsBindingø1, requirementsø1))));
        }.call(this);
    };
installWriter('ns', writeNs);
var writeFn = exports.writeFn = function writeFn(form) {
        return function () {
            var baseø1 = count((form || 0)['methods']) > 1 ? writeOverloadingFn(form) : writeSimpleFn(form);
            return conj(baseø1, {
                'type': 'FunctionExpression',
                'id': (form || 0)['id'] ? writeVar((form || 0)['id']) : void 0,
                'defaults': void 0,
                'rest': void 0,
                'generator': false,
                'expression': false
            });
        }.call(this);
    };
installWriter('fn', writeFn);
var write = exports.write = function write(form) {
        return function () {
            var opø1 = (form || 0)['op'];
            var writerø1 = isEqual('invoke', (form || 0)['op']) && isEqual('var', ((form || 0)['callee'] || 0)['op']) && (__specials__ || 0)[name(((form || 0)['callee'] || 0)['form'])];
            return writerø1 ? writeSpecial(writerø1, form) : writeOp((form || 0)['op'], form);
        }.call(this);
    };
var write_ = exports.write_ = function write_() {
        var forms = Array.prototype.slice.call(arguments, 0);
        return function () {
            var bodyø1 = map(writeStatement, forms);
            return {
                'type': 'Program',
                'body': bodyø1,
                'loc': inheritLocation(bodyø1)
            };
        }.call(this);
    };
var compile = exports.compile = function compile() {
        switch (arguments.length) {
        case 1:
            var form = arguments[0];
            return compile({}, form);
        default:
            var options = arguments[0];
            var forms = Array.prototype.slice.call(arguments, 1);
            return generate(write_.apply(void 0, forms), options);
        }
    };
var getMacro = exports.getMacro = function getMacro(target, property) {
        return list.apply(void 0, [symbol(void 0, 'aget')].concat([list.apply(void 0, [symbol(void 0, 'or')].concat([target], [0]))], [property]));
    };
installMacro('get', getMacro);
var installLogicalOperator = exports.installLogicalOperator = function installLogicalOperator(callee, operator, fallback) {
        var writeLogicalOperator = function writeLogicalOperator() {
            var operands = Array.prototype.slice.call(arguments, 0);
            return function () {
                var nø1 = count(operands);
                return isEqual(nø1, 0) ? writeConstant(fallback) : isEqual(nø1, 1) ? write(first(operands)) : 'else' ? reduce(function (left, right) {
                    return {
                        'type': 'LogicalExpression',
                        'operator': operator,
                        'left': left,
                        'right': write(right)
                    };
                }, write(first(operands)), rest(operands)) : void 0;
            }.call(this);
        };
        return installSpecial(callee, writeLogicalOperator);
    };
installLogicalOperator('or', '||', void 0);
installLogicalOperator('and', '&&', true);
var installUnaryOperator = exports.installUnaryOperator = function installUnaryOperator(callee, operator, isPrefix) {
        var writeUnaryOperator = function writeUnaryOperator() {
            var params = Array.prototype.slice.call(arguments, 0);
            return count(params) === 1 ? {
                'type': 'UnaryExpression',
                'operator': operator,
                'argument': write(first(params)),
                'prefix': isPrefix
            } : errorArgCount(callee, count(params));
        };
        return installSpecial(callee, writeUnaryOperator);
    };
installUnaryOperator('not', '!');
installUnaryOperator('bit-not', '~');
var installBinaryOperator = exports.installBinaryOperator = function installBinaryOperator(callee, operator) {
        var writeBinaryOperator = function writeBinaryOperator() {
            var params = Array.prototype.slice.call(arguments, 0);
            return count(params) < 2 ? errorArgCount(callee, count(params)) : reduce(function (left, right) {
                return {
                    'type': 'BinaryExpression',
                    'operator': operator,
                    'left': left,
                    'right': write(right)
                };
            }, write(first(params)), rest(params));
        };
        return installSpecial(callee, writeBinaryOperator);
    };
installBinaryOperator('bit-and', '&');
installBinaryOperator('bit-or', '|');
installBinaryOperator('bit-xor', '^');
installBinaryOperator('bit-shift-left', '<<');
installBinaryOperator('bit-shift-right', '>>');
installBinaryOperator('bit-shift-right-zero-fil', '>>>');
var installArithmeticOperator = exports.installArithmeticOperator = function installArithmeticOperator(callee, operator, isValid, fallback) {
        var writeBinaryOperator = function writeBinaryOperator(left, right) {
            return {
                'type': 'BinaryExpression',
                'operator': name(operator),
                'left': left,
                'right': write(right)
            };
        };
        var writeArithmeticOperator = function writeArithmeticOperator() {
            var params = Array.prototype.slice.call(arguments, 0);
            return function () {
                var nø1 = count(params);
                return isValid && !isValid(nø1) ? errorArgCount(name(callee), nø1) : nø1 == 0 ? writeLiteral(fallback) : nø1 == 1 ? reduce(writeBinaryOperator, writeLiteral(fallback), params) : 'else' ? reduce(writeBinaryOperator, write(first(params)), rest(params)) : void 0;
            }.call(this);
        };
        return installSpecial(callee, writeArithmeticOperator);
    };
installArithmeticOperator('+', '+', void 0, 0);
installArithmeticOperator('-', '-', function ($1) {
    return $1 >= 1;
}, 0);
installArithmeticOperator('*', '*', void 0, 1);
installArithmeticOperator(keyword('/'), keyword('/'), function ($1) {
    return $1 >= 1;
}, 1);
installArithmeticOperator('mod', keyword('%'), function ($1) {
    return $1 == 2;
}, 1);
var installComparisonOperator = exports.installComparisonOperator = function installComparisonOperator(callee, operator, fallback) {
        var writeComparisonOperator = function writeComparisonOperator() {
            switch (arguments.length) {
            case 0:
                return errorArgCount(callee, 0);
            case 1:
                var form = arguments[0];
                return toSequence([
                    write(form),
                    writeLiteral(fallback)
                ]);
            case 2:
                var left = arguments[0];
                var right = arguments[1];
                return {
                    'type': 'BinaryExpression',
                    'operator': operator,
                    'left': write(left),
                    'right': write(right)
                };
            default:
                var left = arguments[0];
                var right = arguments[1];
                var more = Array.prototype.slice.call(arguments, 2);
                return reduce(function (left, right) {
                    return {
                        'type': 'LogicalExpression',
                        'operator': '&&',
                        'left': left,
                        'right': {
                            'type': 'BinaryExpression',
                            'operator': operator,
                            'left': isEqual('LogicalExpression', (left || 0)['type']) ? ((left || 0)['right'] || 0)['right'] : (left || 0)['right'],
                            'right': write(right)
                        }
                    };
                }, writeComparisonOperator(left, right), more);
            }
        };
        return installSpecial(callee, writeComparisonOperator);
    };
installComparisonOperator('==', '==', true);
installComparisonOperator('>', '>', true);
installComparisonOperator('>=', '>=', true);
installComparisonOperator('<', '<', true);
installComparisonOperator('<=', '<=', true);
var isWriteIdentical = exports.isWriteIdentical = function isWriteIdentical() {
        var params = Array.prototype.slice.call(arguments, 0);
        return count(params) === 2 ? {
            'type': 'BinaryExpression',
            'operator': '===',
            'left': write(first(params)),
            'right': write(second(params))
        } : errorArgCount('identical?', count(params));
    };
installSpecial('identical?', isWriteIdentical);
var isWriteInstance = exports.isWriteInstance = function isWriteInstance() {
        var params = Array.prototype.slice.call(arguments, 0);
        return function () {
            var constructorø1 = first(params);
            var instanceø1 = second(params);
            return count(params) < 1 ? errorArgCount('instance?', count(params)) : {
                'type': 'BinaryExpression',
                'operator': 'instanceof',
                'left': instanceø1 ? write(instanceø1) : writeConstant(instanceø1),
                'right': write(constructorø1)
            };
        }.call(this);
    };
installSpecial('instance?', isWriteInstance);
var expandApply = exports.expandApply = function expandApply(f) {
        var params = Array.prototype.slice.call(arguments, 1);
        return function () {
            var prefixø1 = vec(butlast(params));
            return isEmpty(prefixø1) ? list.apply(void 0, [symbol(void 0, '.apply')].concat([f], [void 0], vec(params))) : list.apply(void 0, [symbol(void 0, '.apply')].concat([f], [void 0], [list.apply(void 0, [symbol(void 0, '.concat')].concat([prefixø1], [last(params)]))]));
        }.call(this);
    };
installMacro('apply', expandApply);
var expandPrint = exports.expandPrint = function expandPrint(_andForm) {
        var more = Array.prototype.slice.call(arguments, 1);
        'Prints the object(s) to the output for human consumption.';
        return function () {
            var opø1 = withMeta(symbol(void 0, 'console.log'), meta(_andForm));
            return list.apply(void 0, [opø1].concat(vec(more)));
        }.call(this);
    };
installMacro('print', withMeta(expandPrint, { 'implicit': ['&form'] }));
var expandStr = exports.expandStr = function expandStr() {
        var forms = Array.prototype.slice.call(arguments, 0);
        return list.apply(void 0, [symbol(void 0, '+')].concat([''], vec(forms)));
    };
installMacro('str', expandStr);
var expandDebug = exports.expandDebug = function expandDebug() {
        return symbol(void 0, 'debugger');
    };
installMacro('debugger!', expandDebug);
var expandAssert = exports.expandAssert = function expandAssert() {
        switch (arguments.length) {
        case 1:
            var x = arguments[0];
            return expandAssert(x, '');
        case 2:
            var x = arguments[0];
            var message = arguments[1];
            return function () {
                var formø1 = prStr(x);
                return list.apply(void 0, [symbol(void 0, 'if')].concat([list.apply(void 0, [symbol(void 0, 'not')].concat([x]))], [list.apply(void 0, [symbol(void 0, 'throw')].concat([list.apply(void 0, [symbol(void 0, 'Error')].concat([list.apply(void 0, [symbol(void 0, 'str')].concat(['Assert failed: '], [message], [formø1]))]))]))]));
            }.call(this);
        default:
            throw RangeError('Wrong number of arguments passed');
        }
    };
installMacro('assert', expandAssert);
var expandDefprotocol = exports.expandDefprotocol = function expandDefprotocol(_andEnv, id) {
        var forms = Array.prototype.slice.call(arguments, 2);
        return function () {
            var nsø1 = name(((_andEnv || 0)['ns'] || 0)['name']);
            var protocolNameø1 = name(id);
            var protocolDocø1 = isString(first(forms)) ? first(forms) : void 0;
            var protocolMethodsø1 = protocolDocø1 ? rest(forms) : forms;
            var protocolø1 = reduce(function (protocol, method) {
                    return function () {
                        var methodNameø1 = first(method);
                        var idø2 = idToNs('' + nsø1 + '$' + protocolNameø1 + '$' + name(methodNameø1));
                        return conj(protocol, {
                            'id': methodNameø1,
                            'fn': list.apply(void 0, [symbol(void 0, 'fn')].concat([idø2], [[symbol(void 0, 'self')].concat()], [list.apply(void 0, [symbol(void 0, 'def')].concat([symbol(void 0, 'f')], [list.apply(void 0, [symbol(void 0, 'cond')].concat([list.apply(void 0, [symbol(void 0, 'identical?')].concat([symbol(void 0, 'self')], [symbol(void 0, 'null')]))], [list.apply(void 0, [symbol(void 0, '.-nil')].concat([idø2]))], [list.apply(void 0, [symbol(void 0, 'identical?')].concat([symbol(void 0, 'self')], [void 0]))], [list.apply(void 0, [symbol(void 0, '.-nil')].concat([idø2]))], ['\uA789else'], [list.apply(void 0, [symbol(void 0, 'or')].concat([list.apply(void 0, [symbol(void 0, 'aget')].concat([symbol(void 0, 'self')], [list.apply(void 0, [symbol(void 0, 'quote')].concat([idø2]))]))], [list.apply(void 0, [symbol(void 0, 'aget')].concat([idø2], [list.apply(void 0, [symbol(void 0, '.replace')].concat([list.apply(void 0, [symbol(void 0, '.replace')].concat([list.apply(void 0, [symbol(void 0, '.call')].concat([symbol(void 0, 'Object.prototype.toString')], [symbol(void 0, 'self')]))], ['[object '], ['']))], [/\]$/], ['']))]))], [list.apply(void 0, [symbol(void 0, '.-_')].concat([idø2]))]))]))]))], [list.apply(void 0, [symbol(void 0, '.apply')].concat([symbol(void 0, 'f')], [symbol(void 0, 'self')], [symbol(void 0, 'arguments')]))]))
                        });
                    }.call(this);
                }, [], protocolMethodsø1);
            var fnsø1 = map(function (form) {
                    return list.apply(void 0, [symbol(void 0, 'def')].concat([(form || 0)['id']], [list.apply(void 0, [symbol(void 0, 'aget')].concat([id], [list.apply(void 0, [symbol(void 0, 'quote')].concat([(form || 0)['id']]))]))]));
                }, protocolø1);
            var satisfyø1 = assoc({}, symbol(void 0, 'wisp_core$IProtocol$id'), '' + nsø1 + '/' + protocolNameø1);
            var bodyø1 = reduce(function (body, method) {
                    return assoc(body, (method || 0)['id'], (method || 0)['fn']);
                }, satisfyø1, protocolø1);
            return list.apply(void 0, [withMeta(symbol(void 0, 'do'), { 'block': true })].concat([list.apply(void 0, [symbol(void 0, 'def')].concat([id], [bodyø1]))], vec(fnsø1), [id]));
        }.call(this);
    };
installMacro('defprotocol', withMeta(expandDefprotocol, { 'implicit': ['&env'] }));
var expandDeftype = exports.expandDeftype = function expandDeftype(id, fields) {
        var forms = Array.prototype.slice.call(arguments, 2);
        return function () {
            var typeInitø1 = map(function (field) {
                    return list.apply(void 0, [symbol(void 0, 'set!')].concat([list.apply(void 0, [symbol(void 0, 'aget')].concat([symbol(void 0, 'this')], [list.apply(void 0, [symbol(void 0, 'quote')].concat([field]))]))], [field]));
                }, fields);
            var constructorø1 = conj(typeInitø1, symbol(void 0, 'this'));
            var methodInitø1 = map(function (field) {
                    return list.apply(void 0, [symbol(void 0, 'def')].concat([field], [list.apply(void 0, [symbol(void 0, 'aget')].concat([symbol(void 0, 'this')], [list.apply(void 0, [symbol(void 0, 'quote')].concat([field]))]))]));
                }, fields);
            var makeMethodø1 = function (protocol, form) {
                return function () {
                    var methodNameø1 = first(form);
                    var paramsø1 = second(form);
                    var bodyø1 = rest(rest(form));
                    var fieldNameø1 = isEqual(name(protocol), 'Object') ? list.apply(void 0, [symbol(void 0, 'quote')].concat([methodNameø1])) : list.apply(void 0, [symbol(void 0, '.-name')].concat([list.apply(void 0, [symbol(void 0, 'aget')].concat([protocol], [list.apply(void 0, [symbol(void 0, 'quote')].concat([methodNameø1]))]))]));
                    return list.apply(void 0, [symbol(void 0, 'set!')].concat([list.apply(void 0, [symbol(void 0, 'aget')].concat([list.apply(void 0, [symbol(void 0, '.-prototype')].concat([id]))], [fieldNameø1]))], [list.apply(void 0, [symbol(void 0, 'fn')].concat([paramsø1], vec(methodInitø1), vec(bodyø1)))]));
                }.call(this);
            };
            var satisfyø1 = function (protocol) {
                return list.apply(void 0, [symbol(void 0, 'set!')].concat([list.apply(void 0, [symbol(void 0, 'aget')].concat([list.apply(void 0, [symbol(void 0, '.-prototype')].concat([id]))], [list.apply(void 0, [symbol(void 0, '.-wisp_core$IProtocol$id')].concat([protocol]))]))], [true]));
            };
            var bodyø1 = reduce(function (type, form) {
                    return isList(form) ? conj(type, { 'body': conj((type || 0)['body'], makeMethodø1((type || 0)['protocol'], form)) }) : conj(type, {
                        'protocol': form,
                        'body': conj((type || 0)['body'], satisfyø1(form))
                    });
                }, {
                    'protocol': void 0,
                    'body': []
                }, forms);
            var methodsø1 = (bodyø1 || 0)['body'];
            return list.apply(void 0, [symbol(void 0, 'def')].concat([id], [list.apply(void 0, [symbol(void 0, 'do')].concat([list.apply(void 0, [symbol(void 0, 'defn-')].concat([id], [fields], vec(constructorø1)))], vec(methodsø1), [id]))]));
        }.call(this);
    };
installMacro('deftype', expandDeftype);
installMacro('defrecord', expandDeftype);
var expandExtendType = exports.expandExtendType = function expandExtendType(type) {
        var forms = Array.prototype.slice.call(arguments, 1);
        return function () {
            var isDefaultTypeø1 = isEqual(type, symbol(void 0, 'default'));
            var isNilTypeø1 = isNil(type);
            var typeNameø1 = isNil(type) ? symbol('nil') : isEqual(type, symbol(void 0, 'default')) ? symbol(void 0, '_') : isEqual(type, symbol(void 0, 'number')) ? symbol(void 0, 'Number') : isEqual(type, symbol(void 0, 'string')) ? symbol(void 0, 'String') : isEqual(type, symbol(void 0, 'boolean')) ? symbol(void 0, 'Boolean') : isEqual(type, symbol(void 0, 'vector')) ? symbol(void 0, 'Array') : isEqual(type, symbol(void 0, 'function')) ? symbol(void 0, 'Function') : isEqual(type, symbol(void 0, 're-pattern')) ? symbol(void 0, 'RegExp') : isEqual(namespace(type), 'js') ? type : 'else' ? void 0 : void 0;
            var satisfyø1 = function (protocol) {
                return typeNameø1 ? list.apply(void 0, [symbol(void 0, 'set!')].concat([list.apply(void 0, [symbol(void 0, 'aget')].concat([protocol], [list.apply(void 0, [symbol(void 0, 'quote')].concat([symbol('' + 'wisp_core$IProtocol$' + name(typeNameø1))]))]))], [true])) : list.apply(void 0, [symbol(void 0, 'set!')].concat([list.apply(void 0, [symbol(void 0, 'aget')].concat([list.apply(void 0, [symbol(void 0, '.-prototype')].concat([type]))], [list.apply(void 0, [symbol(void 0, '.-wisp_core$IProtocol$id')].concat([protocol]))]))], [true]));
            };
            var makeMethodø1 = function (protocol, form) {
                return function () {
                    var methodNameø1 = first(form);
                    var paramsø1 = second(form);
                    var bodyø1 = rest(rest(form));
                    var targetø1 = typeNameø1 ? list.apply(void 0, [symbol(void 0, 'aget')].concat([list.apply(void 0, [symbol(void 0, 'aget')].concat([protocol], [list.apply(void 0, [symbol(void 0, 'quote')].concat([methodNameø1]))]))], [list.apply(void 0, [symbol(void 0, 'quote')].concat([typeNameø1]))])) : list.apply(void 0, [symbol(void 0, 'aget')].concat([list.apply(void 0, [symbol(void 0, '.-prototype')].concat([type]))], [list.apply(void 0, [symbol(void 0, '.-name')].concat([list.apply(void 0, [symbol(void 0, 'aget')].concat([protocol], [list.apply(void 0, [symbol(void 0, 'quote')].concat([methodNameø1]))]))]))]));
                    return list.apply(void 0, [symbol(void 0, 'set!')].concat([targetø1], [list.apply(void 0, [symbol(void 0, 'fn')].concat([paramsø1], vec(bodyø1)))]));
                }.call(this);
            };
            var bodyø1 = reduce(function (body, form) {
                    return isList(form) ? conj(body, { 'methods': conj((body || 0)['methods'], makeMethodø1((body || 0)['protocol'], form)) }) : conj(body, {
                        'protocol': form,
                        'methods': conj((body || 0)['methods'], satisfyø1(form))
                    });
                }, {
                    'protocol': void 0,
                    'methods': []
                }, forms);
            var methodsø1 = (bodyø1 || 0)['methods'];
            return list.apply(void 0, [symbol(void 0, 'do')].concat(vec(methodsø1), [void 0]));
        }.call(this);
    };
installMacro('extend-type', expandExtendType);
var expandExtendProtocol = exports.expandExtendProtocol = function expandExtendProtocol(protocol) {
        var forms = Array.prototype.slice.call(arguments, 1);
        return function () {
            var specsø1 = reduce(function (specs, form) {
                    return isList(form) ? cons({
                        'type': (first(specs) || 0)['type'],
                        'methods': conj((first(specs) || 0)['methods'], form)
                    }, rest(specs)) : cons({
                        'type': form,
                        'methods': []
                    }, specs);
                }, void 0, forms);
            var bodyø1 = map(function (form) {
                    return list.apply(void 0, [symbol(void 0, 'extend-type')].concat([(form || 0)['type']], [protocol], vec((form || 0)['methods'])));
                }, specsø1);
            return list.apply(void 0, [symbol(void 0, 'do')].concat(vec(bodyø1), [void 0]));
        }.call(this);
    };
installMacro('extend-protocol', expandExtendProtocol);
var asetExpand = exports.asetExpand = function asetExpand() {
        switch (arguments.length) {
        case 3:
            var target = arguments[0];
            var field = arguments[1];
            var value = arguments[2];
            return list.apply(void 0, [symbol(void 0, 'set!')].concat([list.apply(void 0, [symbol(void 0, 'aget')].concat([target], [field]))], [value]));
        default:
            var target = arguments[0];
            var field = arguments[1];
            var subField = arguments[2];
            var subFieldsAndValue = Array.prototype.slice.call(arguments, 3);
            return function () {
                var resolvedTargetø1 = reduce(function (form, node) {
                        return list.apply(void 0, [symbol(void 0, 'aget')].concat([form], [node]));
                    }, list.apply(void 0, [symbol(void 0, 'aget')].concat([target], [field])), cons(subField, butlast(subFieldsAndValue)));
                var valueø1 = last(subFieldsAndValue);
                return list.apply(void 0, [symbol(void 0, 'set!')].concat([resolvedTargetø1], [valueø1]));
            }.call(this);
        }
    };
installMacro('aset', asetExpand);
var alengthExpand = exports.alengthExpand = function alengthExpand(array) {
        return list.apply(void 0, [symbol(void 0, '.-length')].concat([array]));
    };
installMacro('alength', alengthExpand);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFub255bW91cy53aXNwIl0sIm5hbWVzIjpbIl9uc18iLCJpZCIsImRvYyIsInJlYWRGcm9tU3RyaW5nIiwibWV0YSIsIndpdGhNZXRhIiwiaXNTeW1ib2wiLCJzeW1ib2wiLCJpc0tleXdvcmQiLCJrZXl3b3JkIiwibmFtZXNwYWNlIiwiaXNVbnF1b3RlIiwiaXNVbnF1b3RlU3BsaWNpbmciLCJpc1F1b3RlIiwiaXNTeW50YXhRdW90ZSIsIm5hbWUiLCJnZW5zeW0iLCJwclN0ciIsImlzRW1wdHkiLCJjb3VudCIsImlzTGlzdCIsImxpc3QiLCJmaXJzdCIsInNlY29uZCIsInRoaXJkIiwicmVzdCIsImNvbnMiLCJjb25qIiwiYnV0bGFzdCIsInJldmVyc2UiLCJyZWR1Y2UiLCJ2ZWMiLCJsYXN0IiwibWFwIiwiZmlsdGVyIiwidGFrZSIsImNvbmNhdCIsInBhcnRpdGlvbiIsInJlcGVhdCIsImludGVybGVhdmUiLCJhc3NvYyIsImlzT2RkIiwiaXNEaWN0aW9uYXJ5IiwiZGljdGlvbmFyeSIsIm1lcmdlIiwia2V5cyIsInZhbHMiLCJpc0NvbnRhaW5zVmVjdG9yIiwibWFwRGljdGlvbmFyeSIsImlzU3RyaW5nIiwiaXNOdW1iZXIiLCJpc1ZlY3RvciIsImlzQm9vbGVhbiIsInN1YnMiLCJyZUZpbmQiLCJpc1RydWUiLCJpc0ZhbHNlIiwiaXNOaWwiLCJpc1JlUGF0dGVybiIsImluYyIsImRlYyIsInN0ciIsImNoYXIiLCJpbnQiLCJpc0VxdWFsIiwiaXNTdHJpY3RFcXVhbCIsInNwbGl0Iiwiam9pbiIsInVwcGVyQ2FzZSIsInJlcGxhY2UiLCJ0cmltbCIsImluc3RhbGxNYWNybyIsImdlbmVyYXRlIiwiX191bmlxdWVDaGFyX18iLCJleHBvcnRzIiwidG9DYW1lbEpvaW4iLCJwcmVmaXgiLCJrZXkiLCJ0b1ByaXZhdGVQcmVmaXgiLCJzcGFjZURlbGltaXRlZMO4MSIsImxlZnRUcmltbWVkw7gxIiwibsO4MSIsInRyYW5zbGF0ZUlkZW50aWZpZXJXb3JkIiwiZm9ybSIsInRyYW5zbGF0ZUlkZW50aWZpZXIiLCJuc8O4MSIsImVycm9yQXJnQ291bnQiLCJjYWxsZWUiLCJuIiwiU3ludGF4RXJyb3IiLCJpbmhlcml0TG9jYXRpb24iLCJib2R5Iiwic3RhcnTDuDEiLCJlbmTDuDEiLCJ3cml0ZUxvY2F0aW9uIiwib3JpZ2luYWwiLCJkYXRhw7gxIiwiaW5oZXJpdGVkw7gxIiwiX193cml0ZXJzX18iLCJpbnN0YWxsV3JpdGVyIiwib3AiLCJ3cml0ZXIiLCJ3cml0ZU9wIiwid3JpdGVyw7gxIiwiX19zcGVjaWFsc19fIiwiaW5zdGFsbFNwZWNpYWwiLCJ3cml0ZVNwZWNpYWwiLCJ3cml0ZU5pbCIsIndyaXRlTGl0ZXJhbCIsIndyaXRlTGlzdCIsIndyaXRlIiwid3JpdGVTeW1ib2wiLCJ3cml0ZUNvbnN0YW50Iiwid3JpdGVOdW1iZXIiLCJ2YWx1ZU9mIiwid3JpdGVTdHJpbmciLCIkMSIsIndyaXRlS2V5d29yZCIsInRvSWRlbnRpZmllciIsIndyaXRlQmluZGluZ1ZhciIsImJhc2VJZMO4MSIsInJlc29sdmVkSWTDuDEiLCJ3cml0ZVZhciIsIm5vZGUiLCJ3cml0ZUludm9rZSIsIndyaXRlVmVjdG9yIiwid3JpdGVEaWN0aW9uYXJ5IiwicHJvcGVydGllc8O4MSIsInBhaXIiLCJrZXnDuDEiLCJ2YWx1ZcO4MSIsIndyaXRlRXhwb3J0Iiwid3JpdGVEZWYiLCJ3cml0ZUJpbmRpbmciLCJpZMO4MSIsImluaXTDuDEiLCJ3cml0ZVRocm93IiwidG9FeHByZXNzaW9uIiwid3JpdGVOZXciLCJ3cml0ZVNldCIsIndyaXRlQWdldCIsIl9fc3RhdGVtZW50c19fIiwid3JpdGVTdGF0ZW1lbnQiLCJ0b1N0YXRlbWVudCIsInRvUmV0dXJuIiwid3JpdGVCb2R5Iiwic3RhdGVtZW50c8O4MSIsInJlc3VsdMO4MSIsInRvQmxvY2siLCJ0b1NlcXVlbmNlIiwid3JpdGVEbyIsIndyaXRlSWYiLCJ3cml0ZVRyeSIsImhhbmRsZXLDuDEiLCJmaW5hbGl6ZXLDuDEiLCJ3cml0ZUJpbmRpbmdWYWx1ZSIsIndyaXRlQmluZGluZ1BhcmFtIiwid3JpdGVMZXQiLCJib2R5w7gxIiwidG9JaWZlIiwidG9SZWJpbmQiLCJiaW5kaW5nc8O4MSIsImV4cHJlc3Npb25zIiwidG9Mb29wSW5pdCIsInRvRG9XaGlsZSIsInRlc3QiLCJ0b1NldFJlY3VyIiwidG9Mb29wIiwid3JpdGVMb29wIiwibG9vcEJvZHnDuDEiLCJ0b1JlY3VyIiwicGFyYW1zw7gxIiwid3JpdGVSZWN1ciIsImZhbGxiYWNrT3ZlcmxvYWQiLCJzcGxpY2VCaW5kaW5nIiwid3JpdGVPdmVybG9hZGluZ1BhcmFtcyIsInBhcmFtcyIsImZvcm1zIiwicGFyYW0iLCJ3cml0ZU92ZXJsb2FkaW5nRm4iLCJvdmVybG9hZHPDuDEiLCJ3cml0ZUZuT3ZlcmxvYWQiLCJ3cml0ZVNpbXBsZUZuIiwibWV0aG9kw7gxIiwicmVzb2x2ZSIsImZyb20iLCJ0byIsInJlcXVpcmVyw7gxIiwicmVxdWlyZW1lbnTDuDEiLCJpc1JlbGF0aXZlw7gxIiwiZnJvbcO4MiIsInRvw7gyIiwiaWRUb05zIiwid3JpdGVSZXF1aXJlIiwicmVxdWlyZXIiLCJuc0JpbmRpbmfDuDEiLCJuc0FsaWFzw7gxIiwicmVmZXJlbmNlc8O4MSIsInJlZmVyZW5jZXMiLCJ3cml0ZU5zIiwibm9kZcO4MSIsInJlcXVpcmVtZW50c8O4MSIsIndyaXRlRm4iLCJiYXNlw7gxIiwib3DDuDEiLCJ3cml0ZV8iLCJjb21waWxlIiwib3B0aW9ucyIsImdldE1hY3JvIiwidGFyZ2V0IiwicHJvcGVydHkiLCJpbnN0YWxsTG9naWNhbE9wZXJhdG9yIiwib3BlcmF0b3IiLCJmYWxsYmFjayIsIndyaXRlTG9naWNhbE9wZXJhdG9yIiwib3BlcmFuZHMiLCJsZWZ0IiwicmlnaHQiLCJpbnN0YWxsVW5hcnlPcGVyYXRvciIsImlzUHJlZml4Iiwid3JpdGVVbmFyeU9wZXJhdG9yIiwiaW5zdGFsbEJpbmFyeU9wZXJhdG9yIiwid3JpdGVCaW5hcnlPcGVyYXRvciIsImluc3RhbGxBcml0aG1ldGljT3BlcmF0b3IiLCJpc1ZhbGlkIiwid3JpdGVBcml0aG1ldGljT3BlcmF0b3IiLCJpbnN0YWxsQ29tcGFyaXNvbk9wZXJhdG9yIiwid3JpdGVDb21wYXJpc29uT3BlcmF0b3IiLCJtb3JlIiwiaXNXcml0ZUlkZW50aWNhbCIsImlzV3JpdGVJbnN0YW5jZSIsImNvbnN0cnVjdG9yw7gxIiwiaW5zdGFuY2XDuDEiLCJleHBhbmRBcHBseSIsImYiLCJwcmVmaXjDuDEiLCJleHBhbmRQcmludCIsIl9hbmRGb3JtIiwiZXhwYW5kU3RyIiwiZXhwYW5kRGVidWciLCJleHBhbmRBc3NlcnQiLCJ4IiwibWVzc2FnZSIsImZvcm3DuDEiLCJleHBhbmREZWZwcm90b2NvbCIsIl9hbmRFbnYiLCJwcm90b2NvbE5hbWXDuDEiLCJwcm90b2NvbERvY8O4MSIsInByb3RvY29sTWV0aG9kc8O4MSIsInByb3RvY29sw7gxIiwicHJvdG9jb2wiLCJtZXRob2QiLCJtZXRob2ROYW1lw7gxIiwiaWTDuDIiLCJmbnPDuDEiLCJzYXRpc2Z5w7gxIiwiZXhwYW5kRGVmdHlwZSIsImZpZWxkcyIsInR5cGVJbml0w7gxIiwiZmllbGQiLCJtZXRob2RJbml0w7gxIiwibWFrZU1ldGhvZMO4MSIsImZpZWxkTmFtZcO4MSIsInR5cGUiLCJtZXRob2Rzw7gxIiwiZXhwYW5kRXh0ZW5kVHlwZSIsImlzRGVmYXVsdFR5cGXDuDEiLCJpc05pbFR5cGXDuDEiLCJ0eXBlTmFtZcO4MSIsInRhcmdldMO4MSIsImV4cGFuZEV4dGVuZFByb3RvY29sIiwic3BlY3PDuDEiLCJzcGVjcyIsImFzZXRFeHBhbmQiLCJ2YWx1ZSIsInN1YkZpZWxkIiwic3ViRmllbGRzQW5kVmFsdWUiLCJyZXNvbHZlZFRhcmdldMO4MSIsImFsZW5ndGhFeHBhbmQiLCJhcnJheSJdLCJtYXBwaW5ncyI6IjtJQUFBLElBQUNBLEksR0FBRDtBQUFBLFlBQUFDLEUsRUFBSSwrQkFBSjtBQUFBLFlBQUFDLEcsRUFBQSxLLENBQUE7QUFBQSxVOztRQUNpQ0MsY0FBQSxH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LEtBQUEsRztnQkFBTWdCLFFBQUEsRztnQkFBWUMsaUJBQUEsRztZQUMxQixPLFlBQU07QUFBQSxvQkFBQUMsZ0IsR0FBaUJ2UCxNQUFELENBQVEsVUFBS3FELElBQUwsRUFBVXdDLElBQVYsRUFDRTtBQUFBLCtCLFVBQUEsQyxNQUFBLEUsT0FBRSxDLE1BQUEsRSxNQUFBLEMsVUFBTXhDLEksSUFBTXdDLEksRUFBZDtBQUFBLHFCQURWLEUsVUFFUSxDLE1BQUEsRSxPQUFFLEMsTUFBQSxFLE1BQUEsQyxVQUFNc0YsTSxJQUFRa0QsSyxFQUFoQixDQUZSLEVBR1N6TyxJQUFELENBQU15UCxRQUFOLEVBQWlCdlAsT0FBRCxDQUFTd1AsaUJBQVQsQ0FBaEIsQ0FIUixDQUFoQjtBQUFBLGdCQUlBLElBQUFsSixPLEdBQU9sRyxJQUFELENBQU1vUCxpQkFBTixDQUFOLENBSkE7QUFBQSxnQkFLSixPLFVBQUEsQyxNQUFBLEUsT0FBRSxDLE1BQUEsRSxNQUFBLEMsVUFBTUMsZ0IsSUFBaUJuSixPLEVBQXpCLEVBTEk7QUFBQSxhLEtBQU4sQyxJQUFBLEU7O0tBSkgsQztBQVVDM0QsWUFBRCxDLE1BQUEsRUFBc0IwTSxVQUF0QixFO0FBRUEsSUFBTUssYUFBQSxHQUFBNU0sT0FBQSxDQUFBNE0sYUFBQSxHQUFOLFNBQU1BLGFBQU4sQ0FFR0MsS0FGSCxFQUdFO0FBQUEsZSxVQUFBLEMsTUFBQSxFLE9BQUUsQyxNQUFBLEUsVUFBQSxDLFVBQVVBLEssRUFBWjtBQUFBLEtBSEYsQztBQUlDaE4sWUFBRCxDLFNBQUEsRUFBeUIrTSxhQUF6QiIsInNvdXJjZXNDb250ZW50IjpbIihucyB3aXNwLmJhY2tlbmQuZXNjb2RlZ2VuLndyaXRlclxuICAoOnJlcXVpcmUgW3dpc3AucmVhZGVyIDpyZWZlciBbcmVhZC1mcm9tLXN0cmluZ11dXG4gICAgICAgICAgICBbd2lzcC5hc3QgOnJlZmVyIFttZXRhIHdpdGgtbWV0YSBzeW1ib2w/IHN5bWJvbCBrZXl3b3JkPyBrZXl3b3JkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lc3BhY2UgdW5xdW90ZT8gdW5xdW90ZS1zcGxpY2luZz8gcXVvdGU/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeW50YXgtcXVvdGU/IG5hbWUgZ2Vuc3ltIHByLXN0cl1dXG4gICAgICAgICAgICBbd2lzcC5zZXF1ZW5jZSA6cmVmZXIgW2VtcHR5PyBjb3VudCBsaXN0PyBsaXN0IGZpcnN0IHNlY29uZCB0aGlyZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN0IGNvbnMgY29uaiBidXRsYXN0IHJldmVyc2UgcmVkdWNlIHZlY1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0IG1hcCBmaWx0ZXIgdGFrZSBjb25jYXQgcGFydGl0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcGVhdCBpbnRlcmxlYXZlIGFzc29jXV1cbiAgICAgICAgICAgIFt3aXNwLnJ1bnRpbWUgOnJlZmVyIFtvZGQ/IGRpY3Rpb25hcnk/IGRpY3Rpb25hcnkgbWVyZ2Uga2V5cyB2YWxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbnMtdmVjdG9yPyBtYXAtZGljdGlvbmFyeSBzdHJpbmc/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyPyB2ZWN0b3I/IGJvb2xlYW4/IHN1YnMgcmUtZmluZCB0cnVlP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlPyBuaWw/IHJlLXBhdHRlcm4/IGluYyBkZWMgc3RyIGNoYXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnQgPSA9PV1dXG4gICAgICAgICAgICBbd2lzcC5zdHJpbmcgOnJlZmVyIFtzcGxpdCBqb2luIHVwcGVyLWNhc2UgcmVwbGFjZSB0cmltbF1dXG4gICAgICAgICAgICBbd2lzcC5leHBhbmRlciA6cmVmZXIgW2luc3RhbGwtbWFjcm8hXV1cbiAgICAgICAgICAgIFtlc2NvZGVnZW4gOnJlZmVyIFtnZW5lcmF0ZV1dKSlcblxuXG47OyBEZWZpbmUgY2hhcmFjdGVyIHRoYXQgaXMgdmFsaWQgSlMgaWRlbnRpZmllciB0aGF0IHdpbGxcbjs7IGJlIHVzZWQgaW4gZ2VuZXJhdGVkIHN5bWJvbHMgdG8gYXZvaWQgY29uZmxpY3RzXG47OyBodHRwOi8vd3d3LmZpbGVmb3JtYXQuaW5mby9pbmZvL3VuaWNvZGUvY2hhci9mOC9pbmRleC5odG1cbihkZWYgKip1bmlxdWUtY2hhcioqIFwiXFx1MDBGOFwiKVxuXG4oZGVmbiAtPmNhbWVsLWpvaW5cbiAgXCJUYWtlcyBkYXNoIGRlbGltaXRlZCBuYW1lIFwiXG4gIFtwcmVmaXgga2V5XVxuICAoc3RyIHByZWZpeFxuICAgICAgIChpZiAoYW5kIChub3QgKGVtcHR5PyBwcmVmaXgpKVxuICAgICAgICAgICAgICAgIChub3QgKGVtcHR5PyBrZXkpKSlcbiAgICAgICAgIChzdHIgKHVwcGVyLWNhc2UgKGdldCBrZXkgMCkpIChzdWJzIGtleSAxKSlcbiAgICAgICAgIGtleSkpKVxuXG4oZGVmbiAtPnByaXZhdGUtcHJlZml4XG4gIFwiVHJhbnNsYXRlIHByaXZhdGUgaWRlbnRpZmllcnMgbGlrZSAtZm9vIHRvIGEgSlMgZXF1aXZhbGVudFxuICBmb3JtcyBsaWtlIF9mb29cIlxuICBbaWRdXG4gIChsZXQgW3NwYWNlLWRlbGltaXRlZCAoam9pbiBcIiBcIiAoc3BsaXQgaWQgI1wiLVwiKSlcbiAgICAgICAgbGVmdC10cmltbWVkICh0cmltbCBzcGFjZS1kZWxpbWl0ZWQpXG4gICAgICAgIG4gKC0gKGNvdW50IGlkKSAoY291bnQgbGVmdC10cmltbWVkKSldXG4gICAgKGlmICg+IG4gMClcbiAgICAgIChzdHIgKGpvaW4gXCJfXCIgKHJlcGVhdCAoaW5jIG4pIFwiXCIpKSAoc3VicyBpZCBuKSlcbiAgICAgIGlkKSkpXG5cblxuKGRlZm4gdHJhbnNsYXRlLWlkZW50aWZpZXItd29yZFxuICBcIlRyYW5zbGF0ZXMgcmVmZXJlbmNlcyBmcm9tIGNsb2p1cmUgY29udmVudGlvbiB0byBKUzpcblxuICAqKm1hY3JvcyoqICAgICAgX19tYWNyb3NfX1xuICBsaXN0LT52ZWN0b3IgICAgbGlzdFRvVmVjdG9yXG4gIHNldCEgICAgICAgICAgICBzZXRcbiAgZm9vX2JhciAgICAgICAgIGZvb19iYXJcbiAgbnVtYmVyPyAgICAgICAgIGlzTnVtYmVyXG4gIHJlZD0gICAgICAgICAgICByZWRFcXVhbFxuICBjcmVhdGUtc2VydmVyICAgY3JlYXRlU2VydmVyXCJcbiAgW2Zvcm1dXG4gIChkZWYgXjpwcml2YXRlIGlkIChuYW1lIGZvcm0pKVxuICAoc2V0ISBpZCAoY29uZCAoaWRlbnRpY2FsPyBpZCAgXCIqXCIpIFwibXVsdGlwbHlcIlxuICAgICAgICAgICAgICAgICAoaWRlbnRpY2FsPyBpZCBcIi9cIikgXCJkaXZpZGVcIlxuICAgICAgICAgICAgICAgICAoaWRlbnRpY2FsPyBpZCBcIitcIikgXCJzdW1cIlxuICAgICAgICAgICAgICAgICAoaWRlbnRpY2FsPyBpZCBcIi1cIikgXCJzdWJ0cmFjdFwiXG4gICAgICAgICAgICAgICAgIChpZGVudGljYWw/IGlkIFwiPVwiKSBcImVxdWFsP1wiXG4gICAgICAgICAgICAgICAgIChpZGVudGljYWw/IGlkIFwiPT1cIikgXCJzdHJpY3QtZXF1YWw/XCJcbiAgICAgICAgICAgICAgICAgKGlkZW50aWNhbD8gaWQgXCI8PVwiKSBcIm5vdC1ncmVhdGVyLXRoYW5cIlxuICAgICAgICAgICAgICAgICAoaWRlbnRpY2FsPyBpZCBcIj49XCIpIFwibm90LWxlc3MtdGhhblwiXG4gICAgICAgICAgICAgICAgIChpZGVudGljYWw/IGlkIFwiPlwiKSBcImdyZWF0ZXItdGhhblwiXG4gICAgICAgICAgICAgICAgIChpZGVudGljYWw/IGlkIFwiPFwiKSBcImxlc3MtdGhhblwiXG4gICAgICAgICAgICAgICAgIChpZGVudGljYWw/IGlkIFwiLT5cIikgXCJ0aHJlYWQtZmlyc3RcIlxuICAgICAgICAgICAgICAgICA6ZWxzZSBpZCkpXG5cbiAgOzsgKiptYWNyb3MqKiAtPiAgX19tYWNyb3NfX1xuICAoc2V0ISBpZCAoam9pbiBcIl9cIiAoc3BsaXQgaWQgXCIqXCIpKSlcbiAgOzsgZm9vLmJhciAtPiBmb29fYmFyXG4gIChzZXQhIGlkIChqb2luIFwiX1wiIChzcGxpdCBpZCBcIi5cIikpKVxuICA7OyBsaXN0LT52ZWN0b3IgLT4gIGxpc3RUb1ZlY3RvclxuICAoc2V0ISBpZCAoaWYgKGlkZW50aWNhbD8gKHN1YnMgaWQgMCAyKSBcIi0+XCIpXG4gICAgICAgICAgICAgKHN1YnMgKGpvaW4gXCItdG8tXCIgKHNwbGl0IGlkIFwiLT5cIikpIDEpXG4gICAgICAgICAgICAgKGpvaW4gXCItdG8tXCIgKHNwbGl0IGlkIFwiLT5cIikpKSlcbiAgOzsgc2V0ISAtPiAgc2V0XG4gIChzZXQhIGlkIChqb2luIChzcGxpdCBpZCBcIiFcIikpKVxuICAoc2V0ISBpZCAoam9pbiBcIiRcIiAoc3BsaXQgaWQgXCIlXCIpKSlcbiAgKHNldCEgaWQgKGpvaW4gXCItZXF1YWwtXCIgKHNwbGl0IGlkIFwiPVwiKSkpXG4gIDs7IGZvbz0gLT4gZm9vRXF1YWxcbiAgOyhzZXQhIGlkIChqb2luIFwiLWVxdWFsLVwiIChzcGxpdCBpZCBcIj1cIikpXG4gIDs7IGZvbytiYXIgLT4gZm9vUGx1c0JhclxuICAoc2V0ISBpZCAoam9pbiBcIi1wbHVzLVwiIChzcGxpdCBpZCBcIitcIikpKVxuICAoc2V0ISBpZCAoam9pbiBcIi1hbmQtXCIgKHNwbGl0IGlkIFwiJlwiKSkpXG4gIDs7IG51bWJlcj8gLT4gaXNOdW1iZXJcbiAgKHNldCEgaWQgKGlmIChpZGVudGljYWw/IChsYXN0IGlkKSBcIj9cIilcbiAgICAgICAgICAgICAoc3RyIFwiaXMtXCIgKHN1YnMgaWQgMCAoZGVjIChjb3VudCBpZCkpKSlcbiAgICAgICAgICAgICBpZCkpXG4gIDs7IC1mb28gLT4gX2Zvb1xuICAoc2V0ISBpZCAoLT5wcml2YXRlLXByZWZpeCBpZCkpXG4gIDs7IGNyZWF0ZS1zZXJ2ZXIgLT4gY3JlYXRlU2VydmVyXG4gIChzZXQhIGlkIChyZWR1Y2UgLT5jYW1lbC1qb2luIFwiXCIgKHNwbGl0IGlkIFwiLVwiKSkpXG5cbiAgaWQpXG5cbihkZWZuIHRyYW5zbGF0ZS1pZGVudGlmaWVyXG4gIFtmb3JtXVxuICAobGV0IFtucyAobmFtZXNwYWNlIGZvcm0pXVxuICAgIChzdHIgKGlmIChhbmQgbnMgKG5vdCAoPSBucyBcImpzXCIpKSlcbiAgICAgICAgICAgKHN0ciAodHJhbnNsYXRlLWlkZW50aWZpZXItd29yZCAobmFtZXNwYWNlIGZvcm0pKSBcIi5cIilcbiAgICAgICAgICAgXCJcIilcbiAgICAgICAgIChqb2luIFxcLiAobWFwIHRyYW5zbGF0ZS1pZGVudGlmaWVyLXdvcmQgKHNwbGl0IChuYW1lIGZvcm0pIFxcLikpKSkpKVxuXG4oZGVmbiBlcnJvci1hcmctY291bnRcbiAgW2NhbGxlZSBuXVxuICAodGhyb3cgKFN5bnRheEVycm9yIChzdHIgXCJXcm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIChcIiBuIFwiKSBwYXNzZWQgdG86IFwiIGNhbGxlZSkpKSlcblxuKGRlZm4gaW5oZXJpdC1sb2NhdGlvblxuICBbYm9keV1cbiAgKGxldCBbc3RhcnQgKDpzdGFydCAoOmxvYyAoZmlyc3QgYm9keSkpKVxuICAgICAgICBlbmQgKDplbmQgKDpsb2MgKGxhc3QgYm9keSkpKV1cbiAgICAoaWYgKG5vdCAob3IgKG5pbD8gc3RhcnQpIChuaWw/IGVuZCkpKVxuICAgICAgezpzdGFydCBzdGFydCA6ZW5kIGVuZH0pKSlcblxuXG4oZGVmbiB3cml0ZS1sb2NhdGlvblxuICBbZm9ybSBvcmlnaW5hbF1cbiAgKGxldCBbZGF0YSAobWV0YSBmb3JtKVxuICAgICAgICBpbmhlcml0ZWQgKG1ldGEgb3JpZ2luYWwpXG4gICAgICAgIHN0YXJ0IChvciAoOnN0YXJ0IGZvcm0pICg6c3RhcnQgZGF0YSkgKDpzdGFydCBpbmhlcml0ZWQpKVxuICAgICAgICBlbmQgKG9yICg6ZW5kIGZvcm0pICg6ZW5kIGRhdGEpICg6ZW5kIGluaGVyaXRlZCkpXVxuICAgIChpZiAobm90IChuaWw/IHN0YXJ0KSlcbiAgICAgIHs6bG9jIHs6c3RhcnQgezpsaW5lIChpbmMgKDpsaW5lIHN0YXJ0IC0xKSlcbiAgICAgICAgICAgICAgICAgICAgIDpjb2x1bW4gKDpjb2x1bW4gc3RhcnQgLTEpfVxuICAgICAgICAgICAgIDplbmQgezpsaW5lIChpbmMgKDpsaW5lIGVuZCAtMSkpXG4gICAgICAgICAgICAgICAgICAgOmNvbHVtbiAoOmNvbHVtbiBlbmQgLTEpfX19XG4gICAgICB7fSkpKVxuXG4oZGVmICoqd3JpdGVycyoqIHt9KVxuKGRlZm4gaW5zdGFsbC13cml0ZXIhXG4gIFtvcCB3cml0ZXJdXG4gIChzZXQhIChnZXQgKip3cml0ZXJzKiogb3ApIHdyaXRlcikpXG5cbihkZWZuIHdyaXRlLW9wXG4gIFtvcCBmb3JtXVxuICAobGV0IFt3cml0ZXIgKGdldCAqKndyaXRlcnMqKiBvcCldXG4gICAgKGFzc2VydCB3cml0ZXIgKHN0ciBcIlVuc3VwcG9ydGVkIG9wZXJhdGlvbjogXCIgb3ApKVxuICAgIChjb25qICh3cml0ZS1sb2NhdGlvbiAoOmZvcm0gZm9ybSkgKDpvcmlnaW5hbC1mb3JtIGZvcm0pKVxuICAgICAgICAgICh3cml0ZXIgZm9ybSkpKSlcblxuKGRlZiAqKnNwZWNpYWxzKioge30pXG4oZGVmbiBpbnN0YWxsLXNwZWNpYWwhXG4gIFtvcCB3cml0ZXJdXG4gIChzZXQhIChnZXQgKipzcGVjaWFscyoqIChuYW1lIG9wKSkgd3JpdGVyKSlcblxuKGRlZm4gd3JpdGUtc3BlY2lhbFxuICBbd3JpdGVyIGZvcm1dXG4gIChjb25qICh3cml0ZS1sb2NhdGlvbiAoOmZvcm0gZm9ybSkgKDpvcmlnaW5hbC1mb3JtIGZvcm0pKVxuICAgICAgICAoYXBwbHkgd3JpdGVyICg6cGFyYW1zIGZvcm0pKSkpXG5cblxuKGRlZm4gd3JpdGUtbmlsXG4gIFtmb3JtXVxuICB7OnR5cGUgOlVuYXJ5RXhwcmVzc2lvblxuICAgOm9wZXJhdG9yIDp2b2lkXG4gICA6YXJndW1lbnQgezp0eXBlIDpMaXRlcmFsXG4gICAgICAgICAgICAgIDp2YWx1ZSAwfVxuICAgOnByZWZpeCB0cnVlfSlcbihpbnN0YWxsLXdyaXRlciEgOm5pbCB3cml0ZS1uaWwpXG5cbihkZWZuIHdyaXRlLWxpdGVyYWxcbiAgW2Zvcm1dXG4gIHs6dHlwZSA6TGl0ZXJhbFxuICAgOnZhbHVlIGZvcm19KVxuXG4oZGVmbiB3cml0ZS1saXN0XG4gIFtmb3JtXVxuICB7OnR5cGUgOkNhbGxFeHByZXNzaW9uXG4gICA6Y2FsbGVlICh3cml0ZSB7Om9wIDp2YXJcbiAgICAgICAgICAgICAgICAgICA6Zm9ybSAnbGlzdH0pXG4gICA6YXJndW1lbnRzIChtYXAgd3JpdGUgKDppdGVtcyBmb3JtKSl9KVxuKGluc3RhbGwtd3JpdGVyISA6bGlzdCB3cml0ZS1saXN0KVxuXG4oZGVmbiB3cml0ZS1zeW1ib2xcbiAgW2Zvcm1dXG4gIHs6dHlwZSA6Q2FsbEV4cHJlc3Npb25cbiAgIDpjYWxsZWUgKHdyaXRlIHs6b3AgOnZhclxuICAgICAgICAgICAgICAgICAgIDpmb3JtICdzeW1ib2x9KVxuICAgOmFyZ3VtZW50cyBbKHdyaXRlLWNvbnN0YW50ICg6bmFtZXNwYWNlIGZvcm0pKVxuICAgICAgICAgICAgICAgKHdyaXRlLWNvbnN0YW50ICg6bmFtZSBmb3JtKSldfSlcbihpbnN0YWxsLXdyaXRlciEgOnN5bWJvbCB3cml0ZS1zeW1ib2wpXG5cbihkZWZuIHdyaXRlLWNvbnN0YW50XG4gIFtmb3JtXVxuICAoY29uZCAobmlsPyBmb3JtKSAod3JpdGUtbmlsIGZvcm0pXG4gICAgICAgIChrZXl3b3JkPyBmb3JtKSAod3JpdGUtbGl0ZXJhbCAoaWYgKG5hbWVzcGFjZSBmb3JtKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc3RyIChuYW1lc3BhY2UgZm9ybSkgXCIvXCIgKG5hbWUgZm9ybSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChuYW1lIGZvcm0pKSlcbiAgICAgICAgKG51bWJlcj8gZm9ybSkgKHdyaXRlLW51bWJlciAoLnZhbHVlT2YgZm9ybSkpXG4gICAgICAgIChzdHJpbmc/IGZvcm0pICh3cml0ZS1zdHJpbmcgZm9ybSlcbiAgICAgICAgOmVsc2UgKHdyaXRlLWxpdGVyYWwgZm9ybSkpKVxuKGluc3RhbGwtd3JpdGVyISA6Y29uc3RhbnQgIyh3cml0ZS1jb25zdGFudCAoOmZvcm0gJSkpKVxuXG4oZGVmbiB3cml0ZS1zdHJpbmdcbiAgW2Zvcm1dXG4gIHs6dHlwZSA6TGl0ZXJhbFxuICAgOnZhbHVlIChzdHIgZm9ybSl9KVxuXG4oZGVmbiB3cml0ZS1udW1iZXJcbiAgW2Zvcm1dXG4gIChpZiAoPCBmb3JtIDApXG4gICAgezp0eXBlIDpVbmFyeUV4cHJlc3Npb25cbiAgICAgOm9wZXJhdG9yIDotXG4gICAgIDpwcmVmaXggdHJ1ZVxuICAgICA6YXJndW1lbnQgKHdyaXRlLW51bWJlciAoKiBmb3JtIC0xKSl9XG4gICAgKHdyaXRlLWxpdGVyYWwgZm9ybSkpKVxuXG4oZGVmbiB3cml0ZS1rZXl3b3JkXG4gIFtmb3JtXVxuICB7OnR5cGUgOkxpdGVyYWxcbiAgIDp2YWx1ZSAoOmZvcm0gZm9ybSl9KVxuKGluc3RhbGwtd3JpdGVyISA6a2V5d29yZCB3cml0ZS1rZXl3b3JkKVxuXG4oZGVmbiAtPmlkZW50aWZpZXJcbiAgW2Zvcm1dXG4gIHs6dHlwZSA6SWRlbnRpZmllclxuICAgOm5hbWUgKHRyYW5zbGF0ZS1pZGVudGlmaWVyIGZvcm0pfSlcblxuKGRlZm4gd3JpdGUtYmluZGluZy12YXJcbiAgW2Zvcm1dXG4gIDs7IElmIGlkZW50aWZpZXJzIGJpbmRpbmcgc2hhZG93cyBvdGhlciBiaW5kaW5nIHJlbmFtZSBpdCBhY2NvcmRpbmdcbiAgOzsgdG8gc2hhZG93aW5nIGRlcHRoLiBUaGlzIGFsbG93cyBiaW5kaW5ncyBpbml0aWFsaXplciBzYWZlbHlcbiAgOzsgYWNjZXNzIGJpbmRpbmcgYmVmb3JlIHNoYWRvd2luZyBpdC5cbiAgKGxldCBbYmFzZS1pZCAoOmlkIGZvcm0pXG4gICAgICAgIHJlc29sdmVkLWlkIChpZiAoOnNoYWRvdyBmb3JtKVxuICAgICAgICAgICAgICAgICAgICAgIChzeW1ib2wgbmlsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc3RyICh0cmFuc2xhdGUtaWRlbnRpZmllciBiYXNlLWlkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqKnVuaXF1ZS1jaGFyKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKDpkZXB0aCBmb3JtKSkpXG4gICAgICAgICAgICAgYmFzZS1pZCldXG4gICAgKGNvbmogKC0+aWRlbnRpZmllciByZXNvbHZlZC1pZClcbiAgICAgICAgICAod3JpdGUtbG9jYXRpb24gYmFzZS1pZCkpKSlcblxuKGRlZm4gd3JpdGUtdmFyXG4gIFwiaGFuZGxlciBmb3IgezpvcCA6dmFyfSB0eXBlIGZvcm1zLiBTdWNoIGZvcm1zIG1heVxuICByZXByZXNlbnQgcmVmZXJlbmNlcyBpbiB3aGljaCBjYXNlIHRoZXkgaGF2ZSA6aW5mb1xuICBwb2ludGluZyB0byBhIGRlY2xhcmF0aW9uIDp2YXIgd2hpY2ggd2F5IGJlIGVpdGhlclxuICBmdW5jdGlvbiBwYXJhbWV0ZXIgKGhhcyA6cGFyYW0gdHJ1ZSkgb3IgbG9jYWxcbiAgYmluZGluZyBkZWNsYXJhdGlvbiAoaGFzIDpiaW5kaW5nIHRydWUpIGxpa2Ugb25lcyBkZWZpbmVkXG4gIGJ5IGxldCBhbmQgbG9vcCBmb3JtcyBpbiBsYXRlciBjYXNlIGZvcm0gd2lsbCBhbHNvIGhhdmVcbiAgOnNoYWRvdyBwb2ludGluZyB0byBhIGRlY2xhcmF0aW9uIG5vZGUgaXQgc2hhZG93cyBhbmRcbiAgOmRlcHRoIHByb3BlcnR5IHdpdGggYSBkZXB0aCBvZiBzaGFkb3dpbmcsIHRoYXQgaXMgdXNlZFxuICB0byBmb3IgcmVuYW1pbmcgbG9naWMgdG8gYXZvaWQgbmFtZSBjb2xsaXNpb25zIGluIGZvcm1zXG4gIGxpa2UgbGV0IHRoYXQgYWxsb3cgc2FtZSBuYW1lZCBiaW5kaW5ncy5cIlxuICBbbm9kZV1cbiAgKGlmICg9IDpiaW5kaW5nICg6dHlwZSAoOmJpbmRpbmcgbm9kZSkpKVxuICAgIChjb25qICh3cml0ZS1iaW5kaW5nLXZhciAoOmJpbmRpbmcgbm9kZSkpXG4gICAgICAgICAgKHdyaXRlLWxvY2F0aW9uICg6Zm9ybSBub2RlKSkpXG4gICAgKGNvbmogKHdyaXRlLWxvY2F0aW9uICg6Zm9ybSBub2RlKSlcbiAgICAgICAgICAoLT5pZGVudGlmaWVyICg6Zm9ybSBub2RlKSkpKSlcbihpbnN0YWxsLXdyaXRlciEgOnZhciB3cml0ZS12YXIpXG4oaW5zdGFsbC13cml0ZXIhIDpwYXJhbSB3cml0ZS12YXIpXG5cbihkZWZuIHdyaXRlLWludm9rZVxuICBbZm9ybV1cbiAgezp0eXBlIDpDYWxsRXhwcmVzc2lvblxuICAgOmNhbGxlZSAod3JpdGUgKDpjYWxsZWUgZm9ybSkpXG4gICA6YXJndW1lbnRzIChtYXAgd3JpdGUgKDpwYXJhbXMgZm9ybSkpfSlcbihpbnN0YWxsLXdyaXRlciEgOmludm9rZSB3cml0ZS1pbnZva2UpXG5cbihkZWZuIHdyaXRlLXZlY3RvclxuICBbZm9ybV1cbiAgezp0eXBlIDpBcnJheUV4cHJlc3Npb25cbiAgIDplbGVtZW50cyAobWFwIHdyaXRlICg6aXRlbXMgZm9ybSkpfSlcbihpbnN0YWxsLXdyaXRlciEgOnZlY3RvciB3cml0ZS12ZWN0b3IpXG5cbihkZWZuIHdyaXRlLWRpY3Rpb25hcnlcbiAgW2Zvcm1dXG4gIChsZXQgW3Byb3BlcnRpZXMgKHBhcnRpdGlvbiAyIChpbnRlcmxlYXZlICg6a2V5cyBmb3JtKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoOnZhbHVlcyBmb3JtKSkpXVxuICAgIHs6dHlwZSA6T2JqZWN0RXhwcmVzc2lvblxuICAgICA6cHJvcGVydGllcyAobWFwIChmbiBbcGFpcl1cbiAgICAgICAgICAgICAgICAgICAgICAgIChsZXQgW2tleSAoZmlyc3QgcGFpcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIChzZWNvbmQgcGFpcildXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHs6a2luZCA6aW5pdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgOnR5cGUgOlByb3BlcnR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICA6a2V5IChpZiAoPSA6c3ltYm9sICg6b3Aga2V5KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAod3JpdGUtY29uc3RhbnQgKHN0ciAoOmZvcm0ga2V5KSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHdyaXRlIGtleSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICA6dmFsdWUgKHdyaXRlIHZhbHVlKX0pKVxuICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMpfSkpXG4oaW5zdGFsbC13cml0ZXIhIDpkaWN0aW9uYXJ5IHdyaXRlLWRpY3Rpb25hcnkpXG5cbihkZWZuIHdyaXRlLWV4cG9ydFxuICBbZm9ybV1cbiAgKHdyaXRlIHs6b3AgOnNldCFcbiAgICAgICAgICA6dGFyZ2V0IHs6b3AgOm1lbWJlci1leHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgOmNvbXB1dGVkIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgOnRhcmdldCB7Om9wIDp2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Zm9ybSAod2l0aC1tZXRhICdleHBvcnRzIChtZXRhICg6Zm9ybSAoOmlkIGZvcm0pKSkpfVxuICAgICAgICAgICAgICAgICAgIDpwcm9wZXJ0eSAoOmlkIGZvcm0pXG4gICAgICAgICAgICAgICAgICAgOmZvcm0gKDpmb3JtICg6aWQgZm9ybSkpfVxuICAgICAgICAgIDp2YWx1ZSAoOmluaXQgZm9ybSlcbiAgICAgICAgICA6Zm9ybSAoOmZvcm0gKDppZCBmb3JtKSl9KSlcblxuKGRlZm4gd3JpdGUtZGVmXG4gIFtmb3JtXVxuICAoY29uaiB7OnR5cGUgOlZhcmlhYmxlRGVjbGFyYXRpb25cbiAgICAgICAgIDpraW5kIDp2YXJcbiAgICAgICAgIDpkZWNsYXJhdGlvbnMgWyhjb25qIHs6dHlwZSA6VmFyaWFibGVEZWNsYXJhdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOmlkICh3cml0ZSAoOmlkIGZvcm0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDppbml0IChjb25qIChpZiAoOmV4cG9ydCBmb3JtKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHdyaXRlLWV4cG9ydCBmb3JtKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHdyaXRlICg6aW5pdCBmb3JtKSkpKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh3cml0ZS1sb2NhdGlvbiAoOmZvcm0gKDppZCBmb3JtKSkpKV19XG4gICAgICAgICh3cml0ZS1sb2NhdGlvbiAoOmZvcm0gZm9ybSkgKDpvcmlnaW5hbC1mb3JtIGZvcm0pKSkpXG4oaW5zdGFsbC13cml0ZXIhIDpkZWYgd3JpdGUtZGVmKVxuXG4oZGVmbiB3cml0ZS1iaW5kaW5nXG4gIFtmb3JtXVxuICAobGV0IFtpZCAod3JpdGUtYmluZGluZy12YXIgZm9ybSlcbiAgICAgICAgaW5pdCAod3JpdGUgKDppbml0IGZvcm0pKV1cbiAgICB7OnR5cGUgOlZhcmlhYmxlRGVjbGFyYXRpb25cbiAgICAgOmtpbmQgOnZhclxuICAgICA6bG9jIChpbmhlcml0LWxvY2F0aW9uIFtpZCBpbml0XSlcbiAgICAgOmRlY2xhcmF0aW9ucyBbezp0eXBlIDpWYXJpYWJsZURlY2xhcmF0b3JcbiAgICAgICAgICAgICAgICAgICAgIDppZCBpZFxuICAgICAgICAgICAgICAgICAgICAgOmluaXQgaW5pdH1dfSkpXG4oaW5zdGFsbC13cml0ZXIhIDpiaW5kaW5nIHdyaXRlLWJpbmRpbmcpXG5cbihkZWZuIHdyaXRlLXRocm93XG4gIFtmb3JtXVxuICAoLT5leHByZXNzaW9uIChjb25qIHs6dHlwZSA6VGhyb3dTdGF0ZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgOmFyZ3VtZW50ICh3cml0ZSAoOnRocm93IGZvcm0pKX1cbiAgICAgICAgICAgICAgICAgICAgICAod3JpdGUtbG9jYXRpb24gKDpmb3JtIGZvcm0pICg6b3JpZ2luYWwtZm9ybSBmb3JtKSkpKSlcbihpbnN0YWxsLXdyaXRlciEgOnRocm93IHdyaXRlLXRocm93KVxuXG4oZGVmbiB3cml0ZS1uZXdcbiAgW2Zvcm1dXG4gIHs6dHlwZSA6TmV3RXhwcmVzc2lvblxuICAgOmNhbGxlZSAod3JpdGUgKDpjb25zdHJ1Y3RvciBmb3JtKSlcbiAgIDphcmd1bWVudHMgKG1hcCB3cml0ZSAoOnBhcmFtcyBmb3JtKSl9KVxuKGluc3RhbGwtd3JpdGVyISA6bmV3IHdyaXRlLW5ldylcblxuKGRlZm4gd3JpdGUtc2V0IVxuICBbZm9ybV1cbiAgezp0eXBlIDpBc3NpZ25tZW50RXhwcmVzc2lvblxuICAgOm9wZXJhdG9yIDo9XG4gICA6bGVmdCAod3JpdGUgKDp0YXJnZXQgZm9ybSkpXG4gICA6cmlnaHQgKHdyaXRlICg6dmFsdWUgZm9ybSkpfSlcbihpbnN0YWxsLXdyaXRlciEgOnNldCEgd3JpdGUtc2V0ISlcblxuKGRlZm4gd3JpdGUtYWdldFxuICBbZm9ybV1cbiAgezp0eXBlIDpNZW1iZXJFeHByZXNzaW9uXG4gICA6Y29tcHV0ZWQgKDpjb21wdXRlZCBmb3JtKVxuICAgOm9iamVjdCAod3JpdGUgKDp0YXJnZXQgZm9ybSkpXG4gICA6cHJvcGVydHkgKHdyaXRlICg6cHJvcGVydHkgZm9ybSkpfSlcbihpbnN0YWxsLXdyaXRlciEgOm1lbWJlci1leHByZXNzaW9uIHdyaXRlLWFnZXQpXG5cbjs7IE1hcCBvZiBzdGF0ZW1lbnQgQVNUIG5vZGUgdGhhdCBhcmUgZ2VuZXJhdGVkXG47OyBieSBhIHdyaXRlci4gVXNlZCB0byBkZWNldCB3ZWF0aGVyIG5vZGUgaXNcbjs7IHN0YXRlbWVudCBvciBleHByZXNzaW9uLlxuKGRlZiAqKnN0YXRlbWVudHMqKiB7OkVtcHR5U3RhdGVtZW50IHRydWUgOkJsb2NrU3RhdGVtZW50IHRydWVcbiAgICAgICAgICAgICAgICAgICAgIDpFeHByZXNzaW9uU3RhdGVtZW50IHRydWUgOklmU3RhdGVtZW50IHRydWVcbiAgICAgICAgICAgICAgICAgICAgIDpMYWJlbGVkU3RhdGVtZW50IHRydWUgOkJyZWFrU3RhdGVtZW50IHRydWVcbiAgICAgICAgICAgICAgICAgICAgIDpDb250aW51ZVN0YXRlbWVudCB0cnVlIDpTd2l0Y2hTdGF0ZW1lbnQgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgOlJldHVyblN0YXRlbWVudCB0cnVlIDpUaHJvd1N0YXRlbWVudCB0cnVlXG4gICAgICAgICAgICAgICAgICAgICA6VHJ5U3RhdGVtZW50IHRydWUgOldoaWxlU3RhdGVtZW50IHRydWVcbiAgICAgICAgICAgICAgICAgICAgIDpEb1doaWxlU3RhdGVtZW50IHRydWUgOkZvclN0YXRlbWVudCB0cnVlXG4gICAgICAgICAgICAgICAgICAgICA6Rm9ySW5TdGF0ZW1lbnQgdHJ1ZSA6Rm9yT2ZTdGF0ZW1lbnQgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgOkxldFN0YXRlbWVudCB0cnVlIDpWYXJpYWJsZURlY2xhcmF0aW9uIHRydWVcbiAgICAgICAgICAgICAgICAgICAgIDpGdW5jdGlvbkRlY2xhcmF0aW9uIHRydWV9KVxuXG4oZGVmbiB3cml0ZS1zdGF0ZW1lbnRcbiAgXCJXcmFwcyBleHByZXNzaW9uIHRoYXQgY2FuJ3QgYmUgaW4gYSBibG9jayBzdGF0ZW1lbnRcbiAgYm9keSBpbnRvIDpFeHByZXNzaW9uU3RhdGVtZW50IG90aGVyd2lzZSByZXR1cm5zIGJhY2tcbiAgZXhwcmVzc2lvbi5cIlxuICBbZm9ybV1cbiAgKC0+c3RhdGVtZW50ICh3cml0ZSBmb3JtKSkpXG5cbihkZWZuIC0+c3RhdGVtZW50XG4gIFtub2RlXVxuICAoaWYgKGdldCAqKnN0YXRlbWVudHMqKiAoOnR5cGUgbm9kZSkpXG4gICAgbm9kZVxuICAgIHs6dHlwZSA6RXhwcmVzc2lvblN0YXRlbWVudFxuICAgICA6ZXhwcmVzc2lvbiBub2RlXG4gICAgIDpsb2MgKDpsb2Mgbm9kZSlcbiAgICAgfSkpXG5cbihkZWZuIC0+cmV0dXJuXG4gIFtmb3JtXVxuICAoY29uaiB7OnR5cGUgOlJldHVyblN0YXRlbWVudFxuICAgICAgICAgOmFyZ3VtZW50ICh3cml0ZSBmb3JtKX1cbiAgICAgICAgKHdyaXRlLWxvY2F0aW9uICg6Zm9ybSBmb3JtKSAoOm9yaWdpbmFsLWZvcm0gZm9ybSkpKSlcblxuKGRlZm4gd3JpdGUtYm9keVxuICBcIlRha2VzIGZvcm0gdGhhdCBtYXkgY29udGFpbiBgOnN0YXRlbWVudHNgIHZlY3RvclxuICBvciBgOnJlc3VsdGAgZm9ybSAgYW5kIHJldHVybnMgdmVjdG9yIGV4cHJlc3Npb25cbiAgbm9kZXMgdGhhdCBjYW4gYmUgdXNlZCBpbiBhbnkgYmxvY2suIElmIGA6cmVzdWx0YFxuICBpcyBwcmVzZW50IGl0IHdpbGwgYmUgYSBsYXN0IGluIHZlY3RvciBhbmQgb2YgYVxuICBgOlJldHVyblN0YXRlbWVudGAgdHlwZS5cbiAgRXhhbXBsZXM6XG5cblxuICAod3JpdGUtYm9keSB7OnN0YXRlbWVudHMgbmlsXG4gICAgICAgICAgICAgICA6cmVzdWx0IHs6b3AgOmNvbnN0YW50XG4gICAgICAgICAgICAgICAgICAgICAgICA6dHlwZSA6bnVtYmVyXG4gICAgICAgICAgICAgICAgICAgICAgICA6Zm9ybSAzfX0pXG4gIDs7ID0+XG4gIFt7OnR5cGUgOlJldHVyblN0YXRlbWVudFxuICAgIDphcmd1bWVudCB7OnR5cGUgOkxpdGVyYWwgOnZhbHVlIDN9fV1cblxuICAod3JpdGUtYm9keSB7OnN0YXRlbWVudHMgW3s6b3AgOnNldCFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOnRhcmdldCB7Om9wIDp2YXIgOmZvcm0gJ3h9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDp2YWx1ZSB7Om9wIDp2YXIgOmZvcm0gJ3l9fV1cbiAgICAgICAgICAgICAgIDpyZXN1bHQgezpvcCA6dmFyIDpmb3JtICd4fX0pXG4gIDs7ID0+XG4gIFt7OnR5cGUgOkV4cHJlc3Npb25TdGF0ZW1lbnRcbiAgICA6ZXhwcmVzc2lvbiB7OnR5cGUgOkFzc2lnbm1lbnRFeHByZXNzaW9uXG4gICAgICAgICAgICAgICAgIDpvcGVyYXRvciA6PVxuICAgICAgICAgICAgICAgICA6bGVmdCB7OnR5cGUgOklkZW50aWZpZXIgOm5hbWUgOnh9XG4gICAgICAgICAgICAgICAgIDpyaWdodCB7OnR5cGUgOklkZW50aWZpZXIgOm5hbWUgOnl9fX1cbiAgIHs6dHlwZSA6UmV0dXJuU3RhdGVtZW50XG4gICAgOmFyZ3VtZW50IHs6dHlwZSA6SWRlbnRpZmllciA6bmFtZSA6eH19XVwiXG4gIFtmb3JtXVxuICAobGV0IFtzdGF0ZW1lbnRzIChtYXAgd3JpdGUtc3RhdGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAob3IgKDpzdGF0ZW1lbnRzIGZvcm0pIFtdKSlcbiAgICAgICAgcmVzdWx0IChpZiAoOnJlc3VsdCBmb3JtKVxuICAgICAgICAgICAgICAgICAoLT5yZXR1cm4gKDpyZXN1bHQgZm9ybSkpKV1cblxuICAgIChpZiByZXN1bHRcbiAgICAgIChjb25qIHN0YXRlbWVudHMgcmVzdWx0KVxuICAgICAgc3RhdGVtZW50cykpKVxuXG4oZGVmbiAtPmJsb2NrXG4gIFtib2R5XVxuICAoaWYgKHZlY3Rvcj8gYm9keSlcbiAgICB7OnR5cGUgOkJsb2NrU3RhdGVtZW50XG4gICAgIDpib2R5IGJvZHlcbiAgICAgOmxvYyAoaW5oZXJpdC1sb2NhdGlvbiBib2R5KX1cbiAgICB7OnR5cGUgOkJsb2NrU3RhdGVtZW50XG4gICAgIDpib2R5IFtib2R5XVxuICAgICA6bG9jICg6bG9jIGJvZHkpfSkpXG5cbihkZWZuIC0+ZXhwcmVzc2lvblxuICBbJiBib2R5XVxuICB7OnR5cGUgOkNhbGxFeHByZXNzaW9uXG4gICA6YXJndW1lbnRzIFtdXG4gICA6bG9jIChpbmhlcml0LWxvY2F0aW9uIGJvZHkpXG4gICA6Y2FsbGVlICgtPnNlcXVlbmNlIFt7OnR5cGUgOkZ1bmN0aW9uRXhwcmVzc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgIDppZCBuaWxcbiAgICAgICAgICAgICAgICAgICAgICAgICA6cGFyYW1zIFtdXG4gICAgICAgICAgICAgICAgICAgICAgICAgOmRlZmF1bHRzIFtdXG4gICAgICAgICAgICAgICAgICAgICAgICAgOmV4cHJlc3Npb24gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICA6Z2VuZXJhdG9yIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgOnJlc3QgbmlsXG4gICAgICAgICAgICAgICAgICAgICAgICAgOmJvZHkgKC0+YmxvY2sgYm9keSl9XSl9KVxuXG4oZGVmbiB3cml0ZS1kb1xuICBbZm9ybV1cbiAgKGlmICg6YmxvY2sgKG1ldGEgKGZpcnN0ICg6Zm9ybSBmb3JtKSkpKVxuICAgICgtPmJsb2NrICh3cml0ZS1ib2R5IChjb25qIGZvcm0gezpyZXN1bHQgbmlsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOnN0YXRlbWVudHMgKGNvbmogKDpzdGF0ZW1lbnRzIGZvcm0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKDpyZXN1bHQgZm9ybSkpfSkpKVxuICAgIChhcHBseSAtPmV4cHJlc3Npb24gKHdyaXRlLWJvZHkgZm9ybSkpKSlcbihpbnN0YWxsLXdyaXRlciEgOmRvIHdyaXRlLWRvKVxuXG4oZGVmbiB3cml0ZS1pZlxuICBbZm9ybV1cbiAgezp0eXBlIDpDb25kaXRpb25hbEV4cHJlc3Npb25cbiAgIDp0ZXN0ICh3cml0ZSAoOnRlc3QgZm9ybSkpXG4gICA6Y29uc2VxdWVudCAod3JpdGUgKDpjb25zZXF1ZW50IGZvcm0pKVxuICAgOmFsdGVybmF0ZSAod3JpdGUgKDphbHRlcm5hdGUgZm9ybSkpfSlcbihpbnN0YWxsLXdyaXRlciEgOmlmIHdyaXRlLWlmKVxuXG4oZGVmbiB3cml0ZS10cnlcbiAgW2Zvcm1dXG4gIChsZXQgW2hhbmRsZXIgKDpoYW5kbGVyIGZvcm0pXG4gICAgICAgIGZpbmFsaXplciAoOmZpbmFsaXplciBmb3JtKV1cbiAgICAoLT5leHByZXNzaW9uIChjb25qIHs6dHlwZSA6VHJ5U3RhdGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgOmd1YXJkZWRIYW5kbGVycyBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgIDpibG9jayAoLT5ibG9jayAod3JpdGUtYm9keSAoOmJvZHkgZm9ybSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgIDpoYW5kbGVycyAoaWYgaGFuZGxlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt7OnR5cGUgOkNhdGNoQ2xhdXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6cGFyYW0gKHdyaXRlICg6bmFtZSBoYW5kbGVyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpib2R5ICgtPmJsb2NrICh3cml0ZS1ib2R5IGhhbmRsZXIpKX1dXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW10pXG4gICAgICAgICAgICAgICAgICAgICAgICAgOmZpbmFsaXplciAoY29uZCBmaW5hbGl6ZXIgKC0+YmxvY2sgKHdyaXRlLWJvZHkgZmluYWxpemVyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChub3QgaGFuZGxlcikgKC0+YmxvY2sgW10pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ZWxzZSBuaWwpfVxuICAgICAgICAgICAgICAgICAgICAgICAgKHdyaXRlLWxvY2F0aW9uICg6Zm9ybSBmb3JtKSAoOm9yaWdpbmFsLWZvcm0gZm9ybSkpKSkpKVxuKGluc3RhbGwtd3JpdGVyISA6dHJ5IHdyaXRlLXRyeSlcblxuKGRlZm4tIHdyaXRlLWJpbmRpbmctdmFsdWVcbiAgW2Zvcm1dXG4gICh3cml0ZSAoOmluaXQgZm9ybSkpKVxuXG4oZGVmbi0gd3JpdGUtYmluZGluZy1wYXJhbVxuICBbZm9ybV1cbiAgKHdyaXRlLXZhciB7OmZvcm0gKDpuYW1lIGZvcm0pfSkpXG5cbihkZWZuIHdyaXRlLWJpbmRpbmdcbiAgW2Zvcm1dXG4gICh3cml0ZSB7Om9wIDpkZWZcbiAgICAgICAgICA6dmFyIGZvcm1cbiAgICAgICAgICA6aW5pdCAoOmluaXQgZm9ybSlcbiAgICAgICAgICA6Zm9ybSBmb3JtfSkpXG5cbihkZWZuIHdyaXRlLWxldFxuICBbZm9ybV1cbiAgKGxldCBbYm9keSAoY29uaiBmb3JtXG4gICAgICAgICAgICAgICAgICAgezpzdGF0ZW1lbnRzICh2ZWMgKGNvbmNhdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoOmJpbmRpbmdzIGZvcm0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICg6c3RhdGVtZW50cyBmb3JtKSkpfSldXG4gICAgKC0+aWlmZSAoLT5ibG9jayAod3JpdGUtYm9keSBib2R5KSkpKSlcbihpbnN0YWxsLXdyaXRlciEgOmxldCB3cml0ZS1sZXQpXG5cbihkZWZuIC0+cmViaW5kXG4gIFtmb3JtXVxuICAobG9vcCBbcmVzdWx0IFtdXG4gICAgICAgICBiaW5kaW5ncyAoOmJpbmRpbmdzIGZvcm0pXVxuICAgIChpZiAoZW1wdHk/IGJpbmRpbmdzKVxuICAgICAgcmVzdWx0XG4gICAgICAocmVjdXIgKGNvbmogcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgezp0eXBlIDpBc3NpZ25tZW50RXhwcmVzc2lvblxuICAgICAgICAgICAgICAgICAgICA6b3BlcmF0b3IgOj1cbiAgICAgICAgICAgICAgICAgICAgOmxlZnQgKHdyaXRlLWJpbmRpbmctdmFyIChmaXJzdCBiaW5kaW5ncykpXG4gICAgICAgICAgICAgICAgICAgIDpyaWdodCB7OnR5cGUgOk1lbWJlckV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Y29tcHV0ZWQgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpvYmplY3Qgezp0eXBlIDpJZGVudGlmaWVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOm5hbWUgOmxvb3B9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOnByb3BlcnR5IHs6dHlwZSA6TGl0ZXJhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOnZhbHVlIChjb3VudCByZXN1bHQpfX19KVxuICAgICAgICAgICAgIChyZXN0IGJpbmRpbmdzKSkpKSlcblxuKGRlZm4gLT5zZXF1ZW5jZVxuICBbZXhwcmVzc2lvbnNdXG4gIHs6dHlwZSA6U2VxdWVuY2VFeHByZXNzaW9uXG4gICA6ZXhwcmVzc2lvbnMgZXhwcmVzc2lvbnN9KVxuXG4oZGVmbiAtPmlpZmVcbiAgW2JvZHkgaWRdXG4gIHs6dHlwZSA6Q2FsbEV4cHJlc3Npb25cbiAgIDphcmd1bWVudHMgW3s6dHlwZSA6VGhpc0V4cHJlc3Npb259XVxuICAgOmNhbGxlZSB7OnR5cGUgOk1lbWJlckV4cHJlc3Npb25cbiAgICAgICAgICAgIDpjb21wdXRlZCBmYWxzZVxuICAgICAgICAgICAgOm9iamVjdCB7OnR5cGUgOkZ1bmN0aW9uRXhwcmVzc2lvblxuICAgICAgICAgICAgICAgICAgICAgOmlkIGlkXG4gICAgICAgICAgICAgICAgICAgICA6cGFyYW1zIFtdXG4gICAgICAgICAgICAgICAgICAgICA6ZGVmYXVsdHMgW11cbiAgICAgICAgICAgICAgICAgICAgIDpleHByZXNzaW9uIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICA6Z2VuZXJhdG9yIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICA6cmVzdCBuaWxcbiAgICAgICAgICAgICAgICAgICAgIDpib2R5IGJvZHl9XG4gICAgICAgICAgICA6cHJvcGVydHkgezp0eXBlIDpJZGVudGlmaWVyXG4gICAgICAgICAgICAgICAgICAgICAgIDpuYW1lIDpjYWxsfX19KVxuXG4oZGVmbiAtPmxvb3AtaW5pdFxuICBbXVxuICB7OnR5cGUgOlZhcmlhYmxlRGVjbGFyYXRpb25cbiAgIDpraW5kIDp2YXJcbiAgIDpkZWNsYXJhdGlvbnMgW3s6dHlwZSA6VmFyaWFibGVEZWNsYXJhdG9yXG4gICAgICAgICAgICAgICAgICAgOmlkIHs6dHlwZSA6SWRlbnRpZmllclxuICAgICAgICAgICAgICAgICAgICAgICAgOm5hbWUgOnJlY3VyfVxuICAgICAgICAgICAgICAgICAgIDppbml0IHs6dHlwZSA6SWRlbnRpZmllclxuICAgICAgICAgICAgICAgICAgICAgICAgICA6bmFtZSA6bG9vcH19XX0pXG5cbihkZWZuIC0+ZG8td2hpbGVcbiBbYm9keSB0ZXN0XVxuIHs6dHlwZSA6RG9XaGlsZVN0YXRlbWVudFxuICA6Ym9keSBib2R5XG4gIDp0ZXN0IHRlc3R9KVxuXG4oZGVmbiAtPnNldCEtcmVjdXJcbiAgW2Zvcm1dXG4gIHs6dHlwZSA6QXNzaWdubWVudEV4cHJlc3Npb25cbiAgIDpvcGVyYXRvciA6PVxuICAgOmxlZnQgezp0eXBlIDpJZGVudGlmaWVyIDpuYW1lIDpyZWN1cn1cbiAgIDpyaWdodCAod3JpdGUgZm9ybSl9KVxuXG4oZGVmbiAtPmxvb3BcbiAgW2Zvcm1dXG4gICgtPnNlcXVlbmNlIChjb25qICgtPnJlYmluZCBmb3JtKVxuICAgICAgICAgICAgICAgICAgICB7OnR5cGUgOkJpbmFyeUV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgIDpvcGVyYXRvciA6PT09XG4gICAgICAgICAgICAgICAgICAgICA6bGVmdCB7OnR5cGUgOklkZW50aWZpZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6bmFtZSA6cmVjdXJ9XG4gICAgICAgICAgICAgICAgICAgICA6cmlnaHQgezp0eXBlIDpJZGVudGlmaWVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpuYW1lIDpsb29wfX0pKSlcblxuXG4oZGVmbiB3cml0ZS1sb29wXG4gIFtmb3JtXVxuICAobGV0IFtzdGF0ZW1lbnRzICg6c3RhdGVtZW50cyBmb3JtKVxuICAgICAgICByZXN1bHQgKDpyZXN1bHQgZm9ybSlcbiAgICAgICAgYmluZGluZ3MgKDpiaW5kaW5ncyBmb3JtKVxuXG4gICAgICAgIGxvb3AtYm9keSAoY29uaiAobWFwIHdyaXRlLXN0YXRlbWVudCBzdGF0ZW1lbnRzKVxuICAgICAgICAgICAgICAgICAgICAgICAgKC0+c3RhdGVtZW50ICgtPnNldCEtcmVjdXIgcmVzdWx0KSkpXG4gICAgICAgIGJvZHkgKGNvbmNhdCBbKFxuICAgICAgICAgICAgICAgICAgICAgICAtPmxvb3AtaW5pdCldXG4gICAgICAgICAgICAgICAgICAgICAobWFwIHdyaXRlIGJpbmRpbmdzKVxuICAgICAgICAgICAgICAgICAgICAgWygtPmRvLXdoaWxlICgtPmJsb2NrICh2ZWMgbG9vcC1ib2R5KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoLT5sb29wIGZvcm0pKV1cbiAgICAgICAgICAgICAgICAgICAgIFt7OnR5cGUgOlJldHVyblN0YXRlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICA6YXJndW1lbnQgezp0eXBlIDpJZGVudGlmaWVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOm5hbWUgOnJlY3VyfX1dKV1cbiAgICAoLT5paWZlICgtPmJsb2NrICh2ZWMgYm9keSkpICdsb29wKSkpXG4oaW5zdGFsbC13cml0ZXIhIDpsb29wIHdyaXRlLWxvb3ApXG5cbihkZWZuIC0+cmVjdXJcbiAgW2Zvcm1dXG4gIChsb29wIFtyZXN1bHQgW11cbiAgICAgICAgIHBhcmFtcyAoOnBhcmFtcyBmb3JtKV1cbiAgICAoaWYgKGVtcHR5PyBwYXJhbXMpXG4gICAgICByZXN1bHRcbiAgICAgIChyZWN1ciAoY29uaiByZXN1bHRcbiAgICAgICAgICAgICAgICAgICB7OnR5cGUgOkFzc2lnbm1lbnRFeHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgIDpvcGVyYXRvciA6PVxuICAgICAgICAgICAgICAgICAgICA6cmlnaHQgKHdyaXRlIChmaXJzdCBwYXJhbXMpKVxuICAgICAgICAgICAgICAgICAgICA6bGVmdCB7OnR5cGUgOk1lbWJlckV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIDpjb21wdXRlZCB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICA6b2JqZWN0IHs6dHlwZSA6SWRlbnRpZmllclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOm5hbWUgOmxvb3B9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICA6cHJvcGVydHkgezp0eXBlIDpMaXRlcmFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDp2YWx1ZSAoY291bnQgcmVzdWx0KX19fSlcbiAgICAgICAgICAgICAocmVzdCBwYXJhbXMpKSkpKVxuXG4oZGVmbiB3cml0ZS1yZWN1clxuICBbZm9ybV1cbiAgKC0+c2VxdWVuY2UgKGNvbmogKC0+cmVjdXIgZm9ybSlcbiAgICAgICAgICAgICAgICAgICAgezp0eXBlIDpJZGVudGlmaWVyXG4gICAgICAgICAgICAgICAgICAgICA6bmFtZSA6bG9vcH0pKSlcbihpbnN0YWxsLXdyaXRlciEgOnJlY3VyIHdyaXRlLXJlY3VyKVxuXG4oZGVmbiBmYWxsYmFjay1vdmVybG9hZFxuICBbXVxuICB7OnR5cGUgOlN3aXRjaENhc2VcbiAgIDp0ZXN0IG5pbFxuICAgOmNvbnNlcXVlbnQgW3s6dHlwZSA6VGhyb3dTdGF0ZW1lbnRcbiAgICAgICAgICAgICAgICAgOmFyZ3VtZW50IHs6dHlwZSA6Q2FsbEV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Y2FsbGVlIHs6dHlwZSA6SWRlbnRpZmllclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpuYW1lIDpSYW5nZUVycm9yfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDphcmd1bWVudHMgW3s6dHlwZSA6TGl0ZXJhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6dmFsdWUgXCJXcm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIHBhc3NlZFwifV19fV19KVxuXG4oZGVmbiBzcGxpY2UtYmluZGluZ1xuICBbZm9ybV1cbiAgezpvcCA6ZGVmXG4gICA6aWQgKGxhc3QgKDpwYXJhbXMgZm9ybSkpXG4gICA6aW5pdCB7Om9wIDppbnZva2VcbiAgICAgICAgICA6Y2FsbGVlIHs6b3AgOnZhclxuICAgICAgICAgICAgICAgICAgIDpmb3JtICdBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbH1cbiAgICAgICAgICA6cGFyYW1zIFt7Om9wIDp2YXJcbiAgICAgICAgICAgICAgICAgICAgOmZvcm0gJ2FyZ3VtZW50c31cbiAgICAgICAgICAgICAgICAgICB7Om9wIDpjb25zdGFudFxuICAgICAgICAgICAgICAgICAgICA6Zm9ybSAoOmFyaXR5IGZvcm0pXG4gICAgICAgICAgICAgICAgICAgIDp0eXBlIDpudW1iZXJ9XX19KVxuXG4oZGVmbiB3cml0ZS1vdmVybG9hZGluZy1wYXJhbXNcbiAgW3BhcmFtc11cbiAgKHJlZHVjZSAoZm4gW2Zvcm1zIHBhcmFtXVxuICAgICAgICAgICAgKGNvbmogZm9ybXMgezpvcCA6ZGVmXG4gICAgICAgICAgICAgICAgICAgICAgICAgOmlkIHBhcmFtXG4gICAgICAgICAgICAgICAgICAgICAgICAgOmluaXQgezpvcCA6bWVtYmVyLWV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOmNvbXB1dGVkIHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOnRhcmdldCB7Om9wIDp2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOmZvcm0gJ2FyZ3VtZW50c31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOnByb3BlcnR5IHs6b3AgOmNvbnN0YW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOnR5cGUgOm51bWJlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpmb3JtIChjb3VudCBmb3Jtcyl9fX0pKVxuICAgICAgICAgIFtdXG4gICAgICAgICAgcGFyYW1zKSlcblxuKGRlZm4gd3JpdGUtb3ZlcmxvYWRpbmctZm5cbiAgW2Zvcm1dXG4gIChsZXQgW292ZXJsb2FkcyAobWFwIHdyaXRlLWZuLW92ZXJsb2FkICg6bWV0aG9kcyBmb3JtKSldXG4gICAgezpwYXJhbXMgW11cbiAgICAgOmJvZHkgKC0+YmxvY2sgezp0eXBlIDpTd2l0Y2hTdGF0ZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgIDpkaXNjcmltaW5hbnQgezp0eXBlIDpNZW1iZXJFeHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Y29tcHV0ZWQgZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpvYmplY3Qgezp0eXBlIDpJZGVudGlmaWVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6bmFtZSA6YXJndW1lbnRzfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOnByb3BlcnR5IHs6dHlwZSA6SWRlbnRpZmllclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6bmFtZSA6bGVuZ3RofX1cbiAgICAgICAgICAgICAgICAgICAgIDpjYXNlcyAoaWYgKDp2YXJpYWRpYyBmb3JtKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxvYWRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY29uaiBvdmVybG9hZHMgKGZhbGxiYWNrLW92ZXJsb2FkKSkpfSl9KSlcblxuKGRlZm4gd3JpdGUtZm4tb3ZlcmxvYWRcbiAgW2Zvcm1dXG4gIChsZXQgW3BhcmFtcyAoOnBhcmFtcyBmb3JtKVxuICAgICAgICBiaW5kaW5ncyAoaWYgKDp2YXJpYWRpYyBmb3JtKVxuICAgICAgICAgICAgICAgICAgIChjb25qICh3cml0ZS1vdmVybG9hZGluZy1wYXJhbXMgKGJ1dGxhc3QgcGFyYW1zKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAoc3BsaWNlLWJpbmRpbmcgZm9ybSkpXG4gICAgICAgICAgICAgICAgICAgKHdyaXRlLW92ZXJsb2FkaW5nLXBhcmFtcyBwYXJhbXMpKVxuICAgICAgICBzdGF0ZW1lbnRzICh2ZWMgKGNvbmNhdCBiaW5kaW5ncyAoOnN0YXRlbWVudHMgZm9ybSkpKV1cbiAgICB7OnR5cGUgOlN3aXRjaENhc2VcbiAgICAgOnRlc3QgKGlmIChub3QgKDp2YXJpYWRpYyBmb3JtKSlcbiAgICAgICAgICAgICB7OnR5cGUgOkxpdGVyYWxcbiAgICAgICAgICAgICAgOnZhbHVlICg6YXJpdHkgZm9ybSl9KVxuICAgICA6Y29uc2VxdWVudCAod3JpdGUtYm9keSAoY29uaiBmb3JtIHs6c3RhdGVtZW50cyBzdGF0ZW1lbnRzfSkpfSkpXG5cbihkZWZuIHdyaXRlLXNpbXBsZS1mblxuICBbZm9ybV1cbiAgKGxldCBbbWV0aG9kIChmaXJzdCAoOm1ldGhvZHMgZm9ybSkpXG4gICAgICAgIHBhcmFtcyAoaWYgKDp2YXJpYWRpYyBtZXRob2QpXG4gICAgICAgICAgICAgICAgIChidXRsYXN0ICg6cGFyYW1zIG1ldGhvZCkpXG4gICAgICAgICAgICAgICAgICg6cGFyYW1zIG1ldGhvZCkpXG4gICAgICAgIGJvZHkgKGlmICg6dmFyaWFkaWMgbWV0aG9kKVxuICAgICAgICAgICAgICAgKGNvbmogbWV0aG9kXG4gICAgICAgICAgICAgICAgICAgICB7OnN0YXRlbWVudHMgKHZlYyAoY29ucyAoc3BsaWNlLWJpbmRpbmcgbWV0aG9kKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKDpzdGF0ZW1lbnRzIG1ldGhvZCkpKX0pXG4gICAgICAgICAgICAgICBtZXRob2QpXVxuICAgIHs6cGFyYW1zIChtYXAgd3JpdGUtdmFyIHBhcmFtcylcbiAgICAgOmJvZHkgKC0+YmxvY2sgKHdyaXRlLWJvZHkgYm9keSkpfSkpXG5cbihkZWZuIHJlc29sdmVcbiAgW2Zyb20gdG9dXG4gIChsZXQgW3JlcXVpcmVyIChzcGxpdCAobmFtZSBmcm9tKSBcXC4pXG4gICAgICAgIHJlcXVpcmVtZW50IChzcGxpdCAobmFtZSB0bykgXFwuKVxuICAgICAgICByZWxhdGl2ZT8gKGFuZCAobm90IChpZGVudGljYWw/IChuYW1lIGZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG5hbWUgdG8pKSlcbiAgICAgICAgICAgICAgICAgICAgICAgKGlkZW50aWNhbD8gKGZpcnN0IHJlcXVpcmVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZmlyc3QgcmVxdWlyZW1lbnQpKSldXG4gICAgKGlmIHJlbGF0aXZlP1xuICAgICAgKGxvb3AgW2Zyb20gcmVxdWlyZXJcbiAgICAgICAgICAgICB0byByZXF1aXJlbWVudF1cbiAgICAgICAgKGlmIChpZGVudGljYWw/IChmaXJzdCBmcm9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgKGZpcnN0IHRvKSlcbiAgICAgICAgICAocmVjdXIgKHJlc3QgZnJvbSkgKHJlc3QgdG8pKVxuICAgICAgICAgIChqb2luIFxcL1xuICAgICAgICAgICAgICAgIChjb25jYXQgW1xcLl1cbiAgICAgICAgICAgICAgICAgICAgICAgIChyZXBlYXQgKGRlYyAoY291bnQgZnJvbSkpIFwiLi5cIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvKSkpKVxuICAgICAgKGpvaW4gXFwvIHJlcXVpcmVtZW50KSkpKVxuXG4oZGVmbiBpZC0+bnNcbiAgXCJUYWtlcyBuYW1lc3BhY2UgaWRlbnRpZmllciBzeW1ib2wgYW5kIHRyYW5zbGF0ZXMgdG8gbmV3XG4gIHN5bWJvbCB3aXRob3V0IC4gc3BlY2lhbCBjaGFyYWN0ZXJzXG4gIHdpc3AuY29yZSAtPiB3aXNwKmNvcmVcIlxuICBbaWRdXG4gIChzeW1ib2wgbmlsIChqb2luIFxcKiAoc3BsaXQgKG5hbWUgaWQpIFxcLikpKSlcblxuXG4oZGVmbiB3cml0ZS1yZXF1aXJlXG4gIFtmb3JtIHJlcXVpcmVyXVxuICAobGV0IFtucy1iaW5kaW5nIHs6b3AgOmRlZlxuICAgICAgICAgICAgICAgICAgICA6aWQgezpvcCA6dmFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgOnR5cGUgOmlkZW50aWZpZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICA6Zm9ybSAoaWQtPm5zICg6bnMgZm9ybSkpfVxuICAgICAgICAgICAgICAgICAgICA6aW5pdCB7Om9wIDppbnZva2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIDpjYWxsZWUgezpvcCA6dmFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6dHlwZSA6aWRlbnRpZmllclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOmZvcm0gJ3JlcXVpcmV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICA6cGFyYW1zIFt7Om9wIDpjb25zdGFudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpmb3JtIChyZXNvbHZlIHJlcXVpcmVyICg6bnMgZm9ybSkpfV19fVxuICAgICAgICBucy1hbGlhcyAoaWYgKDphbGlhcyBmb3JtKVxuICAgICAgICAgICAgICAgICAgIHs6b3AgOmRlZlxuICAgICAgICAgICAgICAgICAgICA6aWQgezpvcCA6dmFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgOnR5cGUgOmlkZW50aWZpZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICA6Zm9ybSAoaWQtPm5zICg6YWxpYXMgZm9ybSkpfVxuICAgICAgICAgICAgICAgICAgICA6aW5pdCAoOmlkIG5zLWJpbmRpbmcpfSlcblxuICAgICAgICByZWZlcmVuY2VzIChyZWR1Y2UgKGZuIFtyZWZlcmVuY2VzIGZvcm1dXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjb25qIHJlZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgezpvcCA6ZGVmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6aWQgezpvcCA6dmFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDp0eXBlIDppZGVudGlmaWVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpmb3JtIChvciAoOnJlbmFtZSBmb3JtKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKDpuYW1lIGZvcm0pKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDppbml0IHs6b3AgOm1lbWJlci1leHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOmNvbXB1dGVkIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOnRhcmdldCAoOmlkIG5zLWJpbmRpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOnByb3BlcnR5IHs6b3AgOnZhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOnR5cGUgOmlkZW50aWZpZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpmb3JtICg6bmFtZSBmb3JtKX19fSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKDpyZWZlciBmb3JtKSldXG4gICAgKHZlYyAoY29ucyBucy1iaW5kaW5nXG4gICAgICAgICAgICAgICAoaWYgbnMtYWxpYXNcbiAgICAgICAgICAgICAgICAgKGNvbnMgbnMtYWxpYXMgcmVmZXJlbmNlcylcbiAgICAgICAgICAgICAgICAgcmVmZXJlbmNlcykpKSkpXG5cbihkZWZuIHdyaXRlLW5zXG4gIFtmb3JtXVxuICAobGV0IFtub2RlICg6Zm9ybSBmb3JtKVxuICAgICAgICByZXF1aXJlciAoOm5hbWUgZm9ybSlcbiAgICAgICAgbnMtYmluZGluZyB7Om9wIDpkZWZcbiAgICAgICAgICAgICAgICAgICAgOm9yaWdpbmFsLWZvcm0gbm9kZVxuICAgICAgICAgICAgICAgICAgICA6aWQgezpvcCA6dmFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgOnR5cGUgOmlkZW50aWZpZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICA6b3JpZ2luYWwtZm9ybSAoZmlyc3Qgbm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICA6Zm9ybSAnKm5zKn1cbiAgICAgICAgICAgICAgICAgICAgOmluaXQgezpvcCA6ZGljdGlvbmFyeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgOmZvcm0gbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgOmtleXMgW3s6b3AgOnZhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6dHlwZSA6aWRlbnRpZmllclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6b3JpZ2luYWwtZm9ybSBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpmb3JtICdpZH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Om9wIDp2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOnR5cGUgOmlkZW50aWZpZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOm9yaWdpbmFsLWZvcm0gbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Zm9ybSAnZG9jfV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIDp2YWx1ZXMgW3s6b3AgOmNvbnN0YW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOnR5cGUgOmlkZW50aWZpZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6b3JpZ2luYWwtZm9ybSAoOm5hbWUgZm9ybSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Zm9ybSAobmFtZSAoOm5hbWUgZm9ybSkpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgezpvcCA6Y29uc3RhbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6b3JpZ2luYWwtZm9ybSBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOmZvcm0gKDpkb2MgZm9ybSl9XX19XG4gICAgICAgIHJlcXVpcmVtZW50cyAodmVjIChhcHBseSBjb25jYXQgKG1hcCAjKHdyaXRlLXJlcXVpcmUgJSByZXF1aXJlcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICg6cmVxdWlyZSBmb3JtKSkpKV1cbiAgICAoLT5ibG9jayAobWFwIHdyaXRlICh2ZWMgKGNvbnMgbnMtYmluZGluZyByZXF1aXJlbWVudHMpKSkpKSlcbihpbnN0YWxsLXdyaXRlciEgOm5zIHdyaXRlLW5zKVxuXG4oZGVmbiB3cml0ZS1mblxuICBbZm9ybV1cbiAgKGxldCBbYmFzZSAoaWYgKD4gKGNvdW50ICg6bWV0aG9kcyBmb3JtKSkgMSlcbiAgICAgICAgICAgICAgICh3cml0ZS1vdmVybG9hZGluZy1mbiBmb3JtKVxuICAgICAgICAgICAgICAgKHdyaXRlLXNpbXBsZS1mbiBmb3JtKSldXG4gICAgKGNvbmogYmFzZVxuICAgICAgICAgIHs6dHlwZSA6RnVuY3Rpb25FeHByZXNzaW9uXG4gICAgICAgICAgIDppZCAoaWYgKDppZCBmb3JtKSAod3JpdGUtdmFyICg6aWQgZm9ybSkpKVxuICAgICAgICAgICA6ZGVmYXVsdHMgbmlsXG4gICAgICAgICAgIDpyZXN0IG5pbFxuICAgICAgICAgICA6Z2VuZXJhdG9yIGZhbHNlXG4gICAgICAgICAgIDpleHByZXNzaW9uIGZhbHNlfSkpKVxuKGluc3RhbGwtd3JpdGVyISA6Zm4gd3JpdGUtZm4pXG5cbihkZWZuIHdyaXRlXG4gIFtmb3JtXVxuICAobGV0IFtvcCAoOm9wIGZvcm0pXG4gICAgICAgIHdyaXRlciAoYW5kICg9IDppbnZva2UgKDpvcCBmb3JtKSlcbiAgICAgICAgICAgICAgICAgICAgKD0gOnZhciAoOm9wICg6Y2FsbGVlIGZvcm0pKSlcbiAgICAgICAgICAgICAgICAgICAgKGdldCAqKnNwZWNpYWxzKiogKG5hbWUgKDpmb3JtICg6Y2FsbGVlIGZvcm0pKSkpKV1cbiAgICAoaWYgd3JpdGVyXG4gICAgICAod3JpdGUtc3BlY2lhbCB3cml0ZXIgZm9ybSlcbiAgICAgICh3cml0ZS1vcCAoOm9wIGZvcm0pIGZvcm0pKSkpXG5cbihkZWZuIHdyaXRlKlxuICBbJiBmb3Jtc11cbiAgKGxldCBbYm9keSAobWFwIHdyaXRlLXN0YXRlbWVudCBmb3JtcyldXG4gICAgezp0eXBlIDpQcm9ncmFtXG4gICAgIDpib2R5IGJvZHlcbiAgICAgOmxvYyAoaW5oZXJpdC1sb2NhdGlvbiBib2R5KX0pKVxuXG5cbihkZWZuIGNvbXBpbGVcbiAgKFtmb3JtXSAoY29tcGlsZSB7fSBmb3JtKSlcbiAgKFtvcHRpb25zICYgZm9ybXNdIChnZW5lcmF0ZSAoYXBwbHkgd3JpdGUqIGZvcm1zKSBvcHRpb25zKSkpXG5cblxuKGRlZm4gZ2V0LW1hY3JvXG4gIFt0YXJnZXQgcHJvcGVydHldXG4gIGAoYWdldCAob3IgfnRhcmdldCAwKVxuICAgICAgICAgfnByb3BlcnR5KSlcbihpbnN0YWxsLW1hY3JvISA6Z2V0IGdldC1tYWNybylcblxuOzsgTG9naWNhbCBvcGVyYXRvcnNcblxuKGRlZm4gaW5zdGFsbC1sb2dpY2FsLW9wZXJhdG9yIVxuICBbY2FsbGVlIG9wZXJhdG9yIGZhbGxiYWNrXVxuICAoZGVmbiB3cml0ZS1sb2dpY2FsLW9wZXJhdG9yXG4gICAgWyYgb3BlcmFuZHNdXG4gICAgKGxldCBbbiAoY291bnQgb3BlcmFuZHMpXVxuICAgICAgKGNvbmQgKD0gbiAwKSAod3JpdGUtY29uc3RhbnQgZmFsbGJhY2spXG4gICAgICAgICAgICAoPSBuIDEpICh3cml0ZSAoZmlyc3Qgb3BlcmFuZHMpKVxuICAgICAgICAgICAgOmVsc2UgKHJlZHVjZSAoZm4gW2xlZnQgcmlnaHRdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgezp0eXBlIDpMb2dpY2FsRXhwcmVzc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6b3BlcmF0b3Igb3BlcmF0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOmxlZnQgbGVmdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6cmlnaHQgKHdyaXRlIHJpZ2h0KX0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICh3cml0ZSAoZmlyc3Qgb3BlcmFuZHMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAocmVzdCBvcGVyYW5kcykpKSkpXG4gIChpbnN0YWxsLXNwZWNpYWwhIGNhbGxlZSB3cml0ZS1sb2dpY2FsLW9wZXJhdG9yKSlcbihpbnN0YWxsLWxvZ2ljYWwtb3BlcmF0b3IhIDpvciA6fHwgbmlsKVxuKGluc3RhbGwtbG9naWNhbC1vcGVyYXRvciEgOmFuZCA6JiYgdHJ1ZSlcblxuKGRlZm4gaW5zdGFsbC11bmFyeS1vcGVyYXRvciFcbiAgW2NhbGxlZSBvcGVyYXRvciBwcmVmaXg/XVxuICAoZGVmbiB3cml0ZS11bmFyeS1vcGVyYXRvclxuICAgIFsmIHBhcmFtc11cbiAgICAoaWYgKGlkZW50aWNhbD8gKGNvdW50IHBhcmFtcykgMSlcbiAgICAgIHs6dHlwZSA6VW5hcnlFeHByZXNzaW9uXG4gICAgICAgOm9wZXJhdG9yIG9wZXJhdG9yXG4gICAgICAgOmFyZ3VtZW50ICh3cml0ZSAoZmlyc3QgcGFyYW1zKSlcbiAgICAgICA6cHJlZml4IHByZWZpeD99XG4gICAgICAoZXJyb3ItYXJnLWNvdW50IGNhbGxlZSAoY291bnQgcGFyYW1zKSkpKVxuICAoaW5zdGFsbC1zcGVjaWFsISBjYWxsZWUgd3JpdGUtdW5hcnktb3BlcmF0b3IpKVxuKGluc3RhbGwtdW5hcnktb3BlcmF0b3IhIDpub3QgOiEpXG5cbjs7IEJpdHdpc2UgT3BlcmF0b3JzXG5cbihpbnN0YWxsLXVuYXJ5LW9wZXJhdG9yISA6Yml0LW5vdCA6filcblxuKGRlZm4gaW5zdGFsbC1iaW5hcnktb3BlcmF0b3IhXG4gIFtjYWxsZWUgb3BlcmF0b3JdXG4gIChkZWZuIHdyaXRlLWJpbmFyeS1vcGVyYXRvclxuICAgIFsmIHBhcmFtc11cbiAgICAoaWYgKDwgKGNvdW50IHBhcmFtcykgMilcbiAgICAgIChlcnJvci1hcmctY291bnQgY2FsbGVlIChjb3VudCBwYXJhbXMpKVxuICAgICAgKHJlZHVjZSAoZm4gW2xlZnQgcmlnaHRdXG4gICAgICAgICAgICAgICAgezp0eXBlIDpCaW5hcnlFeHByZXNzaW9uXG4gICAgICAgICAgICAgICAgIDpvcGVyYXRvciBvcGVyYXRvclxuICAgICAgICAgICAgICAgICA6bGVmdCBsZWZ0XG4gICAgICAgICAgICAgICAgIDpyaWdodCAod3JpdGUgcmlnaHQpfSlcbiAgICAgICAgICAgICAgKHdyaXRlIChmaXJzdCBwYXJhbXMpKVxuICAgICAgICAgICAgICAocmVzdCBwYXJhbXMpKSkpXG4gIChpbnN0YWxsLXNwZWNpYWwhIGNhbGxlZSB3cml0ZS1iaW5hcnktb3BlcmF0b3IpKVxuKGluc3RhbGwtYmluYXJ5LW9wZXJhdG9yISA6Yml0LWFuZCA6JilcbihpbnN0YWxsLWJpbmFyeS1vcGVyYXRvciEgOmJpdC1vciA6fClcbihpbnN0YWxsLWJpbmFyeS1vcGVyYXRvciEgOmJpdC14b3IgOl4pXG4oaW5zdGFsbC1iaW5hcnktb3BlcmF0b3IhIDpiaXQtc2hpZnQtbGVmdCA6PDwpXG4oaW5zdGFsbC1iaW5hcnktb3BlcmF0b3IhIDpiaXQtc2hpZnQtcmlnaHQgOj4+KVxuKGluc3RhbGwtYmluYXJ5LW9wZXJhdG9yISA6Yml0LXNoaWZ0LXJpZ2h0LXplcm8tZmlsIDo+Pj4pXG5cbjs7IEFyaXRobWV0aWMgb3BlcmF0b3JzXG5cbihkZWZuIGluc3RhbGwtYXJpdGhtZXRpYy1vcGVyYXRvciFcbiAgW2NhbGxlZSBvcGVyYXRvciB2YWxpZD8gZmFsbGJhY2tdXG5cbiAgKGRlZm4gd3JpdGUtYmluYXJ5LW9wZXJhdG9yXG4gICAgW2xlZnQgcmlnaHRdXG4gICAgezp0eXBlIDpCaW5hcnlFeHByZXNzaW9uXG4gICAgIDpvcGVyYXRvciAobmFtZSBvcGVyYXRvcilcbiAgICAgOmxlZnQgbGVmdFxuICAgICA6cmlnaHQgKHdyaXRlIHJpZ2h0KX0pXG5cbiAgKGRlZm4gd3JpdGUtYXJpdGhtZXRpYy1vcGVyYXRvclxuICAgIFsmIHBhcmFtc11cbiAgICAobGV0IFtuIChjb3VudCBwYXJhbXMpXVxuICAgICAgKGNvbmQgKGFuZCB2YWxpZD8gKG5vdCAodmFsaWQ/IG4pKSkgKGVycm9yLWFyZy1jb3VudCAobmFtZSBjYWxsZWUpIG4pXG4gICAgICAgICAgICAoPT0gbiAwKSAod3JpdGUtbGl0ZXJhbCBmYWxsYmFjaylcbiAgICAgICAgICAgICg9PSBuIDEpIChyZWR1Y2Ugd3JpdGUtYmluYXJ5LW9wZXJhdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICh3cml0ZS1saXRlcmFsIGZhbGxiYWNrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMpXG4gICAgICAgICAgICA6ZWxzZSAocmVkdWNlIHdyaXRlLWJpbmFyeS1vcGVyYXRvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAod3JpdGUgKGZpcnN0IHBhcmFtcykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChyZXN0IHBhcmFtcykpKSkpXG5cblxuICAoaW5zdGFsbC1zcGVjaWFsISBjYWxsZWUgd3JpdGUtYXJpdGhtZXRpYy1vcGVyYXRvcikpXG5cbihpbnN0YWxsLWFyaXRobWV0aWMtb3BlcmF0b3IhIDorIDorIG5pbCAwKVxuKGluc3RhbGwtYXJpdGhtZXRpYy1vcGVyYXRvciEgOi0gOi0gIyg+PSAlIDEpIDApXG4oaW5zdGFsbC1hcml0aG1ldGljLW9wZXJhdG9yISA6KiA6KiBuaWwgMSlcbihpbnN0YWxsLWFyaXRobWV0aWMtb3BlcmF0b3IhIChrZXl3b3JkIFxcLykgKGtleXdvcmQgXFwvKSAjKD49ICUgMSkgMSlcbihpbnN0YWxsLWFyaXRobWV0aWMtb3BlcmF0b3IhIDptb2QgKGtleXdvcmQgXFwlKSAjKD09ICUgMikgMSlcblxuXG47OyBDb21wYXJpc29uIG9wZXJhdG9yc1xuXG4oZGVmbiBpbnN0YWxsLWNvbXBhcmlzb24tb3BlcmF0b3IhXG4gIFwiR2VuZXJhdGVzIGNvbXBhcmlzb24gb3BlcmF0b3Igd3JpdGVyIHRoYXQgZ2l2ZW4gb25lXG4gIHBhcmFtZXRlciB3cml0ZXMgYGZhbGxiYWNrYCBnaXZlbiB0d28gcGFyYW1ldGVycyB3cml0ZXNcbiAgYmluYXJ5IGV4cHJlc3Npb24gYW5kIGdpdmVuIG1vcmUgcGFyYW1ldGVycyB3cml0ZXMgYmluYXJ5XG4gIGV4cHJlc3Npb25zIGpvaW5lZCBieSBsb2dpY2FsIGFuZC5cIlxuICBbY2FsbGVlIG9wZXJhdG9yIGZhbGxiYWNrXVxuXG4gIDs7IFRPRE8gIzU0XG4gIDs7IENvbXBhcmlzb24gb3BlcmF0b3JzIG11c3QgdXNlIHRlbXBvcmFyeSB2YXJpYWJsZSB0byBzdG9yZVxuICA7OyBleHByZXNzaW9uIG5vbiBsaXRlcmFsIGFuZCBub24taWRlbnRpZmllcnMuXG4gIChkZWZuIHdyaXRlLWNvbXBhcmlzb24tb3BlcmF0b3JcbiAgICAoW10gKGVycm9yLWFyZy1jb3VudCBjYWxsZWUgMCkpXG4gICAgKFtmb3JtXSAoLT5zZXF1ZW5jZSBbKHdyaXRlIGZvcm0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgKHdyaXRlLWxpdGVyYWwgZmFsbGJhY2spXSkpXG4gICAgKFtsZWZ0IHJpZ2h0XVxuICAgICB7OnR5cGUgOkJpbmFyeUV4cHJlc3Npb25cbiAgICAgIDpvcGVyYXRvciBvcGVyYXRvclxuICAgICAgOmxlZnQgKHdyaXRlIGxlZnQpXG4gICAgICA6cmlnaHQgKHdyaXRlIHJpZ2h0KX0pXG4gICAgKFtsZWZ0IHJpZ2h0ICYgbW9yZV1cbiAgICAgKHJlZHVjZSAoZm4gW2xlZnQgcmlnaHRdXG4gICAgICAgICAgICAgICB7OnR5cGUgOkxvZ2ljYWxFeHByZXNzaW9uXG4gICAgICAgICAgICAgICAgOm9wZXJhdG9yIDomJlxuICAgICAgICAgICAgICAgIDpsZWZ0IGxlZnRcbiAgICAgICAgICAgICAgICA6cmlnaHQgezp0eXBlIDpCaW5hcnlFeHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICA6b3BlcmF0b3Igb3BlcmF0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgIDpsZWZ0IChpZiAoPSA6TG9naWNhbEV4cHJlc3Npb24gKDp0eXBlIGxlZnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoOnJpZ2h0ICg6cmlnaHQgbGVmdCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICg6cmlnaHQgbGVmdCkpXG4gICAgICAgICAgICAgICAgICAgICAgICA6cmlnaHQgKHdyaXRlIHJpZ2h0KX19KVxuICAgICAgICAgICAgICh3cml0ZS1jb21wYXJpc29uLW9wZXJhdG9yIGxlZnQgcmlnaHQpXG4gICAgICAgICAgICAgbW9yZSkpKVxuXG4gIChpbnN0YWxsLXNwZWNpYWwhIGNhbGxlZSB3cml0ZS1jb21wYXJpc29uLW9wZXJhdG9yKSlcblxuKGluc3RhbGwtY29tcGFyaXNvbi1vcGVyYXRvciEgOj09IDo9PSB0cnVlKVxuKGluc3RhbGwtY29tcGFyaXNvbi1vcGVyYXRvciEgOj4gOj4gdHJ1ZSlcbihpbnN0YWxsLWNvbXBhcmlzb24tb3BlcmF0b3IhIDo+PSA6Pj0gdHJ1ZSlcbihpbnN0YWxsLWNvbXBhcmlzb24tb3BlcmF0b3IhIDo8IDo8IHRydWUpXG4oaW5zdGFsbC1jb21wYXJpc29uLW9wZXJhdG9yISA6PD0gOjw9IHRydWUpXG5cblxuKGRlZm4gd3JpdGUtaWRlbnRpY2FsP1xuICBbJiBwYXJhbXNdXG4gIDs7IFRPRE86IFN1Ym1pdCBhIGJ1ZyBmb3IgY2xvanVyZSB0byBhbGxvdyB2YXJpYWRpY1xuICA7OyBudW1iZXIgb2YgcGFyYW1zIGpvaW5lZCBieSBsb2dpY2FsIGFuZC5cbiAgKGlmIChpZGVudGljYWw/IChjb3VudCBwYXJhbXMpIDIpXG4gICAgezp0eXBlIDpCaW5hcnlFeHByZXNzaW9uXG4gICAgIDpvcGVyYXRvciA6PT09XG4gICAgIDpsZWZ0ICh3cml0ZSAoZmlyc3QgcGFyYW1zKSlcbiAgICAgOnJpZ2h0ICh3cml0ZSAoc2Vjb25kIHBhcmFtcykpfVxuICAgIChlcnJvci1hcmctY291bnQgOmlkZW50aWNhbD8gKGNvdW50IHBhcmFtcykpKSlcbihpbnN0YWxsLXNwZWNpYWwhIDppZGVudGljYWw/IHdyaXRlLWlkZW50aWNhbD8pXG5cbihkZWZuIHdyaXRlLWluc3RhbmNlP1xuICBbJiBwYXJhbXNdXG4gIDs7IFRPRE86IFN1Ym1pdCBhIGJ1ZyBmb3IgY2xvanVyZSB0byBtYWtlIHN1cmUgdGhhdFxuICA7OyBpbnN0YW5jZT8gZWl0aGVyIGFjY2VwdHMgb25seSB0d28gYXJncyBvciByZXR1cm5zXG4gIDs7IHRydWUgb25seSBpZiBhbGwgdGhlIHBhcmFtcyBhcmUgaW5zdGFuY2Ugb2YgdGhlXG4gIDs7IGdpdmVuIHR5cGUuXG5cbiAgKGxldCBbY29uc3RydWN0b3IgKGZpcnN0IHBhcmFtcylcbiAgICAgICAgaW5zdGFuY2UgKHNlY29uZCBwYXJhbXMpXVxuICAgIChpZiAoPCAoY291bnQgcGFyYW1zKSAxKVxuICAgICAgKGVycm9yLWFyZy1jb3VudCA6aW5zdGFuY2U/IChjb3VudCBwYXJhbXMpKVxuICAgICAgezp0eXBlIDpCaW5hcnlFeHByZXNzaW9uXG4gICAgICAgOm9wZXJhdG9yIDppbnN0YW5jZW9mXG4gICAgICAgOmxlZnQgKGlmIGluc3RhbmNlXG4gICAgICAgICAgICAgICAod3JpdGUgaW5zdGFuY2UpXG4gICAgICAgICAgICAgICAod3JpdGUtY29uc3RhbnQgaW5zdGFuY2UpKVxuICAgICAgIDpyaWdodCAod3JpdGUgY29uc3RydWN0b3IpfSkpKVxuKGluc3RhbGwtc3BlY2lhbCEgOmluc3RhbmNlPyB3cml0ZS1pbnN0YW5jZT8pXG5cblxuKGRlZm4gZXhwYW5kLWFwcGx5XG4gIFtmICYgcGFyYW1zXVxuICAobGV0IFtwcmVmaXggKHZlYyAoYnV0bGFzdCBwYXJhbXMpKV1cbiAgICAoaWYgKGVtcHR5PyBwcmVmaXgpXG4gICAgICBgKC5hcHBseSB+ZiBuaWwgfkBwYXJhbXMpXG4gICAgICBgKC5hcHBseSB+ZiBuaWwgKC5jb25jYXQgfnByZWZpeCB+KGxhc3QgcGFyYW1zKSkpKSkpXG4oaW5zdGFsbC1tYWNybyEgOmFwcGx5IGV4cGFuZC1hcHBseSlcblxuXG4oZGVmbiBleHBhbmQtcHJpbnRcbiAgWyZmb3JtICYgbW9yZV1cbiAgXCJQcmludHMgdGhlIG9iamVjdChzKSB0byB0aGUgb3V0cHV0IGZvciBodW1hbiBjb25zdW1wdGlvbi5cIlxuICAobGV0IFtvcCAod2l0aC1tZXRhICdjb25zb2xlLmxvZyAobWV0YSAmZm9ybSkpXVxuICAgIGAofm9wIH5AbW9yZSkpKVxuKGluc3RhbGwtbWFjcm8hIDpwcmludCAod2l0aC1tZXRhIGV4cGFuZC1wcmludCB7OmltcGxpY2l0IFs6JmZvcm1dfSkpXG5cbihkZWZuIGV4cGFuZC1zdHJcbiAgXCJzdHIgaW5saW5pbmcgYW5kIG9wdGltaXphdGlvbiB2aWEgbWFjcm9zXCJcbiAgWyYgZm9ybXNdXG4gIGAoKyBcIlwiIH5AZm9ybXMpKVxuKGluc3RhbGwtbWFjcm8hIDpzdHIgZXhwYW5kLXN0cilcblxuKGRlZm4gZXhwYW5kLWRlYnVnXG4gIFtdXG4gICdkZWJ1Z2dlcilcbihpbnN0YWxsLW1hY3JvISA6ZGVidWdnZXIhIGV4cGFuZC1kZWJ1ZylcblxuKGRlZm4gZXhwYW5kLWFzc2VydFxuICBeezpkb2MgXCJFdmFsdWF0ZXMgZXhwciBhbmQgdGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiBpdCBkb2VzIG5vdCBldmFsdWF0ZSB0b1xuICAgIGxvZ2ljYWwgdHJ1ZS5cIn1cbiAgKFt4XSAoZXhwYW5kLWFzc2VydCB4IFwiXCIpKVxuICAoW3ggbWVzc2FnZV0gKGxldCBbZm9ybSAocHItc3RyIHgpXVxuICAgICAgICAgICAgICAgICBgKGlmIChub3QgfngpXG4gICAgICAgICAgICAgICAgICAgICh0aHJvdyAoRXJyb3IgKHN0ciBcIkFzc2VydCBmYWlsZWQ6IFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB+bWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfmZvcm0pKSkpKSkpXG4oaW5zdGFsbC1tYWNybyEgOmFzc2VydCBleHBhbmQtYXNzZXJ0KVxuXG5cbihkZWZuIGV4cGFuZC1kZWZwcm90b2NvbFxuICBbJmVudiBpZCAmIGZvcm1zXVxuICAobGV0IFtucyAobmFtZSAoOm5hbWUgKDpucyAmZW52KSkpXG4gICAgICAgIHByb3RvY29sLW5hbWUgKG5hbWUgaWQpXG4gICAgICAgIHByb3RvY29sLWRvYyAoaWYgKHN0cmluZz8gKGZpcnN0IGZvcm1zKSlcbiAgICAgICAgICAgICAgICAgICAgICAgKGZpcnN0IGZvcm1zKSlcbiAgICAgICAgcHJvdG9jb2wtbWV0aG9kcyAoaWYgcHJvdG9jb2wtZG9jXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAocmVzdCBmb3JtcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1zKVxuICAgICAgICBwcm90b2NvbCAocmVkdWNlIChmbiBbcHJvdG9jb2wgbWV0aG9kXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKGxldCBbbWV0aG9kLW5hbWUgKGZpcnN0IG1ldGhvZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkIChpZC0+bnMgKHN0ciBucyBcIiRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3RvY29sLW5hbWUgXCIkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobmFtZSBtZXRob2QtbmFtZSkpKV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNvbmogcHJvdG9jb2xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgezppZCBtZXRob2QtbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOmZuIGAoZm4gfmlkIFtzZWxmXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChkZWYgZiAoY29uZCAoaWRlbnRpY2FsPyBzZWxmIG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICguLW5pbCB+aWQpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGlkZW50aWNhbD8gc2VsZiBuaWwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICguLW5pbCB+aWQpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOmVsc2UgKG9yIChhZ2V0IHNlbGYgJ35pZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChhZ2V0IH5pZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKC5yZXBsYWNlICgucmVwbGFjZSAoLmNhbGwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyBzZWxmKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIltvYmplY3QgXCIgXCJcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAjXCJcXF0kXCIgXCJcIikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoLi1fIH5pZCkpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoLmFwcGx5IGYgc2VsZiBhcmd1bWVudHMpKX0pKSlcblxuICAgICAgICAgICAgICAgICAgICAgICAgIFtdXG4gICAgICAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2wtbWV0aG9kcylcbiAgICAgICAgZm5zIChtYXAgKGZuIFtmb3JtXVxuICAgICAgICAgICAgICAgICAgIGAoZGVmIH4oOmlkIGZvcm0pIChhZ2V0IH5pZCAnfig6aWQgZm9ybSkpKSlcbiAgICAgICAgICAgICAgICAgcHJvdG9jb2wpXG4gICAgICAgIHNhdGlzZnkgKGFzc29jIHt9ICd3aXNwX2NvcmUkSVByb3RvY29sJGlkIChzdHIgbnMgXCIvXCIgcHJvdG9jb2wtbmFtZSkpXG4gICAgICAgIGJvZHkgKHJlZHVjZSAoZm4gW2JvZHkgbWV0aG9kXVxuICAgICAgICAgICAgICAgICAgICAgICAoYXNzb2MgYm9keSAoOmlkIG1ldGhvZCkgKDpmbiBtZXRob2QpKSlcbiAgICAgICAgICAgICAgICAgICAgIHNhdGlzZnlcbiAgICAgICAgICAgICAgICAgICAgIHByb3RvY29sKV1cbiAgICBgKH4od2l0aC1tZXRhICdkbyB7OmJsb2NrIHRydWV9KVxuICAgICAgIChkZWYgfmlkIH5ib2R5KVxuICAgICAgIH5AZm5zXG4gICAgICAgfmlkKSkpXG4oaW5zdGFsbC1tYWNybyEgOmRlZnByb3RvY29sICh3aXRoLW1ldGEgZXhwYW5kLWRlZnByb3RvY29sIHs6aW1wbGljaXQgWzomZW52XX0pKVxuXG4oZGVmbiBleHBhbmQtZGVmdHlwZVxuICBbaWQgZmllbGRzICYgZm9ybXNdXG4gIChsZXQgW3R5cGUtaW5pdCAobWFwIChmbiBbZmllbGRdIGAoc2V0ISAoYWdldCB0aGlzICd+ZmllbGQpIH5maWVsZCkpXG4gICAgICAgICAgICAgICAgICAgICAgIGZpZWxkcylcbiAgICAgICAgY29uc3RydWN0b3IgKGNvbmogdHlwZS1pbml0ICd0aGlzKVxuICAgICAgICBtZXRob2QtaW5pdCAobWFwIChmbiBbZmllbGRdIGAoZGVmIH5maWVsZCAoYWdldCB0aGlzICd+ZmllbGQpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZHMpXG4gICAgICAgIG1ha2UtbWV0aG9kIChmbiBbcHJvdG9jb2wgZm9ybV1cbiAgICAgICAgICAgICAgICAgICAgICAobGV0IFttZXRob2QtbmFtZSAoZmlyc3QgZm9ybSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgKHNlY29uZCBmb3JtKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgKHJlc3QgKHJlc3QgZm9ybSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQtbmFtZSAoaWYgKD0gKG5hbWUgcHJvdG9jb2wpIFwiT2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAocXVvdGUgfm1ldGhvZC1uYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgKC4tbmFtZSAoYWdldCB+cHJvdG9jb2wgJ35tZXRob2QtbmFtZSkpKV1cblxuICAgICAgICAgICAgICAgICAgICAgICAgYChzZXQhIChhZ2V0ICguLXByb3RvdHlwZSB+aWQpIH5maWVsZC1uYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChmbiB+cGFyYW1zIH5AbWV0aG9kLWluaXQgfkBib2R5KSkpKVxuICAgICAgICBzYXRpc2Z5IChmbiBbcHJvdG9jb2xdXG4gICAgICAgICAgICAgICAgICBgKHNldCEgKGFnZXQgKC4tcHJvdG90eXBlIH5pZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoLi13aXNwX2NvcmUkSVByb3RvY29sJGlkIH5wcm90b2NvbCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSkpXG5cbiAgICAgICAgYm9keSAocmVkdWNlIChmbiBbdHlwZSBmb3JtXVxuICAgICAgICAgICAgICAgICAgICAgICAoaWYgKGxpc3Q/IGZvcm0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgKGNvbmogdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHs6Ym9keSAoY29uaiAoOmJvZHkgdHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG1ha2UtbWV0aG9kICg6cHJvdG9jb2wgdHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm0pKX0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgKGNvbmogdHlwZSB7OnByb3RvY29sIGZvcm1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Ym9keSAoY29uaiAoOmJvZHkgdHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc2F0aXNmeSBmb3JtKSl9KSkpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgezpwcm90b2NvbCBuaWxcbiAgICAgICAgICAgICAgICAgICAgICAgIDpib2R5IFtdfVxuXG4gICAgICAgICAgICAgICAgICAgICAgIGZvcm1zKVxuXG4gICAgICAgIG1ldGhvZHMgKDpib2R5IGJvZHkpXVxuICAgIGAoZGVmIH5pZCAoZG9cbiAgICAgICAoZGVmbi0gfmlkIH5maWVsZHMgfkBjb25zdHJ1Y3RvcilcbiAgICAgICB+QG1ldGhvZHNcbiAgICAgICB+aWQpKSkpXG4oaW5zdGFsbC1tYWNybyEgOmRlZnR5cGUgZXhwYW5kLWRlZnR5cGUpXG4oaW5zdGFsbC1tYWNybyEgOmRlZnJlY29yZCBleHBhbmQtZGVmdHlwZSlcblxuKGRlZm4gZXhwYW5kLWV4dGVuZC10eXBlXG4gIFt0eXBlICYgZm9ybXNdXG4gIChsZXQgW2RlZmF1bHQtdHlwZT8gKD0gdHlwZSAnZGVmYXVsdClcbiAgICAgICAgbmlsLXR5cGU/IChuaWw/IHR5cGUpXG5cbiAgICAgICAgdHlwZS1uYW1lIChjb25kIChuaWw/IHR5cGUpIChzeW1ib2wgXCJuaWxcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICg9IHR5cGUgJ2RlZmF1bHQpICdfXG4gICAgICAgICAgICAgICAgICAgICAgICAoPSB0eXBlICdudW1iZXIpICdOdW1iZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICg9IHR5cGUgJ3N0cmluZykgJ1N0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgKD0gdHlwZSAnYm9vbGVhbikgJ0Jvb2xlYW5cbiAgICAgICAgICAgICAgICAgICAgICAgICg9IHR5cGUgJ3ZlY3RvcikgJ0FycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICAoPSB0eXBlICdmdW5jdGlvbikgJ0Z1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAoPSB0eXBlICdyZS1wYXR0ZXJuKSAnUmVnRXhwXG4gICAgICAgICAgICAgICAgICAgICAgICAoPSAobmFtZXNwYWNlIHR5cGUpIFwianNcIikgdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgOmVsc2UgbmlsKVxuXG4gICAgICAgIHNhdGlzZnkgKGZuIFtwcm90b2NvbF1cbiAgICAgICAgICAgICAgICAgIChpZiB0eXBlLW5hbWVcbiAgICAgICAgICAgICAgICAgICAgYChzZXQhIChhZ2V0IH5wcm90b2NvbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ34oc3ltYm9sIChzdHIgXCJ3aXNwX2NvcmUkSVByb3RvY29sJFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobmFtZSB0eXBlLW5hbWUpKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVlKVxuICAgICAgICAgICAgICAgICAgICBgKHNldCEgKGFnZXQgKC4tcHJvdG90eXBlIH50eXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKC4td2lzcF9jb3JlJElQcm90b2NvbCRpZCB+cHJvdG9jb2wpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSkpKVxuXG4gICAgICAgIG1ha2UtbWV0aG9kIChmbiBbcHJvdG9jb2wgZm9ybV1cbiAgICAgICAgICAgICAgICAgICAgICAobGV0IFttZXRob2QtbmFtZSAoZmlyc3QgZm9ybSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgKHNlY29uZCBmb3JtKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHkgKHJlc3QgKHJlc3QgZm9ybSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0IChpZiB0eXBlLW5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgKGFnZXQgKGFnZXQgfnByb3RvY29sICd+bWV0aG9kLW5hbWUpICd+dHlwZS1uYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAoYWdldCAoLi1wcm90b3R5cGUgfnR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICguLW5hbWUgKGFnZXQgfnByb3RvY29sICd+bWV0aG9kLW5hbWUpKSkpXVxuICAgICAgICAgICAgICAgICAgICAgICAgYChzZXQhIH50YXJnZXQgKGZuIH5wYXJhbXMgfkBib2R5KSkpKVxuXG4gICAgICAgIGJvZHkgKHJlZHVjZSAoZm4gW2JvZHkgZm9ybV1cbiAgICAgICAgICAgICAgICAgICAgICAgKGlmIChsaXN0PyBmb3JtKVxuICAgICAgICAgICAgICAgICAgICAgICAgIChjb25qIGJvZHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Om1ldGhvZHMgKGNvbmogKDptZXRob2RzIGJvZHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChtYWtlLW1ldGhvZCAoOnByb3RvY29sIGJvZHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtKSl9KVxuICAgICAgICAgICAgICAgICAgICAgICAgIChjb25qIGJvZHkgezpwcm90b2NvbCBmb3JtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOm1ldGhvZHMgKGNvbmogKDptZXRob2RzIGJvZHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNhdGlzZnkgZm9ybSkpfSkpKVxuXG4gICAgICAgICAgICAgICAgICAgICAgIHs6cHJvdG9jb2wgbmlsXG4gICAgICAgICAgICAgICAgICAgICAgICA6bWV0aG9kcyBbXX1cblxuICAgICAgICAgICAgICAgICAgICAgICBmb3JtcylcbiAgICAgICAgbWV0aG9kcyAoOm1ldGhvZHMgYm9keSldXG4gICAgYChkbyB+QG1ldGhvZHMgbmlsKSkpXG4oaW5zdGFsbC1tYWNybyEgOmV4dGVuZC10eXBlIGV4cGFuZC1leHRlbmQtdHlwZSlcblxuKGRlZm4gZXhwYW5kLWV4dGVuZC1wcm90b2NvbFxuICBbcHJvdG9jb2wgJiBmb3Jtc11cbiAgKGxldCBbc3BlY3MgKHJlZHVjZSAoZm4gW3NwZWNzIGZvcm1dXG4gICAgICAgICAgICAgICAgICAgICAgICAoaWYgKGxpc3Q/IGZvcm0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChjb25zIHs6dHlwZSAoOnR5cGUgKGZpcnN0IHNwZWNzKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDptZXRob2RzIChjb25qICg6bWV0aG9kcyAoZmlyc3Qgc3BlY3MpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybSl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChyZXN0IHNwZWNzKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKGNvbnMgezp0eXBlIGZvcm1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDptZXRob2RzIFtdfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGVjcykpKVxuICAgICAgICAgICAgICAgICAgICAgIG5pbFxuICAgICAgICAgICAgICAgICAgICAgIGZvcm1zKVxuICAgICAgICBib2R5IChtYXAgKGZuIFtmb3JtXVxuICAgICAgICAgICAgICAgICAgICBgKGV4dGVuZC10eXBlIH4oOnR5cGUgZm9ybSlcbiAgICAgICAgICAgICAgICAgICAgICAgfnByb3RvY29sXG4gICAgICAgICAgICAgICAgICAgICAgIH5AKDptZXRob2RzIGZvcm0pXG4gICAgICAgICAgICAgICAgICAgICAgICkpXG4gICAgICAgICAgICAgICAgICBzcGVjcyldXG5cblxuICAgIGAoZG8gfkBib2R5IG5pbCkpKVxuKGluc3RhbGwtbWFjcm8hIDpleHRlbmQtcHJvdG9jb2wgZXhwYW5kLWV4dGVuZC1wcm90b2NvbClcblxuKGRlZm4gYXNldC1leHBhbmRcbiAgKFt0YXJnZXQgZmllbGQgdmFsdWVdXG4gICBgKHNldCEgKGFnZXQgfnRhcmdldCB+ZmllbGQpIH52YWx1ZSkpXG4gIChbdGFyZ2V0IGZpZWxkIHN1Yi1maWVsZCAmIHN1Yi1maWVsZHMmdmFsdWVdXG4gICAobGV0IFtyZXNvbHZlZC10YXJnZXQgKHJlZHVjZSAoZm4gW2Zvcm0gbm9kZV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYChhZ2V0IH5mb3JtIH5ub2RlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAoYWdldCB+dGFyZ2V0IH5maWVsZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjb25zIHN1Yi1maWVsZCAoYnV0bGFzdCBzdWItZmllbGRzJnZhbHVlKSkpXG4gICAgICAgICB2YWx1ZSAobGFzdCBzdWItZmllbGRzJnZhbHVlKV1cbiAgICAgYChzZXQhIH5yZXNvbHZlZC10YXJnZXQgfnZhbHVlKSkpKVxuKGluc3RhbGwtbWFjcm8hIDphc2V0IGFzZXQtZXhwYW5kKVxuXG4oZGVmbiBhbGVuZ3RoLWV4cGFuZFxuICBcIlJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuIFdvcmtzIG9uIGFycmF5cyBvZiBhbGwgdHlwZXMuXCJcbiAgW2FycmF5XVxuICBgKC4tbGVuZ3RoIH5hcnJheSkpXG4oaW5zdGFsbC1tYWNybyEgOmFsZW5ndGggYWxlbmd0aC1leHBhbmQpXG5cbiJdfQ==

},{"./../../ast":"ReP8Ll","./../../expander":"RaoPh2","./../../reader":"vmsNNR","./../../runtime":"wcC2X1","./../../sequence":"Mdzbzt","./../../string":"31fh9Q","escodegen":22}],"wisp/backend/javascript/writer":[function(require,module,exports){
module.exports=require('whgxbs');
},{}],"whgxbs":[function(require,module,exports){
{
    var _ns_ = {
            id: 'wisp.backend.javascript.writer',
            doc: 'Compiler backend for for writing JS output'
        };
    var wisp_ast = require('./../../ast');
    var name = wisp_ast.name;
    var namespace = wisp_ast.namespace;
    var symbol = wisp_ast.symbol;
    var isSymbol = wisp_ast.isSymbol;
    var isKeyword = wisp_ast.isKeyword;
    var wisp_sequence = require('./../../sequence');
    var list = wisp_sequence.list;
    var first = wisp_sequence.first;
    var second = wisp_sequence.second;
    var third = wisp_sequence.third;
    var rest = wisp_sequence.rest;
    var isList = wisp_sequence.isList;
    var vec = wisp_sequence.vec;
    var map = wisp_sequence.map;
    var count = wisp_sequence.count;
    var last = wisp_sequence.last;
    var reduce = wisp_sequence.reduce;
    var isEmpty = wisp_sequence.isEmpty;
    var wisp_runtime = require('./../../runtime');
    var isTrue = wisp_runtime.isTrue;
    var isNil = wisp_runtime.isNil;
    var isString = wisp_runtime.isString;
    var isNumber = wisp_runtime.isNumber;
    var isVector = wisp_runtime.isVector;
    var isDictionary = wisp_runtime.isDictionary;
    var isBoolean = wisp_runtime.isBoolean;
    var isRePattern = wisp_runtime.isRePattern;
    var reFind = wisp_runtime.reFind;
    var dec = wisp_runtime.dec;
    var subs = wisp_runtime.subs;
    var isEqual = wisp_runtime.isEqual;
    var wisp_string = require('./../../string');
    var replace = wisp_string.replace;
    var join = wisp_string.join;
    var split = wisp_string.split;
    var upperCase = wisp_string.upperCase;
}
var writeReference = exports.writeReference = function writeReference(form) {
        'Translates references from clojure convention to JS:\n\n  **macros**      __macros__\n  list->vector    listToVector\n  set!            set\n  foo_bar         foo_bar\n  number?         isNumber\n  create-server   createServer';
        return function () {
            var idø1 = name(form);
            idø1 = idø1 === '*' ? 'multiply' : idø1 === '/' ? 'divide' : idø1 === '+' ? 'sum' : idø1 === '-' ? 'subtract' : idø1 === '=' ? 'equal?' : idø1 === '==' ? 'strict-equal?' : idø1 === '<=' ? 'not-greater-than' : idø1 === '>=' ? 'not-less-than' : idø1 === '>' ? 'greater-than' : idø1 === '<' ? 'less-than' : idø1 === '->' ? 'thread-first' : 'else' ? idø1 : void 0;
            idø1 = join('_', split(idø1, '*'));
            idø1 = join('-to-', split(idø1, '->'));
            idø1 = join(split(idø1, '!'));
            idø1 = join('$', split(idø1, '%'));
            idø1 = join('-plus-', split(idø1, '+'));
            idø1 = join('-and-', split(idø1, '&'));
            idø1 = last(idø1) === '?' ? '' + 'is-' + subs(idø1, 0, dec(count(idø1))) : idø1;
            idø1 = reduce(function (result, key) {
                return '' + result + (!isEmpty(result) && !isEmpty(key) ? '' + upperCase((key || 0)[0]) + subs(key, 1) : key);
            }, '', split(idø1, '-'));
            return idø1;
        }.call(this);
    };
var writeKeywordReference = exports.writeKeywordReference = function writeKeywordReference(form) {
        return '' + '"' + name(form) + '"';
    };
var writeKeyword = exports.writeKeyword = function writeKeyword(form) {
        return '' + '"' + '\uA789' + name(form) + '"';
    };
var writeSymbol = exports.writeSymbol = function writeSymbol(form) {
        return write(list(symbol(void 0, 'symbol'), namespace(form), name(form)));
    };
var writeNil = exports.writeNil = function writeNil(form) {
        return 'void(0)';
    };
var writeNumber = exports.writeNumber = function writeNumber(form) {
        return form;
    };
var writeBoolean = exports.writeBoolean = function writeBoolean(form) {
        return isTrue(form) ? 'true' : 'false';
    };
var writeString = exports.writeString = function writeString(form) {
        form = replace(form, RegExp('\\\\', 'g'), '\\\\');
        form = replace(form, RegExp('\n', 'g'), '\\n');
        form = replace(form, RegExp('\r', 'g'), '\\r');
        form = replace(form, RegExp('\t', 'g'), '\\t');
        form = replace(form, RegExp('"', 'g'), '\\"');
        return '' + '"' + form + '"';
    };
var writeTemplate = exports.writeTemplate = function writeTemplate() {
        var form = Array.prototype.slice.call(arguments, 0);
        return function () {
            var indentPatternø1 = /\n *$/;
            var lineBreakPatterø1 = RegExp('\n', 'g');
            var getIndentationø1 = function (code) {
                return reFind(indentPatternø1, code) || '\n';
            };
            return function loop() {
                var recur = loop;
                var codeø1 = '';
                var partsø1 = split(first(form), '~{}');
                var valuesø1 = rest(form);
                do {
                    recur = count(partsø1) > 1 ? (loop[0] = '' + codeø1 + first(partsø1) + replace('' + '' + first(valuesø1), lineBreakPatterø1, getIndentationø1(first(partsø1))), loop[1] = rest(partsø1), loop[2] = rest(valuesø1), loop) : '' + codeø1 + first(partsø1);
                } while (codeø1 = loop[0], partsø1 = loop[1], valuesø1 = loop[2], recur === loop);
                return recur;
            }.call(this);
        }.call(this);
    };
var writeGroup = exports.writeGroup = function writeGroup() {
        var forms = Array.prototype.slice.call(arguments, 0);
        return join(', ', forms);
    };
var writeInvoke = exports.writeInvoke = function writeInvoke(callee) {
        var params = Array.prototype.slice.call(arguments, 1);
        return writeTemplate('~{}(~{})', callee, writeGroup.apply(void 0, params));
    };
var writeError = exports.writeError = function writeError(message) {
        return function () {
            return (function () {
                throw Error(message);
            })();
        };
    };
var writeVector = exports.writeVector = writeError('Vectors are not supported');
var writeDictionary = exports.writeDictionary = writeError('Dictionaries are not supported');
var escapePattern = function escapePattern(pattern) {
    pattern = join('/', split(pattern, '\\/'));
    pattern = join('\\/', split(pattern, '/'));
    return pattern;
};
var writeRePattern = exports.writeRePattern = function writeRePattern(form) {
        return function () {
            var flagsø1 = '' + (form.multiline ? 'm' : '') + (form.ignoreCase ? 'i' : '') + (form.sticky ? 'y' : '');
            var patternø1 = form.source;
            return '' + '/' + escapePattern(patternø1) + '/' + flagsø1;
        }.call(this);
    };
var compileComment = exports.compileComment = function compileComment(form) {
        return compileTemplate(list('//~{}\n', first(form)));
    };
var writeDef = exports.writeDef = function writeDef(form) {
        return function () {
            var idø1 = first(form);
            var isExportø1 = (meta(form) || {} || 0)['top'] && !(meta(idø1) || {} || 0)['private'];
            var attributeø1 = symbol(namespace(idø1), '' + '-' + name(idø1));
            return isExportø1 ? compileTemplate(list('var ~{};\n~{}', compile(cons(symbol(void 0, 'set!'), form)), compile(list.apply(void 0, [symbol(void 0, 'set!')].concat([list.apply(void 0, [symbol(void 0, '.')].concat([symbol(void 0, 'exports')], [attributeø1]))], [idø1]))))) : compileTemplate(list('var ~{}', compile(cons(symbol(void 0, 'set!'), form))));
        }.call(this);
    };
var isWriteInstance = exports.isWriteInstance = function isWriteInstance(form) {
        return writeTemplate('~{} instanceof ~{}', write(second(form)), write(first(form)));
    };
var write = exports.write = function write(form) {
        return isNil(form) ? writeNil(form) : isSymbol(form) ? writeReference(form) : isKeyword(form) ? writeKeywordReference(form) : isString(form) ? writeString(form) : isNumber(form) ? writeNumber(form) : isBoolean(form) ? writeBoolean(form) : isRePattern(form) ? writePattern(form) : isVector(form) ? writeVector(form) : isDictionary(form) ? writeDictionary() : isList(form) ? writeInvoke.apply(void 0, map(write, vec(form))) : 'else' ? writeError('Unsupported form') : void 0;
    };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFub255bW91cy53aXNwIl0sIm5hbWVzIjpbIl9uc18iLCJpZCIsImRvYyIsIm5hbWUiLCJuYW1lc3BhY2UiLCJzeW1ib2wiLCJpc1N5bWJvbCIsImlzS2V5d29yZCIsImxpc3QiLCJmaXJzdCIsInNlY29uZCIsInRoaXJkIiwicmVzdCIsImlzTGlzdCIsInZlYyIsIm1hcCIsImNvdW50IiwibGFzdCIsInJlZHVjZSIsImlzRW1wdHkiLCJpc1RydWUiLCJpc05pbCIsImlzU3RyaW5nIiwiaXNOdW1iZXIiLCJpc1ZlY3RvciIsImlzRGljdGlvbmFyeSIsImlzQm9vbGVhbiIsImlzUmVQYXR0ZXJuIiwicmVGaW5kIiwiZGVjIiwic3VicyIsImlzRXF1YWwiLCJyZXBsYWNlIiwiam9pbiIsInNwbGl0IiwidXBwZXJDYXNlIiwid3JpdGVSZWZlcmVuY2UiLCJleHBvcnRzIiwiZm9ybSIsImlkw7gxIiwicmVzdWx0Iiwia2V5Iiwid3JpdGVLZXl3b3JkUmVmZXJlbmNlIiwid3JpdGVLZXl3b3JkIiwid3JpdGVTeW1ib2wiLCJ3cml0ZSIsIndyaXRlTmlsIiwid3JpdGVOdW1iZXIiLCJ3cml0ZUJvb2xlYW4iLCJ3cml0ZVN0cmluZyIsIlJlZ0V4cCIsIndyaXRlVGVtcGxhdGUiLCJpbmRlbnRQYXR0ZXJuw7gxIiwibGluZUJyZWFrUGF0dGVyw7gxIiwiZ2V0SW5kZW50YXRpb27DuDEiLCJjb2RlIiwiY29kZcO4MSIsInBhcnRzw7gxIiwidmFsdWVzw7gxIiwid3JpdGVHcm91cCIsImZvcm1zIiwid3JpdGVJbnZva2UiLCJjYWxsZWUiLCJwYXJhbXMiLCJ3cml0ZUVycm9yIiwibWVzc2FnZSIsIkVycm9yIiwid3JpdGVWZWN0b3IiLCJ3cml0ZURpY3Rpb25hcnkiLCJlc2NhcGVQYXR0ZXJuIiwicGF0dGVybiIsIndyaXRlUmVQYXR0ZXJuIiwiZmxhZ3PDuDEiLCJtdWx0aWxpbmUiLCJpZ25vcmVDYXNlIiwic3RpY2t5IiwicGF0dGVybsO4MSIsInNvdXJjZSIsImNvbXBpbGVDb21tZW50IiwiY29tcGlsZVRlbXBsYXRlIiwid3JpdGVEZWYiLCJpc0V4cG9ydMO4MSIsIm1ldGEiLCJhdHRyaWJ1dGXDuDEiLCJjb21waWxlIiwiY29ucyIsImlzV3JpdGVJbnN0YW5jZSIsIndyaXRlUGF0dGVybiJdLCJtYXBwaW5ncyI6IjtJQUFBLElBQUNBLEksR0FBRDtBQUFBLFlBQUFDLEUsRUFBSSxnQ0FBSjtBQUFBLFlBQUFDLEcsRUFDRSw0Q0FERjtBQUFBLFU7O1FBRThCQyxJQUFBLEcsU0FBQUEsSTtRQUFLQyxTQUFBLEcsU0FBQUEsUztRQUFVQyxNQUFBLEcsU0FBQUEsTTtRQUFPQyxRQUFBLEcsU0FBQUEsUTtRQUFRQyxTQUFBLEcsU0FBQUEsUzs7UUFDekJDLElBQUEsRyxjQUFBQSxJO1FBQUtDLEtBQUEsRyxjQUFBQSxLO1FBQU1DLE1BQUEsRyxjQUFBQSxNO1FBQU9DLEtBQUEsRyxjQUFBQSxLO1FBQU1DLElBQUEsRyxjQUFBQSxJO1FBQUtDLE1BQUEsRyxjQUFBQSxNO1FBQzdCQyxHQUFBLEcsY0FBQUEsRztRQUFJQyxHQUFBLEcsY0FBQUEsRztRQUFJQyxLQUFBLEcsY0FBQUEsSztRQUFNQyxJQUFBLEcsY0FBQUEsSTtRQUFLQyxNQUFBLEcsY0FBQUEsTTtRQUFPQyxPQUFBLEcsY0FBQUEsTzs7UUFDM0JDLE1BQUEsRyxhQUFBQSxNO1FBQU1DLEtBQUEsRyxhQUFBQSxLO1FBQUtDLFFBQUEsRyxhQUFBQSxRO1FBQVFDLFFBQUEsRyxhQUFBQSxRO1FBQVFDLFFBQUEsRyxhQUFBQSxRO1FBQzNCQyxZQUFBLEcsYUFBQUEsWTtRQUFZQyxTQUFBLEcsYUFBQUEsUztRQUFTQyxXQUFBLEcsYUFBQUEsVztRQUNyQkMsTUFBQSxHLGFBQUFBLE07UUFBUUMsR0FBQSxHLGFBQUFBLEc7UUFBSUMsSUFBQSxHLGFBQUFBLEk7UUFBS0MsT0FBQSxHLGFBQUFBLE87O1FBQ2xCQyxPQUFBLEcsWUFBQUEsTztRQUFRQyxJQUFBLEcsWUFBQUEsSTtRQUFLQyxLQUFBLEcsWUFBQUEsSztR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TUEsS0FBTixDQUVHUCxJQUZILEVBR0U7QUFBQSxlQUNFakIsS0FBRCxDQUFNaUIsSUFBTixDQURELEdBQ2NRLFFBQUQsQ0FBV1IsSUFBWCxDQURiLEdBRUVoQyxRQUFELENBQVNnQyxJQUFULEMsR0FBZ0JGLGNBQUQsQ0FBaUJFLElBQWpCLEMsR0FDZC9CLFNBQUQsQ0FBVStCLElBQVYsQyxHQUFpQkkscUJBQUQsQ0FBeUJKLElBQXpCLEMsR0FDZmhCLFFBQUQsQ0FBU2dCLElBQVQsQyxHQUFnQlcsV0FBRCxDQUFjWCxJQUFkLEMsR0FDZGYsUUFBRCxDQUFTZSxJQUFULEMsR0FBZ0JTLFdBQUQsQ0FBY1QsSUFBZCxDLEdBQ2RaLFNBQUQsQ0FBVVksSUFBVixDLEdBQWlCVSxZQUFELENBQWVWLElBQWYsQyxHQUNmWCxXQUFELENBQWFXLElBQWIsQyxHQUFvQmlELFlBQUQsQ0FBZWpELElBQWYsQyxHQUNsQmQsUUFBRCxDQUFTYyxJQUFULEMsR0FBZ0I2QixXQUFELENBQWM3QixJQUFkLEMsR0FDZGIsWUFBRCxDQUFhYSxJQUFiLEMsR0FBb0I4QixlQUFELEUsR0FDbEJ2RCxNQUFELENBQU95QixJQUFQLEMsR0FBb0J1QixXLE1BQVAsQyxNQUFBLEVBQXFCOUMsR0FBRCxDQUFLOEIsS0FBTCxFQUFZL0IsR0FBRCxDQUFLd0IsSUFBTCxDQUFYLENBQXBCLEMsWUFDTjBCLFVBQUQsQ0FBYSxrQkFBYixDLFNBWFA7QUFBQSxLQUhGIiwic291cmNlc0NvbnRlbnQiOlsiKG5zIHdpc3AuYmFja2VuZC5qYXZhc2NyaXB0LndyaXRlclxuICBcIkNvbXBpbGVyIGJhY2tlbmQgZm9yIGZvciB3cml0aW5nIEpTIG91dHB1dFwiXG4gICg6cmVxdWlyZSBbd2lzcC5hc3QgOnJlZmVyIFtuYW1lIG5hbWVzcGFjZSBzeW1ib2wgc3ltYm9sPyBrZXl3b3JkP11dXG4gICAgICAgICAgICBbd2lzcC5zZXF1ZW5jZSA6cmVmZXIgW2xpc3QgZmlyc3Qgc2Vjb25kIHRoaXJkIHJlc3QgbGlzdD9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjIG1hcCBjb3VudCBsYXN0IHJlZHVjZSBlbXB0eT9dXVxuICAgICAgICAgICAgW3dpc3AucnVudGltZSA6cmVmZXIgW3RydWU/IG5pbD8gc3RyaW5nPyBudW1iZXI/IHZlY3Rvcj9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWN0aW9uYXJ5PyBib29sZWFuPyByZS1wYXR0ZXJuP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlLWZpbmQgZGVjIHN1YnMgPV1dXG4gICAgICAgICAgICBbd2lzcC5zdHJpbmcgOnJlZmVyIFtyZXBsYWNlIGpvaW4gc3BsaXQgdXBwZXItY2FzZV1dKSlcblxuOzsgQWN0dWFsIGNvZGVcblxuKGRlZm4gd3JpdGUtcmVmZXJlbmNlXG4gIFtmb3JtXVxuICBcIlRyYW5zbGF0ZXMgcmVmZXJlbmNlcyBmcm9tIGNsb2p1cmUgY29udmVudGlvbiB0byBKUzpcblxuICAqKm1hY3JvcyoqICAgICAgX19tYWNyb3NfX1xuICBsaXN0LT52ZWN0b3IgICAgbGlzdFRvVmVjdG9yXG4gIHNldCEgICAgICAgICAgICBzZXRcbiAgZm9vX2JhciAgICAgICAgIGZvb19iYXJcbiAgbnVtYmVyPyAgICAgICAgIGlzTnVtYmVyXG4gIGNyZWF0ZS1zZXJ2ZXIgICBjcmVhdGVTZXJ2ZXJcIlxuICAobGV0IFtpZCAobmFtZSBmb3JtKV1cbiAgICAoc2V0ISBpZCAoY29uZCAoaWRlbnRpY2FsPyBpZCAgXCIqXCIpIFwibXVsdGlwbHlcIlxuICAgICAgICAgICAgICAgICAgIChpZGVudGljYWw/IGlkIFwiL1wiKSBcImRpdmlkZVwiXG4gICAgICAgICAgICAgICAgICAgKGlkZW50aWNhbD8gaWQgXCIrXCIpIFwic3VtXCJcbiAgICAgICAgICAgICAgICAgICAoaWRlbnRpY2FsPyBpZCBcIi1cIikgXCJzdWJ0cmFjdFwiXG4gICAgICAgICAgICAgICAgICAgKGlkZW50aWNhbD8gaWQgXCI9XCIpIFwiZXF1YWw/XCJcbiAgICAgICAgICAgICAgICAgICAoaWRlbnRpY2FsPyBpZCBcIj09XCIpIFwic3RyaWN0LWVxdWFsP1wiXG4gICAgICAgICAgICAgICAgICAgKGlkZW50aWNhbD8gaWQgXCI8PVwiKSBcIm5vdC1ncmVhdGVyLXRoYW5cIlxuICAgICAgICAgICAgICAgICAgIChpZGVudGljYWw/IGlkIFwiPj1cIikgXCJub3QtbGVzcy10aGFuXCJcbiAgICAgICAgICAgICAgICAgICAoaWRlbnRpY2FsPyBpZCBcIj5cIikgXCJncmVhdGVyLXRoYW5cIlxuICAgICAgICAgICAgICAgICAgIChpZGVudGljYWw/IGlkIFwiPFwiKSBcImxlc3MtdGhhblwiXG4gICAgICAgICAgICAgICAgICAgKGlkZW50aWNhbD8gaWQgXCItPlwiKSBcInRocmVhZC1maXJzdFwiXG4gICAgICAgICAgICAgICAgICAgOmVsc2UgaWQpKVxuICAgIDs7ICoqbWFjcm9zKiogLT4gIF9fbWFjcm9zX19cbiAgICAoc2V0ISBpZCAoam9pbiBcIl9cIiAoc3BsaXQgaWQgXCIqXCIpKSlcbiAgICA7OyBsaXN0LT52ZWN0b3IgLT4gIGxpc3RUb1ZlY3RvclxuICAgIChzZXQhIGlkIChqb2luIFwiLXRvLVwiIChzcGxpdCBpZCBcIi0+XCIpKSlcbiAgICA7OyBzZXQhIC0+ICBzZXRcbiAgICAoc2V0ISBpZCAoam9pbiAoc3BsaXQgaWQgXCIhXCIpKSlcbiAgICAoc2V0ISBpZCAoam9pbiBcIiRcIiAoc3BsaXQgaWQgXCIlXCIpKSlcbiAgICA7OyBmb289IC0+IGZvb0VxdWFsXG4gICAgOyhzZXQhIGlkIChqb2luIFwiLWVxdWFsLVwiIChzcGxpdCBpZCBcIj1cIikpXG4gICAgOzsgZm9vK2JhciAtPiBmb29QbHVzQmFyXG4gICAgKHNldCEgaWQgKGpvaW4gXCItcGx1cy1cIiAoc3BsaXQgaWQgXCIrXCIpKSlcbiAgICAoc2V0ISBpZCAoam9pbiBcIi1hbmQtXCIgKHNwbGl0IGlkIFwiJlwiKSkpXG4gICAgOzsgbnVtYmVyPyAtPiBpc051bWJlclxuICAgIChzZXQhIGlkIChpZiAoaWRlbnRpY2FsPyAobGFzdCBpZCkgXCI/XCIpXG4gICAgICAgICAgICAgICAoc3RyIFwiaXMtXCIgKHN1YnMgaWQgMCAoZGVjIChjb3VudCBpZCkpKSlcbiAgICAgICAgICAgICAgIGlkKSlcbiAgICA7OyBjcmVhdGUtc2VydmVyIC0+IGNyZWF0ZVNlcnZlclxuICAgIChzZXQhIGlkIChyZWR1Y2VcbiAgICAgICAgICAgICAgKGZuIFtyZXN1bHQga2V5XVxuICAgICAgICAgICAgICAgIChzdHIgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAoaWYgKGFuZCAobm90IChlbXB0eT8gcmVzdWx0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChub3QgKGVtcHR5PyBrZXkpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgKHN0ciAodXBwZXItY2FzZSAoZ2V0IGtleSAwKSkgKHN1YnMga2V5IDEpKVxuICAgICAgICAgICAgICAgICAgICAgICBrZXkpKSlcbiAgICAgICAgICAgICAgXCJcIlxuICAgICAgICAgICAgICAoc3BsaXQgaWQgXCItXCIpKSlcbiAgICBpZCkpXG5cbihkZWZuIHdyaXRlLWtleXdvcmQtcmVmZXJlbmNlXG4gIFtmb3JtXVxuICAoc3RyIFwiXFxcIlwiIChuYW1lIGZvcm0pIFwiXFxcIlwiKSlcblxuKGRlZm4gd3JpdGUta2V5d29yZCBbZm9ybV0gKHN0ciBcIlxcXCJcIiBcIlxcdUE3ODlcIiAobmFtZSBmb3JtKSBcIlxcXCJcIikpXG5cbihkZWZuIHdyaXRlLXN5bWJvbCBbZm9ybV1cbiAgKHdyaXRlIChsaXN0ICdzeW1ib2wgKG5hbWVzcGFjZSBmb3JtKSAobmFtZSBmb3JtKSkpKVxuXG4oZGVmbiB3cml0ZS1uaWwgW2Zvcm1dIFwidm9pZCgwKVwiKVxuXG4oZGVmbiB3cml0ZS1udW1iZXIgW2Zvcm1dIGZvcm0pXG5cbihkZWZuIHdyaXRlLWJvb2xlYW4gW2Zvcm1dIChpZiAodHJ1ZT8gZm9ybSkgXCJ0cnVlXCIgXCJmYWxzZVwiKSlcblxuKGRlZm4gd3JpdGUtc3RyaW5nXG4gIFtmb3JtXVxuICAoc2V0ISBmb3JtIChyZXBsYWNlIGZvcm0gKFJlZ0V4cCBcIlxcXFxcXFxcXCIgXCJnXCIpIFwiXFxcXFxcXFxcIikpXG4gIChzZXQhIGZvcm0gKHJlcGxhY2UgZm9ybSAoUmVnRXhwIFwiXFxuXCIgXCJnXCIpIFwiXFxcXG5cIikpXG4gIChzZXQhIGZvcm0gKHJlcGxhY2UgZm9ybSAoUmVnRXhwIFwiXFxyXCIgXCJnXCIpIFwiXFxcXHJcIikpXG4gIChzZXQhIGZvcm0gKHJlcGxhY2UgZm9ybSAoUmVnRXhwIFwiXFx0XCIgXCJnXCIpIFwiXFxcXHRcIikpXG4gIChzZXQhIGZvcm0gKHJlcGxhY2UgZm9ybSAoUmVnRXhwIFwiXFxcIlwiIFwiZ1wiKSBcIlxcXFxcXFwiXCIpKVxuICAoc3RyIFwiXFxcIlwiIGZvcm0gXCJcXFwiXCIpKVxuXG4oZGVmbiB3cml0ZS10ZW1wbGF0ZVxuICBcIkNvbXBpbGVzIGdpdmVuIHRlbXBsYXRlXCJcbiAgWyYgZm9ybV1cbiAgKGxldCBbaW5kZW50LXBhdHRlcm4gI1wiXFxuICokXCJcbiAgICAgICAgbGluZS1icmVhay1wYXR0ZXIgKFJlZ0V4cCBcIlxcblwiIFwiZ1wiKVxuICAgICAgICBnZXQtaW5kZW50YXRpb24gKGZuIFtjb2RlXSAob3IgKHJlLWZpbmQgaW5kZW50LXBhdHRlcm4gY29kZSkgXCJcXG5cIikpXVxuICAgIChsb29wIFtjb2RlIFwiXCJcbiAgICAgICAgICAgcGFydHMgKHNwbGl0IChmaXJzdCBmb3JtKSBcIn57fVwiKVxuICAgICAgICAgICB2YWx1ZXMgKHJlc3QgZm9ybSldXG4gICAgICAoaWYgKD4gKGNvdW50IHBhcnRzKSAxKVxuICAgICAgICAocmVjdXJcbiAgICAgICAgIChzdHJcbiAgICAgICAgICBjb2RlXG4gICAgICAgICAgKGZpcnN0IHBhcnRzKVxuICAgICAgICAgIChyZXBsYWNlIChzdHIgXCJcIiAoZmlyc3QgdmFsdWVzKSlcbiAgICAgICAgICAgICAgICAgICAgbGluZS1icmVhay1wYXR0ZXJcbiAgICAgICAgICAgICAgICAgICAgKGdldC1pbmRlbnRhdGlvbiAoZmlyc3QgcGFydHMpKSkpXG4gICAgICAgICAocmVzdCBwYXJ0cylcbiAgICAgICAgIChyZXN0IHZhbHVlcykpXG4gICAgICAgICAoc3RyIGNvZGUgKGZpcnN0IHBhcnRzKSkpKSkpXG5cblxuKGRlZm4gd3JpdGUtZ3JvdXBcbiAgWyYgZm9ybXNdXG4gIChqb2luIFwiLCBcIiBmb3JtcykpXG5cbihkZWZuIHdyaXRlLWludm9rZVxuICBbY2FsbGVlICYgcGFyYW1zXVxuICAod3JpdGUtdGVtcGxhdGUgXCJ+e30ofnt9KVwiIGNhbGxlZSAoYXBwbHkgd3JpdGUtZ3JvdXAgcGFyYW1zKSkpXG5cbihkZWZuIHdyaXRlLWVycm9yXG4gIFttZXNzYWdlXVxuICAoZm4gW10gKHRocm93IChFcnJvciBtZXNzYWdlKSkpKVxuXG4oZGVmIHdyaXRlLXZlY3RvciAod3JpdGUtZXJyb3IgXCJWZWN0b3JzIGFyZSBub3Qgc3VwcG9ydGVkXCIpKVxuKGRlZiB3cml0ZS1kaWN0aW9uYXJ5ICh3cml0ZS1lcnJvciBcIkRpY3Rpb25hcmllcyBhcmUgbm90IHN1cHBvcnRlZFwiKSlcblxuKGRlZm4tIGVzY2FwZS1wYXR0ZXJuIFtwYXR0ZXJuXVxuICAoc2V0ISBwYXR0ZXJuIChqb2luIFwiL1wiIChzcGxpdCBwYXR0ZXJuIFwiXFxcXC9cIikpKVxuICAoc2V0ISBwYXR0ZXJuIChqb2luIFwiXFxcXC9cIiAoc3BsaXQgcGF0dGVybiBcIi9cIikpKVxuICBwYXR0ZXJuKVxuXG4oZGVmbiB3cml0ZS1yZS1wYXR0ZXJuXG4gIFtmb3JtXVxuICAobGV0IFtmbGFncyAoc3RyIChpZiBmb3JtLm11bHRpbGluZSBcIm1cIiBcIlwiKVxuICAgICAgICAgICAgICAgICAgIChpZiBmb3JtLmlnbm9yZUNhc2UgXCJpXCIgXCJcIilcbiAgICAgICAgICAgICAgICAgICAoaWYgZm9ybS5zdGlja3kgXCJ5XCIgXCJcIikpXG4gICAgICAgIHBhdHRlcm4gZm9ybS5zb3VyY2VdXG4gICAgKHN0ciBcXC8gKGVzY2FwZS1wYXR0ZXJuIHBhdHRlcm4pIFxcLyBmbGFncykpKVxuXG5cbihkZWZuIGNvbXBpbGUtY29tbWVudFxuICBbZm9ybV1cbiAgKGNvbXBpbGUtdGVtcGxhdGUgKGxpc3QgXCIvL357fVxcblwiIChmaXJzdCBmb3JtKSkpKVxuXG4oZGVmbiB3cml0ZS1kZWZcbiAgXCJDcmVhdGVzIGFuZCBpbnRlcm5zIG9yIGxvY2F0ZXMgYSBnbG9iYWwgdmFyIHdpdGggdGhlIG5hbWUgb2Ygc3ltYm9sXG4gIGFuZCBhIG5hbWVzcGFjZSBvZiB0aGUgdmFsdWUgb2YgdGhlIGN1cnJlbnQgbmFtZXNwYWNlICgqbnMqKS4gSWYgaW5pdFxuICBpcyBzdXBwbGllZCwgaXQgaXMgZXZhbHVhdGVkLCBhbmQgdGhlIHJvb3QgYmluZGluZyBvZiB0aGUgdmFyIGlzIHNldFxuICB0byB0aGUgcmVzdWx0aW5nIHZhbHVlLiBJZiBpbml0IGlzIG5vdCBzdXBwbGllZCwgdGhlIHJvb3QgYmluZGluZyBvZlxuICB0aGUgdmFyIGlzIHVuYWZmZWN0ZWQuIGRlZiBhbHdheXMgYXBwbGllcyB0byB0aGUgcm9vdCBiaW5kaW5nLCBldmVuIGlmXG4gIHRoZSB2YXIgaXMgdGhyZWFkLWJvdW5kIGF0IHRoZSBwb2ludCB3aGVyZSBkZWYgaXMgY2FsbGVkLiBkZWYgeWllbGRzXG4gIHRoZSB2YXIgaXRzZWxmIChub3QgaXRzIHZhbHVlKS5cIlxuICBbZm9ybV1cbiAgKGxldCBbaWQgKGZpcnN0IGZvcm0pXG4gICAgICAgIGV4cG9ydD8gKGFuZCAoOnRvcCAob3IgKG1ldGEgZm9ybSkge30pKVxuICAgICAgICAgICAgICAgICAgICAgKG5vdCAoOnByaXZhdGUgKG9yIChtZXRhIGlkKSB7fSkpKSlcbiAgICAgICAgYXR0cmlidXRlIChzeW1ib2wgKG5hbWVzcGFjZSBpZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKHN0ciBcIi1cIiAobmFtZSBpZCkpKV1cbiAgICAoaWYgZXhwb3J0P1xuICAgICAgKGNvbXBpbGUtdGVtcGxhdGUgKGxpc3QgXCJ2YXIgfnt9O1xcbn57fVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNvbXBpbGUgKGNvbnMgJ3NldCEgZm9ybSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNvbXBpbGUgYChzZXQhICguIGV4cG9ydHMgfmF0dHJpYnV0ZSkgfmlkKSkpKVxuICAgICAgKGNvbXBpbGUtdGVtcGxhdGUgKGxpc3QgXCJ2YXIgfnt9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjb21waWxlIChjb25zICdzZXQhIGZvcm0pKSkpKSkpXG5cblxuKGRlZm4gd3JpdGUtaW5zdGFuY2U/XG4gIFwiRXZhbHVhdGVzIHggYW5kIHRlc3RzIGlmIGl0IGlzIGFuIGluc3RhbmNlIG9mIHRoZSBjbGFzc1xuICBjLiBSZXR1cm5zIHRydWUgb3IgZmFsc2VcIlxuICBbZm9ybV1cbiAgKHdyaXRlLXRlbXBsYXRlIFwifnt9IGluc3RhbmNlb2Ygfnt9XCJcbiAgICAgICAgICAgICAgICAgICh3cml0ZSAoc2Vjb25kIGZvcm0pKVxuICAgICAgICAgICAgICAgICAgKHdyaXRlIChmaXJzdCBmb3JtKSkpKVxuKGRlZm4gd3JpdGVcbiAgXCJjb21waWxlcyBnaXZlbiBmb3JtXCJcbiAgW2Zvcm1dXG4gIChjb25kXG4gICAobmlsPyBmb3JtKSAod3JpdGUtbmlsIGZvcm0pXG4gICAoc3ltYm9sPyBmb3JtKSAod3JpdGUtcmVmZXJlbmNlIGZvcm0pXG4gICAoa2V5d29yZD8gZm9ybSkgKHdyaXRlLWtleXdvcmQtcmVmZXJlbmNlIGZvcm0pXG4gICAoc3RyaW5nPyBmb3JtKSAod3JpdGUtc3RyaW5nIGZvcm0pXG4gICAobnVtYmVyPyBmb3JtKSAod3JpdGUtbnVtYmVyIGZvcm0pXG4gICAoYm9vbGVhbj8gZm9ybSkgKHdyaXRlLWJvb2xlYW4gZm9ybSlcbiAgIChyZS1wYXR0ZXJuPyBmb3JtKSAod3JpdGUtcGF0dGVybiBmb3JtKVxuICAgKHZlY3Rvcj8gZm9ybSkgKHdyaXRlLXZlY3RvciBmb3JtKVxuICAgKGRpY3Rpb25hcnk/IGZvcm0pICh3cml0ZS1kaWN0aW9uYXJ5KVxuICAgKGxpc3Q/IGZvcm0pIChhcHBseSB3cml0ZS1pbnZva2UgKG1hcCB3cml0ZSAodmVjIGZvcm0pKSlcbiAgIDplbHNlICh3cml0ZS1lcnJvciBcIlVuc3VwcG9ydGVkIGZvcm1cIikpKVxuIl19

},{"./../../ast":"ReP8Ll","./../../runtime":"wcC2X1","./../../sequence":"Mdzbzt","./../../string":"31fh9Q"}],"wisp/compiler":[function(require,module,exports){
module.exports=require('hi5qrU');
},{}],"hi5qrU":[function(require,module,exports){
{
    var _ns_ = {
            id: 'wisp.compiler',
            doc: void 0
        };
    var wisp_analyzer = require('./analyzer');
    var analyze = wisp_analyzer.analyze;
    var wisp_reader = require('./reader');
    var read_ = wisp_reader.read_;
    var read = wisp_reader.read;
    var pushBackReader = wisp_reader.pushBackReader;
    var wisp_string = require('./string');
    var replace = wisp_string.replace;
    var wisp_sequence = require('./sequence');
    var map = wisp_sequence.map;
    var reduce = wisp_sequence.reduce;
    var conj = wisp_sequence.conj;
    var cons = wisp_sequence.cons;
    var vec = wisp_sequence.vec;
    var first = wisp_sequence.first;
    var rest = wisp_sequence.rest;
    var isEmpty = wisp_sequence.isEmpty;
    var count = wisp_sequence.count;
    var wisp_runtime = require('./runtime');
    var isError = wisp_runtime.isError;
    var isEqual = wisp_runtime.isEqual;
    var wisp_ast = require('./ast');
    var name = wisp_ast.name;
    var symbol = wisp_ast.symbol;
    var prStr = wisp_ast.prStr;
    var wisp_backend_escodegen_generator = require('./backend/escodegen/generator');
    var generateJs = wisp_backend_escodegen_generator.generate;
    var base64Encode = require('base64-encode');
    var btoa = base64Encode;
}
var generate = exports.generate = generateJs;
var readForm = exports.readForm = function readForm(reader, eof) {
        return (function () {
            try {
                return read(reader, false, eof, false);
            } catch (error) {
                return error;
            }
        })();
    };
var readForms = exports.readForms = function readForms(source, uri) {
        return function () {
            var readerø1 = pushBackReader(source, uri);
            var eofø1 = {};
            return function loop() {
                var recur = loop;
                var formsø1 = [];
                var formø1 = readForm(readerø1, eofø1);
                do {
                    recur = isError(formø1) ? {
                        'forms': formsø1,
                        'error': formø1
                    } : formø1 === eofø1 ? { 'forms': formsø1 } : 'else' ? (loop[0] = conj(formsø1, formø1), loop[1] = readForm(readerø1, eofø1), loop) : void 0;
                } while (formsø1 = loop[0], formø1 = loop[1], recur === loop);
                return recur;
            }.call(this);
        }.call(this);
    };
var analyzeForm = exports.analyzeForm = function analyzeForm(env, form) {
        return (function () {
            try {
                return analyze(env, form);
            } catch (error) {
                return error;
            }
        })();
    };
var analyzeForms = exports.analyzeForms = function analyzeForms(forms) {
        return function loop() {
            var recur = loop;
            var nodesø1 = [];
            var formsø2 = forms;
            var envø1 = {
                    'locals': {},
                    'bindings': [],
                    'top': true,
                    'ns': { 'name': symbol(void 0, 'user.wisp') }
                };
            do {
                recur = function () {
                    var nodeø1 = analyzeForm(envø1, first(formsø2));
                    var nsø1 = isEqual((nodeø1 || 0)['op'], 'ns') ? nodeø1 : (envø1 || 0)['ns'];
                    return isError(nodeø1) ? {
                        'ast': nodesø1,
                        'error': nodeø1
                    } : count(formsø2) <= 1 ? { 'ast': conj(nodesø1, nodeø1) } : 'else' ? (loop[0] = conj(nodesø1, nodeø1), loop[1] = rest(formsø2), loop[2] = conj(envø1, { 'ns': nsø1 }), loop) : void 0;
                }.call(this);
            } while (nodesø1 = loop[0], formsø2 = loop[1], envø1 = loop[2], recur === loop);
            return recur;
        }.call(this);
    };
var compile = exports.compile = function compile() {
        switch (arguments.length) {
        case 1:
            var source = arguments[0];
            return compile(source, {});
        case 2:
            var source = arguments[0];
            var options = arguments[1];
            return function () {
                var sourceUriø1 = (options || 0)['source-uri'] || name('anonymous.wisp');
                var formsø1 = readForms(source, sourceUriø1);
                var astø1 = (formsø1 || 0)['error'] ? formsø1 : analyzeForms((formsø1 || 0)['forms']);
                var outputø1 = (astø1 || 0)['error'] ? astø1 : (function () {
                        try {
                            return generate.apply(void 0, vec(cons(conj(options, {
                                'source': source,
                                'source-uri': sourceUriø1
                            }), (astø1 || 0)['ast'])));
                        } catch (error) {
                            return { 'error': error };
                        }
                    })();
                var expansionø1 = 'expansion' === (options || 0)['print'] ? reduce(function (result, item) {
                        return '' + result + prStr(item.form) + '\n';
                    }, '', astø1.ast) : void 0;
                var resultø1 = {
                        'source-uri': sourceUriø1,
                        'ast': (astø1 || 0)['ast'],
                        'forms': (formsø1 || 0)['forms'],
                        'expansion': expansionø1
                    };
                return conj(options, outputø1, resultø1);
            }.call(this);
        default:
            throw RangeError('Wrong number of arguments passed');
        }
    };
var evaluate = exports.evaluate = function evaluate(source) {
        return function () {
            var outputø1 = compile(source);
            return (outputø1 || 0)['error'] ? (function () {
                throw (outputø1 || 0)['error'];
            })() : eval((outputø1 || 0)['code']);
        }.call(this);
    };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFub255bW91cy53aXNwIl0sIm5hbWVzIjpbIl9uc18iLCJpZCIsImRvYyIsImFuYWx5emUiLCJyZWFkXyIsInJlYWQiLCJwdXNoQmFja1JlYWRlciIsInJlcGxhY2UiLCJtYXAiLCJyZWR1Y2UiLCJjb25qIiwiY29ucyIsInZlYyIsImZpcnN0IiwicmVzdCIsImlzRW1wdHkiLCJjb3VudCIsImlzRXJyb3IiLCJpc0VxdWFsIiwibmFtZSIsInN5bWJvbCIsInByU3RyIiwiZ2VuZXJhdGVKcyIsImdlbmVyYXRlIiwiZXhwb3J0cyIsInJlYWRGb3JtIiwicmVhZGVyIiwiZW9mIiwiZXJyb3IiLCJyZWFkRm9ybXMiLCJzb3VyY2UiLCJ1cmkiLCJyZWFkZXLDuDEiLCJlb2bDuDEiLCJmb3Jtc8O4MSIsImZvcm3DuDEiLCJhbmFseXplRm9ybSIsImVudiIsImZvcm0iLCJhbmFseXplRm9ybXMiLCJmb3JtcyIsIm5vZGVzw7gxIiwiZm9ybXPDuDIiLCJlbnbDuDEiLCJub2Rlw7gxIiwibnPDuDEiLCJjb21waWxlIiwib3B0aW9ucyIsInNvdXJjZVVyacO4MSIsImFzdMO4MSIsIm91dHB1dMO4MSIsImV4cGFuc2lvbsO4MSIsInJlc3VsdCIsIml0ZW0iLCJhc3QiLCJyZXN1bHTDuDEiLCJldmFsdWF0ZSIsImV2YWwiXSwibWFwcGluZ3MiOiI7SUFBQSxJQUFDQSxJLEdBQUQ7QUFBQSxZQUFBQyxFLEVBQUksZUFBSjtBQUFBLFlBQUFDLEcsRUFBQSxLLENBQUE7QUFBQSxVOztRQUNtQ0MsT0FBQSxHLGNBQUFBLE87O1FBQ0ZDLEtBQUEsRyxZQUFBQSxLO1FBQU1DLElBQUEsRyxZQUFBQSxJO1FBQUtDLGNBQUEsRyxZQUFBQSxjOztRQUNYQyxPQUFBLEcsWUFBQUEsTzs7UUFDRUMsR0FBQSxHLGNBQUFBLEc7UUFBSUMsTUFBQSxHLGNBQUFBLE07UUFBT0MsSUFBQSxHLGNBQUFBLEk7UUFBS0MsSUFBQSxHLGNBQUFBLEk7UUFBS0MsR0FBQSxHLGNBQUFBLEc7UUFBSUMs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USxNQUFQLEMsTUFBQSxDQUFOLENBRkYsQ0FESTtBQUFBLFMsS0FBTixDLElBQUE7QUFBQSxLQUZGIiwic291cmNlc0NvbnRlbnQiOlsiKG5zIHdpc3AuY29tcGlsZXJcbiAgKDpyZXF1aXJlIFt3aXNwLmFuYWx5emVyIDpyZWZlciBbYW5hbHl6ZV1dXG4gICAgICAgICAgICBbd2lzcC5yZWFkZXIgOnJlZmVyIFtyZWFkKiByZWFkIHB1c2gtYmFjay1yZWFkZXJdXVxuICAgICAgICAgICAgW3dpc3Auc3RyaW5nIDpyZWZlciBbcmVwbGFjZV1dXG4gICAgICAgICAgICBbd2lzcC5zZXF1ZW5jZSA6cmVmZXIgW21hcCByZWR1Y2UgY29uaiBjb25zIHZlYyBmaXJzdCByZXN0IGVtcHR5PyBjb3VudF1dXG4gICAgICAgICAgICBbd2lzcC5ydW50aW1lIDpyZWZlciBbZXJyb3I/ID1dXVxuICAgICAgICAgICAgW3dpc3AuYXN0IDpyZWZlciBbbmFtZSBzeW1ib2wgcHItc3RyXV1cblxuICAgICAgICAgICAgW3dpc3AuYmFja2VuZC5lc2NvZGVnZW4uZ2VuZXJhdG9yIDpyZWZlciBbZ2VuZXJhdGVdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOnJlbmFtZSB7Z2VuZXJhdGUgZ2VuZXJhdGUtanN9XVxuICAgICAgICAgICAgW2Jhc2U2NC1lbmNvZGUgOmFzIGJ0b2FdKSlcblxuKGRlZiBnZW5lcmF0ZSBnZW5lcmF0ZS1qcylcblxuKGRlZm4gcmVhZC1mb3JtXG4gIFtyZWFkZXIgZW9mXVxuICAodHJ5IChyZWFkIHJlYWRlciBmYWxzZSBlb2YgZmFsc2UpXG4gICAgKGNhdGNoIGVycm9yIGVycm9yKSkpXG5cbihkZWZuIHJlYWQtZm9ybXNcbiAgW3NvdXJjZSB1cmldXG4gIChsZXQgW3JlYWRlciAocHVzaC1iYWNrLXJlYWRlciBzb3VyY2UgdXJpKVxuICAgICAgICBlb2Yge31dXG4gICAgKGxvb3AgW2Zvcm1zIFtdXG4gICAgICAgICAgIGZvcm0gKHJlYWQtZm9ybSByZWFkZXIgZW9mKV1cbiAgICAgIChjb25kIChlcnJvcj8gZm9ybSkgezpmb3JtcyBmb3JtcyA6ZXJyb3IgZm9ybX1cbiAgICAgICAgICAgIChpZGVudGljYWw/IGZvcm0gZW9mKSB7OmZvcm1zIGZvcm1zfVxuICAgICAgICAgICAgOmVsc2UgKHJlY3VyIChjb25qIGZvcm1zIGZvcm0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgKHJlYWQtZm9ybSByZWFkZXIgZW9mKSkpKSkpXG5cbihkZWZuIGFuYWx5emUtZm9ybVxuICBbZW52IGZvcm1dXG4gICh0cnkgKGFuYWx5emUgZW52IGZvcm0pIChjYXRjaCBlcnJvciBlcnJvcikpKVxuXG4oZGVmbiBhbmFseXplLWZvcm1zXG4gIFtmb3Jtc11cbiAgKGxvb3AgW25vZGVzIFtdXG4gICAgICAgICBmb3JtcyBmb3Jtc1xuICAgICAgICAgZW52IHs6bG9jYWxzIHt9XG4gICAgICAgICAgICAgIDpiaW5kaW5ncyBbXVxuICAgICAgICAgICAgICA6dG9wIHRydWVcbiAgICAgICAgICAgICAgOm5zIHs6bmFtZSAndXNlci53aXNwfX1dXG4gICAgKGxldCBbbm9kZSAoYW5hbHl6ZS1mb3JtIGVudiAoZmlyc3QgZm9ybXMpKVxuICAgICAgICAgIG5zIChpZiAoPSAoOm9wIG5vZGUpIDpucylcbiAgICAgICAgICAgICAgIG5vZGVcbiAgICAgICAgICAgICAgICg6bnMgZW52KSldXG4gICAgICAoY29uZCAoZXJyb3I/IG5vZGUpIHs6YXN0IG5vZGVzIDplcnJvciBub2RlfVxuICAgICAgICAgICAgKDw9IChjb3VudCBmb3JtcykgMSkgezphc3QgKGNvbmogbm9kZXMgbm9kZSl9XG4gICAgICAgICAgICA6ZWxzZSAocmVjdXIgKGNvbmogbm9kZXMgbm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAocmVzdCBmb3JtcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAoY29uaiBlbnYgezpucyBuc30pKSkpKSlcblxuKGRlZm4gY29tcGlsZVxuICBcIkNvbXBpbGVyIHRha2VzIHdpc3AgY29kZSBpbiBmb3JtIG9mIHN0cmluZyBhbmQgcmV0dXJucyBhIGhhc2hcbiAgY29udGFpbmluZyBgOnNvdXJjZWAgcmVwcmVzZW50aW5nIGNvbXBpbGF0aW9uIHJlc3VsdC4gSWZcbiAgYCg6c291cmNlLW1hcCBvcHRpb25zKWAgaXMgYHRydWVgIHRoZW4gYDpzb3VyY2UtbWFwYCBvZiB0aGUgcmV0dXJuZWRcbiAgaGFzaCB3aWxsIGNvbnRhaW4gc291cmNlIG1hcCBmb3IgaXQuXG4gIDpvdXRwdXQtdXJpXG4gIDpzb3VyY2UtbWFwLXVyaVxuXG4gIFJldHVybnMgaGFzaCB3aXRoIGZvbGxvd2luZyBmaWVsZHM6XG5cbiAgOmNvZGUgLSBHZW5lcmF0ZWQgY29kZS5cblxuICA6c291cmNlLW1hcCAtIEdlbmVyYXRlZCBzb3VyY2UgbWFwLiBPbmx5IGlmICg6c291cmNlLW1hcCBvcHRpb25zKVxuICAgICAgICAgICAgICAgIHdhcyB0cnVlLlxuXG4gIDpvdXRwdXQtdXJpIC0gUmV0dXJucyBiYWNrICg6b3V0cHV0LXVyaSBvcHRpb25zKSBpZiB3YXMgcGFzc2VkIGluLFxuICAgICAgICAgICAgICAgIG90aGVyd2lzZSBjb21wdXRlcyBvbmUgZnJvbSAoOnNvdXJjZS11cmkgb3B0aW9ucykgYnlcbiAgICAgICAgICAgICAgICBjaGFuZ2luZyBmaWxlIGV4dGVuc2lvbi5cblxuICA6c291cmNlLW1hcC11cmkgLSBSZXR1cm5zIGJhY2sgKDpzb3VyY2UtbWFwLXVyaSBvcHRpb25zKSBpZiB3YXMgcGFzc2VkXG4gICAgICAgICAgICAgICAgICAgIGluLCBvdGhlcndpc2UgY29tcHV0ZXMgb25lIGZyb20gKDpzb3VyY2UtdXJpIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgIGJ5IGFkZGluZyBgLm1hcGAgZmlsZSBleHRlbnNpb24uXCJcbiAgKFtzb3VyY2VdIChjb21waWxlIHNvdXJjZSB7fSkpXG4gIChbc291cmNlIG9wdGlvbnNdXG4gICAobGV0IFtzb3VyY2UtdXJpIChvciAoOnNvdXJjZS11cmkgb3B0aW9ucykgKG5hbWUgOmFub255bW91cy53aXNwKSkgOzsgSEFDSzogV29ya2Fyb3VuZCBmb3Igc2VnZmF1bHQgIzY2OTFcbiAgICAgICAgIGZvcm1zIChyZWFkLWZvcm1zIHNvdXJjZSBzb3VyY2UtdXJpKVxuXG4gICAgICAgICBhc3QgKGlmICg6ZXJyb3IgZm9ybXMpXG4gICAgICAgICAgICAgICBmb3Jtc1xuICAgICAgICAgICAgICAgKGFuYWx5emUtZm9ybXMgKDpmb3JtcyBmb3JtcykpKVxuXG4gICAgICAgICBvdXRwdXQgKGlmICg6ZXJyb3IgYXN0KVxuICAgICAgICAgICAgICAgICAgYXN0XG4gICAgICAgICAgICAgICAgICAodHJ5ICAgICAgICAgICAgICA7OyBUT0RPOiBSZW1vdmUgdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOzsgT2xkIGNvbXBpbGVyIGhhcyBpbmNvcnJlY3QgYXBwbHkuXG4gICAgICAgICAgICAgICAgICAgIChhcHBseSBnZW5lcmF0ZSAodmVjIChjb25zIChjb25qIG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgezpzb3VyY2Ugc291cmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6c291cmNlLXVyaSBzb3VyY2UtdXJpfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKDphc3QgYXN0KSkpKVxuICAgICAgICAgICAgICAgICAgICAoY2F0Y2ggZXJyb3IgezplcnJvciBlcnJvcn0pKSlcblxuICAgICAgICAgZXhwYW5zaW9uIChpZiAoaWRlbnRpY2FsPyA6ZXhwYW5zaW9uICg6cHJpbnQgb3B0aW9ucykpXG4gICAgICAgICAgICAgICAgICAgICAocmVkdWNlIChmbiBbcmVzdWx0IGl0ZW1dXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHN0ciByZXN1bHQgKHByLXN0ciAoLi1mb3JtIGl0ZW0pKSBcIlxcblwiKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlwiICguLWFzdCBhc3QpKSlcblxuICAgICAgICAgcmVzdWx0IHs6c291cmNlLXVyaSBzb3VyY2UtdXJpXG4gICAgICAgICAgICAgICAgIDphc3QgKDphc3QgYXN0KVxuICAgICAgICAgICAgICAgICA6Zm9ybXMgKDpmb3JtcyBmb3JtcylcbiAgICAgICAgICAgICAgICAgOmV4cGFuc2lvbiBleHBhbnNpb259XVxuICAgICAoY29uaiBvcHRpb25zIG91dHB1dCByZXN1bHQpKSkpXG5cbihkZWZuIGV2YWx1YXRlXG4gIFtzb3VyY2VdXG4gIChsZXQgW291dHB1dCAoY29tcGlsZSBzb3VyY2UpXVxuICAgIChpZiAoOmVycm9yIG91dHB1dClcbiAgICAgICh0aHJvdyAoOmVycm9yIG91dHB1dCkpXG4gICAgICAoZXZhbCAoOmNvZGUgb3V0cHV0KSkpKSlcbiJdfQ==

},{"./analyzer":"6TzXFU","./ast":"ReP8Ll","./backend/escodegen/generator":5,"./reader":"vmsNNR","./runtime":"wcC2X1","./sequence":"Mdzbzt","./string":"31fh9Q","base64-encode":16}],"wisp/engine/browser":[function(require,module,exports){
module.exports=require('mP4Wz8');
},{}],"mP4Wz8":[function(require,module,exports){
{
    var _ns_ = {
            id: 'runner.main',
            doc: void 0
        };
    var wisp_compiler = require('wisp/compiler');
    var compile = wisp_compiler.compile;
}
var _wisp_runtime = exports._wisp_runtime = require('../runtime.js');
var _wisp_sequence = exports._wisp_sequence = require('../sequence.js');
var _wisp_string = exports._wisp_string = require('../string.js');
var fetchSource = exports.fetchSource = function fetchSource(src, callback) {
        return function () {
            var xhrø1 = new XMLHttpRequest();
            xhrø1.open('GET', src, true);
            xhrø1.addEventListener('load', function (ev) {
                return xhrø1.status >= 200 && xhrø1.status < 300 ? callback(xhrø1.responseText) : console.error(xhrø1.statusText);
            }, false);
            xhrø1.overrideMimeType ? xhrø1.overrideMimeType('text/plain') : void 0;
            xhrø1.setRequestHeader('If-Modified-Since', 'Fri, 01 Jan 1960 00:00:00 GMT');
            return xhrø1.send(null);
        }.call(this);
    };
var runWispCode = exports.runWispCode = function runWispCode(code, url) {
        return function () {
            var resultø1 = compile(code, { 'source-uri': url || 'inline' });
            var errorø1 = (resultø1 || 0)['error'];
            return errorø1 ? console.error(errorø1) : Function(eval((resultø1 || 0)['code']))();
        }.call(this);
    };
var fetchAndRunWispCode = exports.fetchAndRunWispCode = function fetchAndRunWispCode(url) {
        return fetchSource(url, function (code) {
            return runWispCode(code, url);
        });
    };
var __main__ = exports.__main__ = function __main__(ev) {
        [
            _wisp_runtime,
            _wisp_sequence,
            _wisp_string
        ].map(function (f) {
            return Object.keys(f).map(function (k) {
                return (window || 0)[k] = (f || 0)[k];
            });
        });
        return function () {
            var scriptsø1 = document.getElementsByTagName('script');
            return function loop() {
                var recur = loop;
                var xø1 = 0;
                do {
                    recur = xø1 < scriptsø1.length ? function () {
                        var scriptø1 = (scriptsø1 || 0)[xø1];
                        var sourceø1 = scriptø1.src;
                        var contentø1 = scriptø1.text;
                        var contentTypeø1 = scriptø1.type;
                        contentTypeø1 == 'application/wisp' ? (function () {
                            sourceø1 ? fetchAndRunWispCode(sourceø1) : void 0;
                            return contentø1 ? runWispCode(contentø1, sourceø1) : void 0;
                        })() : void 0;
                        return loop[0] = xø1 + 1, loop;
                    }.call(this) : void 0;
                } while (xø1 = loop[0], recur === loop);
                return recur;
            }.call(this);
        }.call(this);
    };
window.addEventListener('load', __main__, false);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFub255bW91cy53aXNwIl0sIm5hbWVzIjpbIl9uc18iLCJpZCIsImRvYyIsImNvbXBpbGUiLCJfd2lzcF9ydW50aW1lIiwiZXhwb3J0cyIsInJlcXVpcmUiLCJfd2lzcF9zZXF1ZW5jZSIsIl93aXNwX3N0cmluZyIsImZldGNoU291cmNlIiwic3JjIiwiY2FsbGJhY2siLCJ4aHLDuDEiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJhZGRFdmVudExpc3RlbmVyIiwiZXYiLCJzdGF0dXMiLCJyZXNwb25zZVRleHQiLCJjb25zb2xlIiwiZXJyb3IiLCJzdGF0dXNUZXh0Iiwib3ZlcnJpZGVNaW1lVHlwZSIsInNldFJlcXVlc3RIZWFkZXIiLCJzZW5kIiwibnVsbCIsInJ1bldpc3BDb2RlIiwiY29kZSIsInVybCIsInJlc3VsdMO4MSIsImVycm9yw7gxIiwiRnVuY3Rpb24iLCJldmFsIiwiZmV0Y2hBbmRSdW5XaXNwQ29kZSIsIl9fbWFpbl9fIiwibWFwIiwiZiIsIk9iamVjdCIsImtleXMiLCJrIiwid2luZG93Iiwic2NyaXB0c8O4MSIsImRvY3VtZW50IiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJ4w7gxIiwibGVuZ3RoIiwic2NyaXB0w7gxIiwic291cmNlw7gxIiwiY29udGVudMO4MSIsInRleHQiLCJjb250ZW50VHlwZcO4MSIsInR5cGUiXSwibWFwcGluZ3MiOiI7SUFBQSxJQUFDQSxJLEdBQUQ7QUFBQSxZQUFBQyxFLEVBQUksYUFBSjtBQUFBLFlBQUFDLEcsRUFBQSxLLENBQUE7QUFBQSxVOztRQUNtQ0MsT0FBQSxHLGNBQUFBLE87O0FBRW5DLElBQUtDLGFBQUEsR0FBQUMsT0FBQSxDQUFBRCxhQUFBLEdBQWVFLE9BQUQsQ0FBUyxlQUFULENBQW5CLEM7QUFDQSxJQUFLQyxjQUFBLEdBQUFGLE9BQUEsQ0FBQUUsY0FBQSxHQUFnQkQsT0FBRCxDQUFTLGdCQUFULENBQXBCLEM7QUFDQSxJQUFLRSxZQUFBLEdBQUFILE9BQUEsQ0FBQUcsWUFBQSxH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UDtBQUFBLHdCQUNBLElBQUFHLFEsR0FBY0QsUUFBUCxDQUFHcEMsR0FBVixDQURBO0FBQUEsd0JBRUEsSUFBQXNDLFMsR0FBZ0JGLFFBQVIsQ0FBR0csSUFBWCxDQUZBO0FBQUEsd0JBR0EsSUFBQUMsYSxHQUFxQkosUUFBUixDQUFHSyxJQUFoQixDQUhBO0FBQUEsd0JBUUlELGFBQUosSUFBaUIsa0JBQXJCLEcsYUFFSTtBQUFBLDRCQUFJSCxRQUFKLEdBQ0dkLG1CQUFELENBQXlCYyxRQUF6QixDQURGLEcsTUFBQTtBQUFBLDRCQUVBLE9BQUlDLFNBQUosR0FDR3RCLFdBQUQsQ0FBZXNCLFNBQWYsRUFBdUJELFFBQXZCLENBREYsRyxNQUFBLENBRkE7QUFBQSx5QixDQUFBLEVBRkosRyxNQUFBLENBUkk7QUFBQSx3QkFjSixPLFVBQVVILEdBQUgsR0FBSyxDQUFaLEUsSUFBQSxDQWRJO0FBQUEscUIsS0FBTixDLElBQUEsQ0FERixHO3lCQUZLQSxHOztrQkFBUCxDLElBQUEsRUFESTtBQUFBLFMsS0FBTixDLElBQUEsRUFQQTtBQUFBLEtBRkYsQztBQTZCbUJKLE1BQWxCLENBQUN6QixnQkFBRixDQUEwQixNQUExQixFQUFpQ21CLFFBQWpDLEUsS0FBQSIsInNvdXJjZXNDb250ZW50IjpbIihucyBydW5uZXIubWFpblxuICAoOnJlcXVpcmUgW3dpc3AuY29tcGlsZXIgOnJlZmVyIFtjb21waWxlXV0pKVxuXG4oZGVmIF93aXNwX3J1bnRpbWUgKHJlcXVpcmUgXCIuLi9ydW50aW1lLmpzXCIpKVxuKGRlZiBfd2lzcF9zZXF1ZW5jZSAocmVxdWlyZSBcIi4uL3NlcXVlbmNlLmpzXCIpKVxuKGRlZiBfd2lzcF9zdHJpbmcgKHJlcXVpcmUgXCIuLi9zdHJpbmcuanNcIikpXG5cbihkZWZuIGZldGNoLXNvdXJjZSBbc3JjIGNhbGxiYWNrXVxuICAobGV0IFt4aHIgKG5ldyBYTUxIdHRwUmVxdWVzdCldXG4gICAgOyguYWRkRXZlbnRMaXN0ZW5lciB4aHIgXCJ0aW1lb3V0XCIgKGZuIFtldl0gKGNvbnNvbGUubG9nIFwiVGltZW91dCBsb2FkaW5nXCIgc3JjKSkgZmFsc2UpXG4gICAgKC5vcGVuIHhociBcIkdFVFwiIHNyYyB0cnVlKVxuICAgICguYWRkRXZlbnRMaXN0ZW5lciB4aHIgXCJsb2FkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgKGZuIFtldl1cbiAgICAgICAgICAgICAgICAgICAgICAgICAoaWYgKGFuZCAoPj0geGhyLnN0YXR1cyAyMDApICg8IHhoci5zdGF0dXMgMzAwKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChjYWxsYmFjayB4aHIucmVzcG9uc2VUZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNvbnNvbGUuZXJyb3IgeGhyLnN0YXR1c1RleHQpKSkgZmFsc2UpXG4gICAgOyhzZXQhICguLXRpbWVvdXQgeGhyKSAzMClcbiAgICAoaWYgeGhyLm92ZXJyaWRlTWltZVR5cGVcbiAgICAgICh4aHIub3ZlcnJpZGVNaW1lVHlwZSBcInRleHQvcGxhaW5cIikpXG4gICAgKHhoci5zZXRSZXF1ZXN0SGVhZGVyIFwiSWYtTW9kaWZpZWQtU2luY2VcIiBcIkZyaSwgMDEgSmFuIDE5NjAgMDA6MDA6MDAgR01UXCIpXG4gICAgKC5zZW5kIHhociBudWxsKSkpXG5cbihkZWZuIHJ1bi13aXNwLWNvZGUgW2NvZGUgdXJsXVxuICAobGV0IFtyZXN1bHQgKGNvbXBpbGUgY29kZSB7OnNvdXJjZS11cmkgKG9yIHVybCBcImlubGluZVwiKX0pXG4gICAgICAgIGVycm9yICg6ZXJyb3IgcmVzdWx0KV1cbiAgICAoaWYgZXJyb3JcbiAgICAgIChjb25zb2xlLmVycm9yIGVycm9yKVxuICAgICAgKChGdW5jdGlvbiAoZXZhbCAoOmNvZGUgcmVzdWx0KSkpKSkpKVxuXG4oZGVmbiBmZXRjaC1hbmQtcnVuLXdpc3AtY29kZSBbdXJsXVxuICAoZmV0Y2gtc291cmNlIHVybFxuICAgICAgICAgICAgICAgIChmbiBbY29kZV1cbiAgICAgICAgICAgICAgICAgIChydW4td2lzcC1jb2RlIGNvZGUgdXJsKSkpKVxuXG4oZGVmbiBfX21haW5fXyBbZXZdXG4gIDsgaG9pc3Qgd2lzcCBidWlsdGlucyBpbnRvIHRoZSBnbG9iYWwgd2luZG93IGNvbnRleHRcbiAgKC5tYXAgW193aXNwX3J1bnRpbWUgX3dpc3Bfc2VxdWVuY2UgX3dpc3Bfc3RyaW5nXVxuICAgICAgICAoZm4gW2ZdXG4gICAgICAgICAgKC5tYXAgKC5rZXlzIE9iamVjdCBmKVxuICAgICAgICAgICAgICAgIChmbiBba11cbiAgICAgICAgICAgICAgICAgIChzZXQhIChnZXQgd2luZG93IGspIChnZXQgZiBrKSkpKSkpXG4gIDsoY29uc29sZS5sb2cgXCJydW5uaW5nIF9fbWFpbl9fXCIpXG4gIDsgZmluZCBhbGwgdGhlIHNjcmlwdCB0YWdzIG9uIHRoZSBwYWdlXG4gIChsZXQgW3NjcmlwdHMgKGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lIFwic2NyaXB0XCIpXVxuICAgIChsb29wIFt4IDBdXG4gICAgICA7IGxvb3AgdGhyb3VnaCBldmVyeSBzY3JpcHQgdGFnXG4gICAgICAoaWYgKDwgeCBzY3JpcHRzLmxlbmd0aClcbiAgICAgICAgKGxldCBbc2NyaXB0IChnZXQgc2NyaXB0cyB4KVxuICAgICAgICAgICAgICBzb3VyY2UgKC4tc3JjIHNjcmlwdClcbiAgICAgICAgICAgICAgY29udGVudCAoLi10ZXh0IHNjcmlwdClcbiAgICAgICAgICAgICAgY29udGVudC10eXBlICguLXR5cGUgc2NyaXB0KV1cbiAgICAgICAgICA7KGNvbnNvbGUubG9nIFwic3JjOlwiICguLXNyYyBzY3JpcHQpKVxuICAgICAgICAgIDsoY29uc29sZS5sb2cgXCJ0eXBlOlwiICguLXR5cGUgc2NyaXB0KSlcbiAgICAgICAgICA7KGNvbnNvbGUubG9nIFwiY29udGVudDpcIiAoLi10ZXh0IHNjcmlwdCkpXG4gICAgICAgICAgOyBpZiB0aGUgc2NyaXB0IHRhZyBoYXMgYXBwbGljYXRpb24vd2lzcCBhcyB0aGUgdHlwZSB0aGVuIHJ1biBpdFxuICAgICAgICAgIChpZiAoPT0gY29udGVudC10eXBlIFwiYXBwbGljYXRpb24vd2lzcFwiKVxuICAgICAgICAgICAgKGRvXG4gICAgICAgICAgICAgIChpZiBzb3VyY2VcbiAgICAgICAgICAgICAgICAoZmV0Y2gtYW5kLXJ1bi13aXNwLWNvZGUgc291cmNlKSlcbiAgICAgICAgICAgICAgKGlmIGNvbnRlbnRcbiAgICAgICAgICAgICAgICAocnVuLXdpc3AtY29kZSBjb250ZW50IHNvdXJjZSkpKSlcbiAgICAgICAgICAocmVjdXIgKCsgeCAxKSkpKSkpKVxuXG4oLmFkZEV2ZW50TGlzdGVuZXIgd2luZG93IFwibG9hZFwiIF9fbWFpbl9fIGZhbHNlKVxuIl19

},{"../runtime.js":"wcC2X1","../sequence.js":"Mdzbzt","../string.js":"31fh9Q","wisp/compiler":"hi5qrU"}],"wisp/expander":[function(require,module,exports){
module.exports=require('RaoPh2');
},{}],"RaoPh2":[function(require,module,exports){
{
    var _ns_ = {
            id: 'wisp.expander',
            doc: 'wisp syntax and macro expander module'
        };
    var wisp_ast = require('./ast');
    var meta = wisp_ast.meta;
    var withMeta = wisp_ast.withMeta;
    var isSymbol = wisp_ast.isSymbol;
    var isKeyword = wisp_ast.isKeyword;
    var isQuote = wisp_ast.isQuote;
    var symbol = wisp_ast.symbol;
    var namespace = wisp_ast.namespace;
    var name = wisp_ast.name;
    var isUnquote = wisp_ast.isUnquote;
    var isUnquoteSplicing = wisp_ast.isUnquoteSplicing;
    var wisp_sequence = require('./sequence');
    var isList = wisp_sequence.isList;
    var list = wisp_sequence.list;
    var conj = wisp_sequence.conj;
    var partition = wisp_sequence.partition;
    var seq = wisp_sequence.seq;
    var isEmpty = wisp_sequence.isEmpty;
    var map = wisp_sequence.map;
    var vec = wisp_sequence.vec;
    var isEvery = wisp_sequence.isEvery;
    var concat = wisp_sequence.concat;
    var first = wisp_sequence.first;
    var second = wisp_sequence.second;
    var third = wisp_sequence.third;
    var rest = wisp_sequence.rest;
    var last = wisp_sequence.last;
    var butlast = wisp_sequence.butlast;
    var interleave = wisp_sequence.interleave;
    var cons = wisp_sequence.cons;
    var count = wisp_sequence.count;
    var some = wisp_sequence.some;
    var assoc = wisp_sequence.assoc;
    var reduce = wisp_sequence.reduce;
    var filter = wisp_sequence.filter;
    var isSeq = wisp_sequence.isSeq;
    var lazySeq = wisp_sequence.lazySeq;
    var wisp_runtime = require('./runtime');
    var isNil = wisp_runtime.isNil;
    var isDictionary = wisp_runtime.isDictionary;
    var isVector = wisp_runtime.isVector;
    var keys = wisp_runtime.keys;
    var vals = wisp_runtime.vals;
    var isString = wisp_runtime.isString;
    var isNumber = wisp_runtime.isNumber;
    var isBoolean = wisp_runtime.isBoolean;
    var isDate = wisp_runtime.isDate;
    var isRePattern = wisp_runtime.isRePattern;
    var isEven = wisp_runtime.isEven;
    var isEqual = wisp_runtime.isEqual;
    var max = wisp_runtime.max;
    var inc = wisp_runtime.inc;
    var dec = wisp_runtime.dec;
    var dictionary = wisp_runtime.dictionary;
    var subs = wisp_runtime.subs;
    var wisp_string = require('./string');
    var split = wisp_string.split;
}
var __macros__ = exports.__macros__ = {};
var expand = function expand(expander, form, env) {
    return function () {
        var metadataø1 = meta(form) || {};
        var parmasø1 = rest(form);
        var implicitø1 = map(function ($1) {
                return isEqual('&form', $1) ? form : isEqual('&env', $1) ? env : 'else' ? $1 : void 0;
            }, (meta(expander) || 0)['implicit'] || []);
        var paramsø1 = vec(concat(implicitø1, vec(rest(form))));
        var expansionø1 = expander.apply(void 0, paramsø1);
        return expansionø1 ? withMeta(expansionø1, conj(metadataø1, meta(expansionø1))) : expansionø1;
    }.call(this);
};
var installMacro = exports.installMacro = function installMacro(op, expander) {
        return (__macros__ || 0)[name(op)] = expander;
    };
var macro = function macro(op) {
    return isSymbol(op) && (__macros__ || 0)[name(op)];
};
var isMethodSyntax = exports.isMethodSyntax = function isMethodSyntax(op) {
        return function () {
            var idø1 = isSymbol(op) && name(op);
            return idø1 && '.' === first(idø1) && !('-' === second(idø1)) && !('.' === idø1);
        }.call(this);
    };
var isFieldSyntax = exports.isFieldSyntax = function isFieldSyntax(op) {
        return function () {
            var idø1 = isSymbol(op) && name(op);
            return idø1 && '.' === first(idø1) && '-' === second(idø1);
        }.call(this);
    };
var isNewSyntax = exports.isNewSyntax = function isNewSyntax(op) {
        return function () {
            var idø1 = isSymbol(op) && name(op);
            return idø1 && '.' === last(idø1) && !('.' === idø1);
        }.call(this);
    };
var methodSyntax = exports.methodSyntax = function methodSyntax(op, target) {
        var params = Array.prototype.slice.call(arguments, 2);
        return function () {
            var opMetaø1 = meta(op);
            var formStartø1 = (opMetaø1 || 0)['start'];
            var targetMetaø1 = meta(target);
            var memberø1 = withMeta(symbol(subs(name(op), 1)), conj(opMetaø1, {
                    'start': {
                        'line': (formStartø1 || 0)['line'],
                        'column': inc((formStartø1 || 0)['column'])
                    }
                }));
            var agetø1 = withMeta(symbol(void 0, 'aget'), conj(opMetaø1, {
                    'end': {
                        'line': (formStartø1 || 0)['line'],
                        'column': inc((formStartø1 || 0)['column'])
                    }
                }));
            var methodø1 = withMeta(list.apply(void 0, [agetø1].concat([target], [list.apply(void 0, [symbol(void 0, 'quote')].concat([memberø1]))])), conj(opMetaø1, { 'end': (meta(target) || 0)['end'] }));
            return isNil(target) ? (function () {
                throw Error('Malformed method expression, expecting (.method object ...)');
            })() : list.apply(void 0, [methodø1].concat(vec(params)));
        }.call(this);
    };
var fieldSyntax = exports.fieldSyntax = function fieldSyntax(field, target) {
        var more = Array.prototype.slice.call(arguments, 2);
        return function () {
            var metadataø1 = meta(field);
            var startø1 = (metadataø1 || 0)['start'];
            var endø1 = (metadataø1 || 0)['end'];
            var memberø1 = withMeta(symbol(subs(name(field), 2)), conj(metadataø1, {
                    'start': {
                        'line': (startø1 || 0)['line'],
                        'column': (startø1 || 0)['column'] + 2
                    }
                }));
            return isNil(target) || count(more) ? (function () {
                throw Error('Malformed member expression, expecting (.-member target)');
            })() : list.apply(void 0, [symbol(void 0, 'aget')].concat([target], [list.apply(void 0, [symbol(void 0, 'quote')].concat([memberø1]))]));
        }.call(this);
    };
var newSyntax = exports.newSyntax = function newSyntax(op) {
        var params = Array.prototype.slice.call(arguments, 1);
        return function () {
            var idø1 = name(op);
            var idMetaø1 = (idø1 || 0)['meta'];
            var renameø1 = subs(idø1, 0, dec(count(idø1)));
            var constructorø1 = withMeta(symbol(renameø1), conj(idMetaø1, {
                    'end': {
                        'line': ((idMetaø1 || 0)['end'] || 0)['line'],
                        'column': dec(((idMetaø1 || 0)['end'] || 0)['column'])
                    }
                }));
            var operatorø1 = withMeta(symbol(void 0, 'new'), conj(idMetaø1, {
                    'start': {
                        'line': ((idMetaø1 || 0)['end'] || 0)['line'],
                        'column': dec(((idMetaø1 || 0)['end'] || 0)['column'])
                    }
                }));
            return list.apply(void 0, [symbol(void 0, 'new')].concat([constructorø1], vec(params)));
        }.call(this);
    };
var keywordInvoke = exports.keywordInvoke = function keywordInvoke(keyword, target) {
        return list.apply(void 0, [symbol(void 0, 'get')].concat([target], [keyword]));
    };
var desugar = function desugar(expander, form) {
    return function () {
        var desugaredø1 = expander.apply(void 0, vec(form));
        var metadataø1 = conj({}, meta(form), meta(desugaredø1));
        return withMeta(desugaredø1, metadataø1);
    }.call(this);
};
var macroexpand1 = exports.macroexpand1 = function macroexpand1(form, env) {
        return function () {
            var opø1 = isList(form) && first(form);
            var expanderø1 = macro(opø1);
            return expanderø1 ? expand(expanderø1, form, env) : isKeyword(opø1) ? desugar(keywordInvoke, form) : isFieldSyntax(opø1) ? desugar(fieldSyntax, form) : isMethodSyntax(opø1) ? desugar(methodSyntax, form) : isNewSyntax(opø1) ? desugar(newSyntax, form) : 'else' ? form : void 0;
        }.call(this);
    };
var macroexpand = exports.macroexpand = function macroexpand(form, env) {
        return function loop() {
            var recur = loop;
            var originalø1 = form;
            var expandedø1 = macroexpand1(form, env);
            do {
                recur = originalø1 === expandedø1 ? originalø1 : (loop[0] = expandedø1, loop[1] = macroexpand1(expandedø1, env), loop);
            } while (originalø1 = loop[0], expandedø1 = loop[1], recur === loop);
            return recur;
        }.call(this);
    };
var syntaxQuote = exports.syntaxQuote = function syntaxQuote(form) {
        return isSymbol(form) ? list(symbol(void 0, 'quote'), form) : isKeyword(form) ? list(symbol(void 0, 'quote'), form) : isNumber(form) || isString(form) || isBoolean(form) || isNil(form) || isRePattern(form) ? form : isUnquote(form) ? second(form) : isUnquoteSplicing(form) ? readerError('Illegal use of `~@` expression, can only be present in a list') : isEmpty(form) ? form : isDictionary(form) ? list(symbol(void 0, 'apply'), symbol(void 0, 'dictionary'), cons(symbol(void 0, '.concat'), sequenceExpand(concat.apply(void 0, seq(form))))) : isVector(form) ? cons(symbol(void 0, '.concat'), sequenceExpand(form)) : isList(form) ? isEmpty(form) ? cons(symbol(void 0, 'list'), void 0) : list(symbol(void 0, 'apply'), symbol(void 0, 'list'), cons(symbol(void 0, '.concat'), sequenceExpand(form))) : 'else' ? readerError('Unknown Collection type') : void 0;
    };
var syntaxQuoteExpand = exports.syntaxQuoteExpand = syntaxQuote;
var unquoteSplicingExpand = exports.unquoteSplicingExpand = function unquoteSplicingExpand(form) {
        return isVector(form) ? form : list(symbol(void 0, 'vec'), form);
    };
var sequenceExpand = exports.sequenceExpand = function sequenceExpand(forms) {
        return map(function (form) {
            return isUnquote(form) ? [second(form)] : isUnquoteSplicing(form) ? unquoteSplicingExpand(second(form)) : 'else' ? [syntaxQuoteExpand(form)] : void 0;
        }, forms);
    };
installMacro('syntax-quote', syntaxQuote);
var notEqual = exports.notEqual = function notEqual() {
        var body = Array.prototype.slice.call(arguments, 0);
        return list.apply(void 0, [symbol(void 0, 'not')].concat([list.apply(void 0, [symbol(void 0, '=')].concat(vec(body)))]));
    };
installMacro('not=', notEqual);
var ifNot = exports.ifNot = function ifNot(condition, truthy, alternative) {
        'Complements the `if` exclusive conditional branch.';
        return list.apply(void 0, [symbol(void 0, 'if')].concat([list.apply(void 0, [symbol(void 0, 'not')].concat([condition]))], [truthy], [alternative]));
    };
installMacro('if-not', ifNot);
var expandComment = exports.expandComment = function expandComment() {
        var body = Array.prototype.slice.call(arguments, 0);
        return void 0;
    };
installMacro('comment', expandComment);
var expandThreadFirst = exports.expandThreadFirst = function expandThreadFirst() {
        var operations = Array.prototype.slice.call(arguments, 0);
        return reduce(function (form, operation) {
            return cons(first(operation), cons(form, rest(operation)));
        }, first(operations), map(function ($1) {
            return isList($1) ? $1 : list.apply(void 0, [$1].concat());
        }, rest(operations)));
    };
installMacro('->', expandThreadFirst);
var expandCond = exports.expandCond = function expandCond() {
        var clauses = Array.prototype.slice.call(arguments, 0);
        return !isEmpty(clauses) ? list(symbol(void 0, 'if'), first(clauses), isEmpty(rest(clauses)) ? (function () {
            throw Error('cond requires an even number of forms');
        })() : second(clauses), cons(symbol(void 0, 'cond'), rest(rest(clauses)))) : void 0;
    };
installMacro('cond', expandCond);
var expandDefn = exports.expandDefn = function expandDefn(_andForm, name) {
        var docPlusMetaPlusBody = Array.prototype.slice.call(arguments, 2);
        return function () {
            var docø1 = isString(first(docPlusMetaPlusBody)) ? first(docPlusMetaPlusBody) : void 0;
            var metaPlusBodyø1 = docø1 ? rest(docPlusMetaPlusBody) : docPlusMetaPlusBody;
            var metadataø1 = isDictionary(first(metaPlusBodyø1)) ? conj({ 'doc': docø1 }, first(metaPlusBodyø1)) : void 0;
            var bodyø1 = metadataø1 ? rest(metaPlusBodyø1) : metaPlusBodyø1;
            var idø1 = withMeta(name, conj(meta(name) || {}, metadataø1));
            var fnø1 = withMeta(list.apply(void 0, [symbol(void 0, 'fn')].concat([idø1], vec(bodyø1))), meta(_andForm));
            return list.apply(void 0, [symbol(void 0, 'def')].concat([idø1], [fnø1]));
        }.call(this);
    };
installMacro('defn', withMeta(expandDefn, { 'implicit': ['&form'] }));
var expandPrivateDefn = exports.expandPrivateDefn = function expandPrivateDefn(name) {
        var body = Array.prototype.slice.call(arguments, 1);
        return function () {
            var metadataø1 = conj(meta(name) || {}, { 'private': true });
            var idø1 = withMeta(name, metadataø1);
            return list.apply(void 0, [symbol(void 0, 'defn')].concat([idø1], vec(body)));
        }.call(this);
    };
installMacro('defn-', expandPrivateDefn);
var expandLazySeq = exports.expandLazySeq = function expandLazySeq() {
        var body = Array.prototype.slice.call(arguments, 0);
        return list.apply(void 0, [symbol(void 0, '.call')].concat([symbol(void 0, 'lazy-seq')], [void 0], [false], [list.apply(void 0, [symbol(void 0, 'fn')].concat([[]], vec(body)))]));
    };
installMacro('lazy-seq', expandLazySeq);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFub255bW91cy53aXNwIl0sIm5hbWVzIjpbIl9uc18iLCJpZCIsImRvYyIsIm1ldGEiLCJ3aXRoTWV0YSIsImlzU3ltYm9sIiwiaXNLZXl3b3JkIiwiaXNRdW90ZSIsInN5bWJvbCIsIm5hbWVzcGFjZSIsIm5hbWUiLCJpc1VucXVvdGUiLCJpc1VucXVvdGVTcGxpY2luZyIsImlzTGlzdCIsImxpc3QiLCJjb25qIiwicGFydGl0aW9uIiwic2VxIiwiaXNFbXB0eSIsIm1hcCIsInZlYyIsImlzRXZlcnkiLCJjb25jYXQiLCJmaXJzdCIsInNlY29uZCIsInRoaXJkIiwicmVzdCIsImxhc3QiLCJidXRsYXN0IiwiaW50ZXJsZWF2ZSIsImNvbnMiLCJjb3VudCIsInNvbWUiLCJhc3NvYyIsInJlZHVjZSIsImZpbHRlciIsImlzU2VxIiwibGF6eVNlcSIsImlzTmlsIiwiaXNEaWN0aW9uYXJ5IiwiaXNWZWN0b3IiLCJrZXlzIiwidmFscyIsImlzU3RyaW5nIiwiaXNOdW1iZXIiLCJpc0Jvb2xlYW4iLCJpc0RhdGUiLCJpc1JlUGF0dGVybiIsImlzRXZlbiIsImlzRXF1YWwiLCJtYXgiLCJpbmMiLCJkZWMiLCJkaWN0aW9uYXJ5Iiwic3VicyIsInNwbGl0IiwiX19tYWNyb3NfXyIsImV4cG9ydHMiLCJleHBhbmQiLCJleHBhbmRlciIsImZvcm0iLCJlbnYiLCJtZXRhZGF0YcO4MSIsInBhcm1hc8O4MSIsImltcGxpY2l0w7gxIiwiJDEiLCJwYXJhbXPDuDEiLCJleHBhbnNpb27DuDEiLCJpbnN0YWxsTWFjcm8iLCJvcCIsIm1hY3JvIiwiaXNNZXRob2RTeW50YXgiLCJpZMO4MSIsImlzRmllbGRTeW50YXgiLCJpc05ld1N5bnRheCIsIm1ldGhvZFN5bnRheCIsInRhcmdldCIsInBhcmFtcyIsIm9wTWV0YcO4MSIsImZvcm1TdGFydMO4MSIsInRhcmdldE1ldGHDuDEiLCJtZW1iZXLDuDEiLCJhZ2V0w7gxIiwibWV0aG9kw7gxIiwiRXJyb3IiLCJmaWVsZFN5bnRheCIsImZpZWxkIiwibW9yZSIsInN0YXJ0w7gxIiwiZW5kw7gxIiwibmV3U3ludGF4IiwiaWRNZXRhw7gxIiwicmVuYW1lw7gxIiwiY29uc3RydWN0b3LDuDEiLCJvcGVyYXRvcsO4MSIsImtleXdvcmRJbnZva2UiLCJrZXl3b3JkIiwiZGVzdWdhciIsImRlc3VnYXJlZMO4MSIsIm1hY3JvZXhwYW5kMSIsIm9ww7gxIiwiZXhwYW5kZXLDuDEiLCJtYWNyb2V4cGFuZCIsIm9yaWdpbmFsw7gxIiwiZXhwYW5kZWTDuDEiLCJzeW50YXhRdW90ZSIsInJlYWRlckVycm9yIiwic2VxdWVuY2VFeHBhbmQiLCJzeW50YXhRdW90ZUV4cGFuZCIsInVucXVvdGVTcGxpY2luZ0V4cGFuZCIsImZvcm1zIiwibm90RXF1YWwiLCJib2R5IiwiaWZOb3QiLCJjb25kaXRpb24iLCJ0cnV0aHkiLCJhbHRlcm5hdGl2ZSIsImV4cGFuZENvbW1lbnQiLCJleHBhbmRUaHJlYWRGaXJzdCIsIm9wZXJhdGlvbnMiLCJvcGVyYXRpb24iLCJleHBhbmRDb25kIiwiY2xhdXNlcyIsImV4cGFuZERlZm4iLCJfYW5kRm9ybSIsImRvY1BsdXNNZXRhUGx1c0JvZHkiLCJkb2PDuDEiLCJtZXRhUGx1c0JvZHnDuDEiLCJib2R5w7gxIiwiZm7DuDEiLCJleHBhbmRQcml2YXRlRGVmbiIsImV4cGFuZExhenlTZXEiXSwibWFwcGluZ3MiOiI7SUFBQSxJQUFDQSxJLEdBQUQ7QUFBQSxZQUFBQyxFLEVBQUksZUFBSjtBQUFBLFlBQUFDLEcsRUFDRSx1Q0FERjtBQUFBLFU7O1FBRThCQyxJQUFBLEcsU0FBQUEsSTtRQUFLQyxRQUFBLEcsU0FBQUEsUTtRQUFVQyxRQUFBLEcsU0FBQUEsUTtRQUFRQyxTQUFBLEcsU0FBQUEsUztRQUN2QkMsT0FBQSxHLFNBQUFBLE87UUFBT0MsTUFBQSxHLFNBQUFBLE07UUFBT0MsU0FBQSxHLFNBQUFBLFM7UUFBVUMsSUFBQSxHLFNBQUFBLEk7UUFDeEJDLFNBQUEsRyxTQUFBQSxTO1FBQVNDLGlCQUFBLEcsU0FB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LEMsT0FBQSxFQUFzQjhELGlCQUF0QixFO0FBR0EsSUFBTUMsYUFBQSxHQUFBMUUsT0FBQSxDQUFBMEUsYUFBQSxHQUFOLFNBQU1BLGFBQU4sRztZQU1LbkIsSUFBQSxHO1FBQ0gsTyxVQUFBLEMsTUFBQSxFLE9BQUUsQyxNQUFBLEUsT0FBQSxDLGdCQUFNLEMsTUFBQSxFLFVBQUEsQyxpREFBb0IsQyxNQUFBLEUsSUFBQSxDLFVBQUcsRSxPQUFLQSxJLEtBQXBDLEU7S0FQRixDO0FBUUM1QyxZQUFELEMsVUFBQSxFQUF5QitELGFBQXpCIiwic291cmNlc0NvbnRlbnQiOlsiKG5zIHdpc3AuZXhwYW5kZXJcbiAgXCJ3aXNwIHN5bnRheCBhbmQgbWFjcm8gZXhwYW5kZXIgbW9kdWxlXCJcbiAgKDpyZXF1aXJlIFt3aXNwLmFzdCA6cmVmZXIgW21ldGEgd2l0aC1tZXRhIHN5bWJvbD8ga2V5d29yZD9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1b3RlPyBzeW1ib2wgbmFtZXNwYWNlIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVucXVvdGU/IHVucXVvdGUtc3BsaWNpbmc/XV1cbiAgICAgICAgICAgIFt3aXNwLnNlcXVlbmNlIDpyZWZlciBbbGlzdD8gbGlzdCBjb25qIHBhcnRpdGlvbiBzZXFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1wdHk/IG1hcCB2ZWMgZXZlcnk/IGNvbmNhdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCBzZWNvbmQgdGhpcmQgcmVzdCBsYXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dGxhc3QgaW50ZXJsZWF2ZSBjb25zIGNvdW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvbWUgYXNzb2MgcmVkdWNlIGZpbHRlciBzZXE/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhenktc2VxXV1cbiAgICAgICAgICAgIFt3aXNwLnJ1bnRpbWUgOnJlZmVyIFtuaWw/IGRpY3Rpb25hcnk/IHZlY3Rvcj8ga2V5c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHMgc3RyaW5nPyBudW1iZXI/IGJvb2xlYW4/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZT8gcmUtcGF0dGVybj8gZXZlbj8gPSBtYXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmMgZGVjIGRpY3Rpb25hcnkgc3Vic11dXG4gICAgICAgICAgICBbd2lzcC5zdHJpbmcgOnJlZmVyIFtzcGxpdF1dKSlcblxuXG4oZGVmICoqbWFjcm9zKioge30pXG5cbihkZWZuLSBleHBhbmRcbiAgXCJBcHBsaWVzIG1hY3JvIHJlZ2lzdGVyZWQgd2l0aCBnaXZlbiBgbmFtZWAgdG8gYSBnaXZlbiBgZm9ybWBcIlxuICBbZXhwYW5kZXIgZm9ybSBlbnZdXG4gIChsZXQgW21ldGFkYXRhIChvciAobWV0YSBmb3JtKSB7fSlcbiAgICAgICAgcGFybWFzIChyZXN0IGZvcm0pXG4gICAgICAgIGltcGxpY2l0IChtYXAgIyhjb25kICg9IDomZm9ybSAlKSBmb3JtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICg9IDomZW52ICUpIGVudlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ZWxzZSAlKVxuICAgICAgICAgICAgICAgICAgICAgIChvciAoOmltcGxpY2l0IChtZXRhIGV4cGFuZGVyKSkgW10pKVxuICAgICAgICBwYXJhbXMgKHZlYyAoY29uY2F0IGltcGxpY2l0ICh2ZWMgKHJlc3QgZm9ybSkpKSlcblxuICAgICAgICBleHBhbnNpb24gKGFwcGx5IGV4cGFuZGVyIHBhcmFtcyldXG4gICAgKGlmIGV4cGFuc2lvblxuICAgICAgKHdpdGgtbWV0YSBleHBhbnNpb24gKGNvbmogbWV0YWRhdGEgKG1ldGEgZXhwYW5zaW9uKSkpXG4gICAgICBleHBhbnNpb24pKSlcblxuKGRlZm4gaW5zdGFsbC1tYWNybyFcbiAgXCJSZWdpc3RlcnMgZ2l2ZW4gYG1hY3JvYCB3aXRoIGEgZ2l2ZW4gYG5hbWVgXCJcbiAgW29wIGV4cGFuZGVyXVxuICAoc2V0ISAoZ2V0ICoqbWFjcm9zKiogKG5hbWUgb3ApKSBleHBhbmRlcikpXG5cbihkZWZuLSBtYWNyb1xuICBcIlJldHVybnMgdHJ1ZSBpZiBtYWNybyB3aXRoIGEgZ2l2ZW4gbmFtZSBpcyByZWdpc3RlcmVkXCJcbiAgW29wXVxuICAoYW5kIChzeW1ib2w/IG9wKVxuICAgICAgIChnZXQgKiptYWNyb3MqKiAobmFtZSBvcCkpKSlcblxuXG4oZGVmbiBtZXRob2Qtc3ludGF4P1xuICBbb3BdXG4gIChsZXQgW2lkIChhbmQgKHN5bWJvbD8gb3ApIChuYW1lIG9wKSldXG4gICAgKGFuZCBpZFxuICAgICAgICAgKGlkZW50aWNhbD8gXFwuIChmaXJzdCBpZCkpXG4gICAgICAgICAobm90IChpZGVudGljYWw/IFxcLSAoc2Vjb25kIGlkKSkpXG4gICAgICAgICAobm90IChpZGVudGljYWw/IFxcLiBpZCkpKSkpXG5cbihkZWZuIGZpZWxkLXN5bnRheD9cbiAgW29wXVxuICAobGV0IFtpZCAoYW5kIChzeW1ib2w/IG9wKSAobmFtZSBvcCkpXVxuICAgIChhbmQgaWRcbiAgICAgICAgIChpZGVudGljYWw/IFxcLiAoZmlyc3QgaWQpKVxuICAgICAgICAgKGlkZW50aWNhbD8gXFwtIChzZWNvbmQgaWQpKSkpKVxuXG4oZGVmbiBuZXctc3ludGF4P1xuICBbb3BdXG4gIChsZXQgW2lkIChhbmQgKHN5bWJvbD8gb3ApIChuYW1lIG9wKSldXG4gICAgKGFuZCBpZFxuICAgICAgICAgKGlkZW50aWNhbD8gXFwuIChsYXN0IGlkKSlcbiAgICAgICAgIChub3QgKGlkZW50aWNhbD8gXFwuIGlkKSkpKSlcblxuKGRlZm4gbWV0aG9kLXN5bnRheFxuICBcIkV4YW1wbGU6XG4gICcoLnN1YnN0cmluZyBzdHJpbmcgMiA1KSA9PiAnKChhZ2V0IHN0cmluZyAnc3Vic3RyaW5nKSAyIDUpXCJcbiAgW29wIHRhcmdldCAmIHBhcmFtc11cbiAgKGxldCBbb3AtbWV0YSAobWV0YSBvcClcbiAgICAgICAgZm9ybS1zdGFydCAoOnN0YXJ0IG9wLW1ldGEpXG4gICAgICAgIHRhcmdldC1tZXRhIChtZXRhIHRhcmdldClcbiAgICAgICAgbWVtYmVyICh3aXRoLW1ldGEgKHN5bWJvbCAoc3VicyAobmFtZSBvcCkgMSkpXG4gICAgICAgICAgICAgICAgIDs7IEluY2x1ZGUgbWV0YWRhdCBmcm9tIHRoZSBvcmlnaW5hbCBzeW1ib2wganVzdFxuICAgICAgICAgICAgICAgICAoY29uaiBvcC1tZXRhXG4gICAgICAgICAgICAgICAgICAgICAgIHs6c3RhcnQgezpsaW5lICg6bGluZSBmb3JtLXN0YXJ0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6Y29sdW1uIChpbmMgKDpjb2x1bW4gZm9ybS1zdGFydCkpfX0pKVxuICAgICAgICA7OyBBZGQgbWV0YWRhdGEgdG8gYWdldCBzeW1ib2wgdGhhdCB3aWxsIG1hcCB0byB0aGUgZmlyc3QgYC5gXG4gICAgICAgIDs7IGNoYXJhY3RlciBvZiB0aGUgbWV0aG9kIG5hbWUuXG4gICAgICAgIGFnZXQgKHdpdGgtbWV0YSAnYWdldFxuICAgICAgICAgICAgICAgKGNvbmogb3AtbWV0YVxuICAgICAgICAgICAgICAgICAgICAgezplbmQgezpsaW5lICg6bGluZSBmb3JtLXN0YXJ0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpjb2x1bW4gKGluYyAoOmNvbHVtbiBmb3JtLXN0YXJ0KSl9fSkpXG5cbiAgICAgICAgOzsgRmlyc3QgdHdvIGZvcm1zICguc3Vic3RyaW5nIHN0cmluZyAuLi4pIGV4cGFuZCB0b1xuICAgICAgICA7OyAoKGFnZXQgc3RyaW5nICdzdWJzdHJpbmcpIC4uLikgdGhlcmUgZm9yIGV4cGFuc2lvbiBnZXRzXG4gICAgICAgIDs7IHBvc2l0aW9uIG1ldGFkYXRhIGZyb20gc3RhcnQgb2YgdGhlIGZpcnN0IGAuc3Vic3RyaW5nYCBmb3JtXG4gICAgICAgIDs7IHRvIHRoZSBlbmQgb2YgdGhlIGBzdHJpbmdgIGZvcm0uXG4gICAgICAgIG1ldGhvZCAod2l0aC1tZXRhIGAofmFnZXQgfnRhcmdldCAocXVvdGUgfm1lbWJlcikpXG4gICAgICAgICAgICAgICAgIChjb25qIG9wLW1ldGFcbiAgICAgICAgICAgICAgICAgICAgICAgezplbmQgKDplbmQgKG1ldGEgdGFyZ2V0KSl9KSldXG4gICAgKGlmIChuaWw/IHRhcmdldClcbiAgICAgICh0aHJvdyAoRXJyb3IgXCJNYWxmb3JtZWQgbWV0aG9kIGV4cHJlc3Npb24sIGV4cGVjdGluZyAoLm1ldGhvZCBvYmplY3QgLi4uKVwiKSlcbiAgICAgIGAofm1ldGhvZCB+QHBhcmFtcykpKSlcblxuKGRlZm4gZmllbGQtc3ludGF4XG4gIFwiRXhhbXBsZTpcbiAgJyguLWZpZWxkIG9iamVjdCkgPT4gJyhhZ2V0IG9iamVjdCAnZmllbGQpXCJcbiAgW2ZpZWxkIHRhcmdldCAmIG1vcmVdXG4gIChsZXQgW21ldGFkYXRhIChtZXRhIGZpZWxkKVxuICAgICAgICBzdGFydCAoOnN0YXJ0IG1ldGFkYXRhKVxuICAgICAgICBlbmQgKDplbmQgbWV0YWRhdGEpXG4gICAgICAgIG1lbWJlciAod2l0aC1tZXRhIChzeW1ib2wgKHN1YnMgKG5hbWUgZmllbGQpIDIpKVxuICAgICAgICAgICAgICAgICAoY29uaiBtZXRhZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICB7OnN0YXJ0IHs6bGluZSAoOmxpbmUgc3RhcnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpjb2x1bW4gKCsgKDpjb2x1bW4gc3RhcnQpIDIpfX0pKV1cbiAgICAoaWYgKG9yIChuaWw/IHRhcmdldClcbiAgICAgICAgICAgIChjb3VudCBtb3JlKSlcbiAgICAgICh0aHJvdyAoRXJyb3IgXCJNYWxmb3JtZWQgbWVtYmVyIGV4cHJlc3Npb24sIGV4cGVjdGluZyAoLi1tZW1iZXIgdGFyZ2V0KVwiKSlcbiAgICAgIGAoYWdldCB+dGFyZ2V0IChxdW90ZSB+bWVtYmVyKSkpKSlcblxuKGRlZm4gbmV3LXN5bnRheFxuICBcIkV4YW1wbGU6XG4gICcoUG9pbnQuIHggeSkgPT4gJyhuZXcgUG9pbnQgeCB5KVwiXG4gIFtvcCAmIHBhcmFtc11cbiAgKGxldCBbaWQgKG5hbWUgb3ApXG4gICAgICAgIGlkLW1ldGEgKDptZXRhIGlkKVxuICAgICAgICByZW5hbWUgKHN1YnMgaWQgMCAoZGVjIChjb3VudCBpZCkpKVxuICAgICAgICA7OyBjb25zdHJ1Y3R1ciBzeW1ib2wgaW5oZXJpdHMgbWV0YWRhIGZyb20gdGhlIGZpcnN0IGBvcGAgZm9ybVxuICAgICAgICA7OyBpdCdzIGp1c3QgaXQncyBlbmQgY29sdW1uIGluZm8gaXMgdXBkYXRlZCB0byByZWZsZWN0IHN1YnRyYWN0aW9uXG4gICAgICAgIDs7IG9mIGAuYCBjaGFyYWN0ZXIuXG4gICAgICAgIGNvbnN0cnVjdG9yICh3aXRoLW1ldGEgKHN5bWJvbCByZW5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgKGNvbmogaWQtbWV0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHs6ZW5kIHs6bGluZSAoOmxpbmUgKDplbmQgaWQtbWV0YSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpjb2x1bW4gKGRlYyAoOmNvbHVtbiAoOmVuZCBpZC1tZXRhKSkpfX0pKVxuICAgICAgICBvcGVyYXRvciAod2l0aC1tZXRhICduZXdcbiAgICAgICAgICAgICAgICAgICAoY29uaiBpZC1tZXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgezpzdGFydCB7OmxpbmUgKDpsaW5lICg6ZW5kIGlkLW1ldGEpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpjb2x1bW4gKGRlYyAoOmNvbHVtbiAoOmVuZCBpZC1tZXRhKSkpfX0pKV1cbiAgICBgKG5ldyB+Y29uc3RydWN0b3IgfkBwYXJhbXMpKSlcblxuKGRlZm4ga2V5d29yZC1pbnZva2VcbiAgXCJDYWxsaW5nIGEga2V5d29yZCBkZXN1Z2FycyB0byBwcm9wZXJ0eSBhY2Nlc3Mgd2l0aCB0aGF0XG4gIGtleXdvcmQgbmFtZSBvbiB0aGUgZ2l2ZW4gYXJndW1lbnQ6XG4gICcoOmZvbyBiYXIpID0+ICcoZ2V0IGJhciA6Zm9vKVwiXG4gIFtrZXl3b3JkIHRhcmdldF1cbiAgYChnZXQgfnRhcmdldCB+a2V5d29yZCkpXG5cbihkZWZuLSBkZXN1Z2FyXG4gIFtleHBhbmRlciBmb3JtXVxuICAobGV0IFtkZXN1Z2FyZWQgKGFwcGx5IGV4cGFuZGVyICh2ZWMgZm9ybSkpXG4gICAgICAgIG1ldGFkYXRhIChjb25qIHt9IChtZXRhIGZvcm0pIChtZXRhIGRlc3VnYXJlZCkpXVxuICAgICh3aXRoLW1ldGEgZGVzdWdhcmVkIG1ldGFkYXRhKSkpXG5cbihkZWZuIG1hY3JvZXhwYW5kLTFcbiAgXCJJZiBmb3JtIHJlcHJlc2VudHMgYSBtYWNybyBmb3JtLCByZXR1cm5zIGl0cyBleHBhbnNpb24sXG4gIGVsc2UgcmV0dXJucyBmb3JtLlwiXG4gIFtmb3JtIGVudl1cbiAgKGxldCBbb3AgKGFuZCAobGlzdD8gZm9ybSlcbiAgICAgICAgICAgICAgICAoZmlyc3QgZm9ybSkpXG4gICAgICAgIGV4cGFuZGVyIChtYWNybyBvcCldXG4gICAgKGNvbmQgZXhwYW5kZXIgKGV4cGFuZCBleHBhbmRlciBmb3JtIGVudilcbiAgICAgICAgICA7OyBDYWxsaW5nIGEga2V5d29yZCBjb21waWxlcyB0byBnZXR0aW5nIHZhbHVlIGZyb20gZ2l2ZW5cbiAgICAgICAgICA7OyBvYmplY3QgYXNzb2NpYXRlZCB3aXRoIHRoYXQga2V5OlxuICAgICAgICAgIDs7ICcoOmZvbyBiYXIpID0+ICcoZ2V0IGJhciA6Zm9vKVxuICAgICAgICAgIChrZXl3b3JkPyBvcCkgKGRlc3VnYXIga2V5d29yZC1pbnZva2UgZm9ybSlcbiAgICAgICAgICA7OyAnKC4tZmllbGQgb2JqZWN0KSA9PiAoYWdldCBvYmplY3QgJ2ZpZWxkKVxuICAgICAgICAgIChmaWVsZC1zeW50YXg/IG9wKSAoZGVzdWdhciBmaWVsZC1zeW50YXggZm9ybSlcbiAgICAgICAgICA7OyAnKC5zdWJzdHJpbmcgc3RyaW5nIDIgNSkgPT4gJygoYWdldCBzdHJpbmcgJ3N1YnN0cmluZykgMiA1KVxuICAgICAgICAgIChtZXRob2Qtc3ludGF4PyBvcCkgKGRlc3VnYXIgbWV0aG9kLXN5bnRheCBmb3JtKVxuICAgICAgICAgIDs7ICcoUG9pbnQuIHggeSkgPT4gJyhuZXcgUG9pbnQgeCB5KVxuICAgICAgICAgIChuZXctc3ludGF4PyBvcCkgKGRlc3VnYXIgbmV3LXN5bnRheCBmb3JtKVxuICAgICAgICAgIDplbHNlIGZvcm0pKSlcblxuKGRlZm4gbWFjcm9leHBhbmRcbiAgXCJSZXBlYXRlZGx5IGNhbGxzIG1hY3JvZXhwYW5kLTEgb24gZm9ybSB1bnRpbCBpdCBubyBsb25nZXJcbiAgcmVwcmVzZW50cyBhIG1hY3JvIGZvcm0sIHRoZW4gcmV0dXJucyBpdC5cIlxuICBbZm9ybSBlbnZdXG4gIChsb29wIFtvcmlnaW5hbCBmb3JtXG4gICAgICAgICBleHBhbmRlZCAobWFjcm9leHBhbmQtMSBmb3JtIGVudildXG4gICAgKGlmIChpZGVudGljYWw/IG9yaWdpbmFsIGV4cGFuZGVkKVxuICAgICAgb3JpZ2luYWxcbiAgICAgIChyZWN1ciBleHBhbmRlZCAobWFjcm9leHBhbmQtMSBleHBhbmRlZCBlbnYpKSkpKVxuXG5cbjs7IERlZmluZSBjb3JlIG1hY3Jvc1xuXG5cbjs7IFRPRE8gbWFrZSB0aGlzIGxhbmd1YWdlIGluZGVwZW5kZW50XG5cbihkZWZuIHN5bnRheC1xdW90ZSBbZm9ybV1cbiAgKGNvbmQgKHN5bWJvbD8gZm9ybSkgKGxpc3QgJ3F1b3RlIGZvcm0pXG4gICAgICAgIChrZXl3b3JkPyBmb3JtKSAobGlzdCAncXVvdGUgZm9ybSlcbiAgICAgICAgKG9yIChudW1iZXI/IGZvcm0pXG4gICAgICAgICAgICAoc3RyaW5nPyBmb3JtKVxuICAgICAgICAgICAgKGJvb2xlYW4/IGZvcm0pXG4gICAgICAgICAgICAobmlsPyBmb3JtKVxuICAgICAgICAgICAgKHJlLXBhdHRlcm4/IGZvcm0pKSBmb3JtXG5cbiAgICAgICAgKHVucXVvdGU/IGZvcm0pIChzZWNvbmQgZm9ybSlcbiAgICAgICAgKHVucXVvdGUtc3BsaWNpbmc/IGZvcm0pIChyZWFkZXItZXJyb3IgXCJJbGxlZ2FsIHVzZSBvZiBgfkBgIGV4cHJlc3Npb24sIGNhbiBvbmx5IGJlIHByZXNlbnQgaW4gYSBsaXN0XCIpXG5cbiAgICAgICAgKGVtcHR5PyBmb3JtKSBmb3JtXG5cbiAgICAgICAgOztcbiAgICAgICAgKGRpY3Rpb25hcnk/IGZvcm0pIChsaXN0ICdhcHBseVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RpY3Rpb25hcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChjb25zICcuY29uY2F0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc2VxdWVuY2UtZXhwYW5kIChhcHBseSBjb25jYXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzZXEgZm9ybSkpKSkpXG4gICAgICAgIDs7IElmIGEgdmVjdG9yIGZvcm0gZXhwYW5kIGFsbCBzdWItZm9ybXMgYW5kIGNvbmNhdGVuYXRlXG4gICAgICAgIDs7IHRoZW0gdG9nZXRoZXI6XG4gICAgICAgIDs7XG4gICAgICAgIDs7IFt+YSBiIH5AY10gLT4gKC5jb25jYXQgW2FdIFsocXVvdGUgYildIGMpXG4gICAgICAgICh2ZWN0b3I/IGZvcm0pIChjb25zICcuY29uY2F0IChzZXF1ZW5jZS1leHBhbmQgZm9ybSkpXG5cbiAgICAgICAgOzsgSWYgYSBsaXN0IGZvcm0gZXhwYW5kIGFsbCB0aGUgc3ViLWZvcm1zIGFuZCBhcHBseVxuICAgICAgICA7OyBjb25jYXRlbmF0aW9uIHRvIGEgbGlzdCBjb25zdHJ1Y3RvcjpcbiAgICAgICAgOztcbiAgICAgICAgOzsgKH5hIGIgfkBjKSAtPiAoYXBwbHkgbGlzdCAoLmNvbmNhdCBbYV0gWyhxdW90ZSBiKV0gYykpXG4gICAgICAgIChsaXN0PyBmb3JtKSAoaWYgKGVtcHR5PyBmb3JtKVxuICAgICAgICAgICAgICAgICAgICAgICAoY29ucyAnbGlzdCBuaWwpXG4gICAgICAgICAgICAgICAgICAgICAgIChsaXN0ICdhcHBseVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnbGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY29ucyAnLmNvbmNhdCAoc2VxdWVuY2UtZXhwYW5kIGZvcm0pKSkpXG5cbiAgICAgICAgOmVsc2UgKHJlYWRlci1lcnJvciBcIlVua25vd24gQ29sbGVjdGlvbiB0eXBlXCIpKSlcbihkZWYgc3ludGF4LXF1b3RlLWV4cGFuZCBzeW50YXgtcXVvdGUpXG5cbihkZWZuIHVucXVvdGUtc3BsaWNpbmctZXhwYW5kXG4gIFtmb3JtXVxuICAoaWYgKHZlY3Rvcj8gZm9ybSlcbiAgICBmb3JtXG4gICAgKGxpc3QgJ3ZlYyBmb3JtKSkpXG5cbihkZWZuIHNlcXVlbmNlLWV4cGFuZFxuICBcIlRha2VzIHNlcXVlbmNlIG9mIGZvcm1zIGFuZCBleHBhbmRzIHRoZW06XG5cbiAgKCh1bnF1b3RlIGEpKSAtPiAoW2FdKVxuICAoKHVucXVvdGUtc3BsaWNpbmcgYSkgLT4gKGEpXG4gIChhKSAtPiAoWyhxdW90ZSBiKV0pXG4gICgodW5xdW90ZSBhKSBiICh1bnF1b3RlLXNwbGljaW5nIGEpKSAtPiAoW2FdIFsocXVvdGUgYildIGMpXCJcbiAgW2Zvcm1zXVxuICAobWFwIChmbiBbZm9ybV1cbiAgICAgICAgIChjb25kICh1bnF1b3RlPyBmb3JtKSBbKHNlY29uZCBmb3JtKV1cbiAgICAgICAgICAgICAgICh1bnF1b3RlLXNwbGljaW5nPyBmb3JtKSAodW5xdW90ZS1zcGxpY2luZy1leHBhbmQgKHNlY29uZCBmb3JtKSlcbiAgICAgICAgICAgICAgIDplbHNlIFsoc3ludGF4LXF1b3RlLWV4cGFuZCBmb3JtKV0pKVxuICAgICAgIGZvcm1zKSlcbihpbnN0YWxsLW1hY3JvISA6c3ludGF4LXF1b3RlIHN5bnRheC1xdW90ZSlcblxuOzsgVE9ETzogTmV3IHJlYWRlciB0cmFuc2xhdGVzIG5vdD0gY29ycmVjdGx5XG47OyBidXQgZm9yIHRoZSB0aW1lIGJlaW5nIHVzZSBub3QtZXF1YWwgbmFtZVxuKGRlZm4gbm90LWVxdWFsXG4gIFsmIGJvZHldXG4gIGAobm90ICg9IH5AYm9keSkpKVxuKGluc3RhbGwtbWFjcm8hIDpub3Q9IG5vdC1lcXVhbClcblxuKGRlZm4gaWYtbm90IFtjb25kaXRpb24gdHJ1dGh5IGFsdGVybmF0aXZlXVxuICBcIkNvbXBsZW1lbnRzIHRoZSBgaWZgIGV4Y2x1c2l2ZSBjb25kaXRpb25hbCBicmFuY2guXCJcbiAgYChpZiAobm90IH5jb25kaXRpb24pIH50cnV0aHkgfmFsdGVybmF0aXZlKSlcbihpbnN0YWxsLW1hY3JvISA6aWYtbm90IGlmLW5vdClcblxuKGRlZm4gZXhwYW5kLWNvbW1lbnRcbiAgXCJJZ25vcmVzIGJvZHksIHlpZWxkcyBuaWxcIlxuICBbJiBib2R5XSlcbihpbnN0YWxsLW1hY3JvISA6Y29tbWVudCBleHBhbmQtY29tbWVudClcblxuKGRlZm4gZXhwYW5kLXRocmVhZC1maXJzdFxuICBcIlRocmVhZCBmaXJzdCBtYWNyb1wiXG4gIFsmIG9wZXJhdGlvbnNdXG4gIChyZWR1Y2VcbiAgIChmbiBbZm9ybSBvcGVyYXRpb25dXG4gICAgIChjb25zIChmaXJzdCBvcGVyYXRpb24pXG4gICAgICAgICAgIChjb25zIGZvcm0gKHJlc3Qgb3BlcmF0aW9uKSkpKVxuICAgKGZpcnN0IG9wZXJhdGlvbnMpXG4gICAobWFwICMoaWYgKGxpc3Q/ICUpICUgYCh+JSkpXG4gICAgICAgIChyZXN0IG9wZXJhdGlvbnMpKSkpXG4oaW5zdGFsbC1tYWNybyEgOi0+IGV4cGFuZC10aHJlYWQtZmlyc3QpXG5cbihkZWZuIGV4cGFuZC1jb25kXG4gIFwiVGFrZXMgYSBzZXQgb2YgdGVzdC9leHByIHBhaXJzLiBJdCBldmFsdWF0ZXMgZWFjaCB0ZXN0IG9uZSBhdCBhXG4gIHRpbWUuICBJZiBhIHRlc3QgcmV0dXJucyBsb2dpY2FsIHRydWUsIGNvbmQgZXZhbHVhdGVzIGFuZCByZXR1cm5zXG4gIHRoZSB2YWx1ZSBvZiB0aGUgY29ycmVzcG9uZGluZyBleHByIGFuZCBkb2Vzbid0IGV2YWx1YXRlIGFueSBvZiB0aGVcbiAgb3RoZXIgdGVzdHMgb3IgZXhwcnMuIChjb25kKSByZXR1cm5zIG5pbC5cIlxuICBbJiBjbGF1c2VzXVxuICAoaWYgKG5vdCAoZW1wdHk/IGNsYXVzZXMpKVxuICAgIChsaXN0ICdpZiAoZmlyc3QgY2xhdXNlcylcbiAgICAgICAgICAoaWYgKGVtcHR5PyAocmVzdCBjbGF1c2VzKSlcbiAgICAgICAgICAgICh0aHJvdyAoRXJyb3IgXCJjb25kIHJlcXVpcmVzIGFuIGV2ZW4gbnVtYmVyIG9mIGZvcm1zXCIpKVxuICAgICAgICAgICAgKHNlY29uZCBjbGF1c2VzKSlcbiAgICAgICAgICAoY29ucyAnY29uZCAocmVzdCAocmVzdCBjbGF1c2VzKSkpKSkpXG4oaW5zdGFsbC1tYWNybyEgOmNvbmQgZXhwYW5kLWNvbmQpXG5cbihkZWZuIGV4cGFuZC1kZWZuXG4gIFwiU2FtZSBhcyAoZGVmIG5hbWUgKGZuIFtwYXJhbXMqIF0gZXhwcnMqKSkgb3JcbiAgKGRlZiBuYW1lIChmbiAoW3BhcmFtcyogXSBleHBycyopKykpIHdpdGggYW55IGRvYy1zdHJpbmcgb3IgYXR0cnMgYWRkZWRcbiAgdG8gdGhlIHZhciBtZXRhZGF0YVwiXG4gIFsmZm9ybSBuYW1lICYgZG9jK21ldGErYm9keV1cbiAgKGxldCBbZG9jIChpZiAoc3RyaW5nPyAoZmlyc3QgZG9jK21ldGErYm9keSkpXG4gICAgICAgICAgICAgIChmaXJzdCBkb2MrbWV0YStib2R5KSlcblxuICAgICAgICA7OyBJZiBkb2NzdHJpbmcgaXMgZm91bmQgaXQncyBub3QgcGFydCBvZiBib2R5LlxuICAgICAgICBtZXRhK2JvZHkgKGlmIGRvYyAocmVzdCBkb2MrbWV0YStib2R5KSBkb2MrbWV0YStib2R5KVxuXG4gICAgICAgIDs7IGRlZm4gbWF5IGNvbnRhaW4gYXR0cmlidXRlIGxpc3QgYWZ0ZXJcbiAgICAgICAgOzsgZG9jc3RyaW5nIG9yIGEgbmFtZSwgaW4gd2hpY2ggY2FzZSBpdCdzXG4gICAgICAgIDs7IG1lcmdlZCBpbnRvIG5hbWUgbWV0YWRhdGEuXG4gICAgICAgIG1ldGFkYXRhIChpZiAoZGljdGlvbmFyeT8gKGZpcnN0IG1ldGErYm9keSkpXG4gICAgICAgICAgICAgICAgICAgKGNvbmogezpkb2MgZG9jfSAoZmlyc3QgbWV0YStib2R5KSkpXG5cbiAgICAgICAgOzsgSWYgbWV0YWRhdGEgbWFwIGlzIGZvdW5kIGl0J3Mgbm90IHBhcnQgb2YgYm9keS5cbiAgICAgICAgYm9keSAoaWYgbWV0YWRhdGEgKHJlc3QgbWV0YStib2R5KSBtZXRhK2JvZHkpXG5cbiAgICAgICAgOzsgQ29tYmluZSBhbGwgdGhlIG1ldGFkYXRhIGFuZCBhZGQgdG8gYSBuYW1lLlxuICAgICAgICBpZCAod2l0aC1tZXRhIG5hbWUgKGNvbmogKG9yIChtZXRhIG5hbWUpIHt9KSBtZXRhZGF0YSkpXG5cbiAgICAgICAgZm4gKHdpdGgtbWV0YSBgKGZuIH5pZCB+QGJvZHkpIChtZXRhICZmb3JtKSldXG4gICAgYChkZWYgfmlkIH5mbikpKVxuKGluc3RhbGwtbWFjcm8hIDpkZWZuICh3aXRoLW1ldGEgZXhwYW5kLWRlZm4gezppbXBsaWNpdCBbOiZmb3JtXX0pKVxuXG5cbihkZWZuIGV4cGFuZC1wcml2YXRlLWRlZm5cbiAgXCJTYW1lIGFzIChkZWYgbmFtZSAoZm4gW3BhcmFtcyogXSBleHBycyopKSBvclxuICAoZGVmIG5hbWUgKGZuIChbcGFyYW1zKiBdIGV4cHJzKikrKSkgd2l0aCBhbnkgZG9jLXN0cmluZyBvciBhdHRycyBhZGRlZFxuICB0byB0aGUgdmFyIG1ldGFkYXRhXCJcbiAgW25hbWUgJiBib2R5XVxuICAobGV0IFttZXRhZGF0YSAoY29uaiAob3IgKG1ldGEgbmFtZSkge30pXG4gICAgICAgICAgICAgICAgICAgICAgIHs6cHJpdmF0ZSB0cnVlfSlcbiAgICAgICAgaWQgKHdpdGgtbWV0YSBuYW1lIG1ldGFkYXRhKV1cbiAgICBgKGRlZm4gfmlkIH5AYm9keSkpKVxuKGluc3RhbGwtbWFjcm8gOmRlZm4tIGV4cGFuZC1wcml2YXRlLWRlZm4pXG5cblxuKGRlZm4gZXhwYW5kLWxhenktc2VxXG4gIFwiVGFrZXMgYSBib2R5IG9mIGV4cHJlc3Npb25zIHRoYXQgcmV0dXJucyBhbiBJU2VxIG9yIG5pbCwgYW5kIHlpZWxkc1xuICBhIFNlcWFibGUgb2JqZWN0IHRoYXQgd2lsbCBpbnZva2UgdGhlIGJvZHkgb25seSB0aGUgZmlyc3QgdGltZSBzZXFcbiAgaXMgY2FsbGVkLCBhbmQgd2lsbCBjYWNoZSB0aGUgcmVzdWx0IGFuZCByZXR1cm4gaXQgb24gYWxsIHN1YnNlcXVlbnRcbiAgc2VxIGNhbGxzLiBTZWUgYWxzbyAtIHJlYWxpemVkP1wiXG4gIHs6YWRkZWQgXCIxLjBcIn1cbiAgWyYgYm9keV1cbiAgYCguY2FsbCBsYXp5LXNlcSBuaWwgZmFsc2UgKGZuIFtdIH5AYm9keSkpKVxuKGluc3RhbGwtbWFjcm8gOmxhenktc2VxIGV4cGFuZC1sYXp5LXNlcSlcbiJdfQ==

},{"./ast":"ReP8Ll","./runtime":"wcC2X1","./sequence":"Mdzbzt","./string":"31fh9Q"}],15:[function(require,module,exports){
var process=require("__browserify_process"),__filename="/node_modules/amdefine/amdefine.js";/** vim: et:ts=4:sw=4:sts=4
 * @license amdefine 1.0.1 Copyright (c) 2011-2016, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/amdefine for details
 */

/*jslint node: true */
/*global module, process */
'use strict';

/**
 * Creates a define for node.
 * @param {Object} module the "module" object that is defined by Node for the
 * current module.
 * @param {Function} [requireFn]. Node's require function for the current module.
 * It only needs to be passed in Node versions before 0.5, when module.require
 * did not exist.
 * @returns {Function} a define function that is usable for the current node
 * module.
 */
function amdefine(module, requireFn) {
    'use strict';
    var defineCache = {},
        loaderCache = {},
        alreadyCalled = false,
        path = require('path'),
        makeRequire, stringRequire;

    /**
     * Trims the . and .. from an array of path segments.
     * It will keep a leading path segment if a .. will become
     * the first path segment, to help with module name lookups,
     * which act like paths, but can be remapped. But the end result,
     * all paths that use this function should look normalized.
     * NOTE: this method MODIFIES the input array.
     * @param {Array} ary the array of path segments.
     */
    function trimDots(ary) {
        var i, part;
        for (i = 0; ary[i]; i+= 1) {
            part = ary[i];
            if (part === '.') {
                ary.splice(i, 1);
                i -= 1;
            } else if (part === '..') {
                if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
                    //End of the line. Keep at least one non-dot
                    //path segment at the front so it can be mapped
                    //correctly to disk. Otherwise, there is likely
                    //no path mapping for a path starting with '..'.
                    //This can still fail, but catches the most reasonable
                    //uses of ..
                    break;
                } else if (i > 0) {
                    ary.splice(i - 1, 2);
                    i -= 2;
                }
            }
        }
    }

    function normalize(name, baseName) {
        var baseParts;

        //Adjust any relative paths.
        if (name && name.charAt(0) === '.') {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                baseParts = baseName.split('/');
                baseParts = baseParts.slice(0, baseParts.length - 1);
                baseParts = baseParts.concat(name.split('/'));
                trimDots(baseParts);
                name = baseParts.join('/');
            }
        }

        return name;
    }

    /**
     * Create the normalize() function passed to a loader plugin's
     * normalize method.
     */
    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(id) {
        function load(value) {
            loaderCache[id] = value;
        }

        load.fromText = function (id, text) {
            //This one is difficult because the text can/probably uses
            //define, and any relative paths and requires should be relative
            //to that id was it would be found on disk. But this would require
            //bootstrapping a module/require fairly deeply from node core.
            //Not sure how best to go about that yet.
            throw new Error('amdefine does not implement load.fromText');
        };

        return load;
    }

    makeRequire = function (systemRequire, exports, module, relId) {
        function amdRequire(deps, callback) {
            if (typeof deps === 'string') {
                //Synchronous, single module require('')
                return stringRequire(systemRequire, exports, module, deps, relId);
            } else {
                //Array of dependencies with a callback.

                //Convert the dependencies to modules.
                deps = deps.map(function (depName) {
                    return stringRequire(systemRequire, exports, module, depName, relId);
                });

                //Wait for next tick to call back the require call.
                if (callback) {
                    process.nextTick(function () {
                        callback.apply(null, deps);
                    });
                }
            }
        }

        amdRequire.toUrl = function (filePath) {
            if (filePath.indexOf('.') === 0) {
                return normalize(filePath, path.dirname(module.filename));
            } else {
                return filePath;
            }
        };

        return amdRequire;
    };

    //Favor explicit value, passed in if the module wants to support Node 0.4.
    requireFn = requireFn || function req() {
        return module.require.apply(module, arguments);
    };

    function runFactory(id, deps, factory) {
        var r, e, m, result;

        if (id) {
            e = loaderCache[id] = {};
            m = {
                id: id,
                uri: __filename,
                exports: e
            };
            r = makeRequire(requireFn, e, m, id);
        } else {
            //Only support one define call per file
            if (alreadyCalled) {
                throw new Error('amdefine with no module ID cannot be called more than once per file.');
            }
            alreadyCalled = true;

            //Use the real variables from node
            //Use module.exports for exports, since
            //the exports in here is amdefine exports.
            e = module.exports;
            m = module;
            r = makeRequire(requireFn, e, m, module.id);
        }

        //If there are dependencies, they are strings, so need
        //to convert them to dependency values.
        if (deps) {
            deps = deps.map(function (depName) {
                return r(depName);
            });
        }

        //Call the factory with the right dependencies.
        if (typeof factory === 'function') {
            result = factory.apply(m.exports, deps);
        } else {
            result = factory;
        }

        if (result !== undefined) {
            m.exports = result;
            if (id) {
                loaderCache[id] = m.exports;
            }
        }
    }

    stringRequire = function (systemRequire, exports, module, id, relId) {
        //Split the ID by a ! so that
        var index = id.indexOf('!'),
            originalId = id,
            prefix, plugin;

        if (index === -1) {
            id = normalize(id, relId);

            //Straight module lookup. If it is one of the special dependencies,
            //deal with it, otherwise, delegate to node.
            if (id === 'require') {
                return makeRequire(systemRequire, exports, module, relId);
            } else if (id === 'exports') {
                return exports;
            } else if (id === 'module') {
                return module;
            } else if (loaderCache.hasOwnProperty(id)) {
                return loaderCache[id];
            } else if (defineCache[id]) {
                runFactory.apply(null, defineCache[id]);
                return loaderCache[id];
            } else {
                if(systemRequire) {
                    return systemRequire(originalId);
                } else {
                    throw new Error('No module with ID: ' + id);
                }
            }
        } else {
            //There is a plugin in play.
            prefix = id.substring(0, index);
            id = id.substring(index + 1, id.length);

            plugin = stringRequire(systemRequire, exports, module, prefix, relId);

            if (plugin.normalize) {
                id = plugin.normalize(id, makeNormalize(relId));
            } else {
                //Normalize the ID normally.
                id = normalize(id, relId);
            }

            if (loaderCache[id]) {
                return loaderCache[id];
            } else {
                plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});

                return loaderCache[id];
            }
        }
    };

    //Create a define function specific to the module asking for amdefine.
    function define(id, deps, factory) {
        if (Array.isArray(id)) {
            factory = deps;
            deps = id;
            id = undefined;
        } else if (typeof id !== 'string') {
            factory = id;
            id = deps = undefined;
        }

        if (deps && !Array.isArray(deps)) {
            factory = deps;
            deps = undefined;
        }

        if (!deps) {
            deps = ['require', 'exports', 'module'];
        }

        //Set up properties for this module. If an ID, then use
        //internal cache. If no ID, then use the external variables
        //for this node module.
        if (id) {
            //Put the module in deep freeze until there is a
            //require call for it.
            defineCache[id] = [id, deps, factory];
        } else {
            runFactory(id, deps, factory);
        }
    }

    //define.require, which has access to all the values in the
    //cache. Useful for AMD modules that all have IDs in the file,
    //but need to finally export a value to node based on one of those
    //IDs.
    define.require = function (id) {
        if (loaderCache[id]) {
            return loaderCache[id];
        }

        if (defineCache[id]) {
            runFactory.apply(null, defineCache[id]);
            return loaderCache[id];
        }
    };

    define.amd = {};

    return define;
}

module.exports = amdefine;

},{"__browserify_process":30,"path":19}],16:[function(require,module,exports){
var Buffer=require("__browserify_Buffer").Buffer;module.exports = encode;
function encode(input) {
  return new Buffer(input).toString('base64')
}
},{"__browserify_Buffer":29}],17:[function(require,module,exports){


//
// The shims in this file are not fully implemented shims for the ES5
// features, but do work for the particular usecases there is in
// the other modules.
//

var toString = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

// Array.isArray is supported in IE9
function isArray(xs) {
  return toString.call(xs) === '[object Array]';
}
exports.isArray = typeof Array.isArray === 'function' ? Array.isArray : isArray;

// Array.prototype.indexOf is supported in IE9
exports.indexOf = function indexOf(xs, x) {
  if (xs.indexOf) return xs.indexOf(x);
  for (var i = 0; i < xs.length; i++) {
    if (x === xs[i]) return i;
  }
  return -1;
};

// Array.prototype.filter is supported in IE9
exports.filter = function filter(xs, fn) {
  if (xs.filter) return xs.filter(fn);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    if (fn(xs[i], i, xs)) res.push(xs[i]);
  }
  return res;
};

// Array.prototype.forEach is supported in IE9
exports.forEach = function forEach(xs, fn, self) {
  if (xs.forEach) return xs.forEach(fn, self);
  for (var i = 0; i < xs.length; i++) {
    fn.call(self, xs[i], i, xs);
  }
};

// Array.prototype.map is supported in IE9
exports.map = function map(xs, fn) {
  if (xs.map) return xs.map(fn);
  var out = new Array(xs.length);
  for (var i = 0; i < xs.length; i++) {
    out[i] = fn(xs[i], i, xs);
  }
  return out;
};

// Array.prototype.reduce is supported in IE9
exports.reduce = function reduce(array, callback, opt_initialValue) {
  if (array.reduce) return array.reduce(callback, opt_initialValue);
  var value, isValueSet = false;

  if (2 < arguments.length) {
    value = opt_initialValue;
    isValueSet = true;
  }
  for (var i = 0, l = array.length; l > i; ++i) {
    if (array.hasOwnProperty(i)) {
      if (isValueSet) {
        value = callback(value, array[i], i, array);
      }
      else {
        value = array[i];
        isValueSet = true;
      }
    }
  }

  return value;
};

// String.prototype.substr - negative index don't work in IE8
if ('ab'.substr(-1) !== 'b') {
  exports.substr = function (str, start, length) {
    // did we get a negative start, calculate how much it is from the beginning of the string
    if (start < 0) start = str.length + start;

    // call the original function
    return str.substr(start, length);
  };
} else {
  exports.substr = function (str, start, length) {
    return str.substr(start, length);
  };
}

// String.prototype.trim is supported in IE9
exports.trim = function (str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
};

// Function.prototype.bind is supported in IE9
exports.bind = function () {
  var args = Array.prototype.slice.call(arguments);
  var fn = args.shift();
  if (fn.bind) return fn.bind.apply(fn, args);
  var self = args.shift();
  return function () {
    fn.apply(self, args.concat([Array.prototype.slice.call(arguments)]));
  };
};

// Object.create is supported in IE9
function create(prototype, properties) {
  var object;
  if (prototype === null) {
    object = { '__proto__' : null };
  }
  else {
    if (typeof prototype !== 'object') {
      throw new TypeError(
        'typeof prototype[' + (typeof prototype) + '] != \'object\''
      );
    }
    var Type = function () {};
    Type.prototype = prototype;
    object = new Type();
    object.__proto__ = prototype;
  }
  if (typeof properties !== 'undefined' && Object.defineProperties) {
    Object.defineProperties(object, properties);
  }
  return object;
}
exports.create = typeof Object.create === 'function' ? Object.create : create;

// Object.keys and Object.getOwnPropertyNames is supported in IE9 however
// they do show a description and number property on Error objects
function notObject(object) {
  return ((typeof object != "object" && typeof object != "function") || object === null);
}

function keysShim(object) {
  if (notObject(object)) {
    throw new TypeError("Object.keys called on a non-object");
  }

  var result = [];
  for (var name in object) {
    if (hasOwnProperty.call(object, name)) {
      result.push(name);
    }
  }
  return result;
}

// getOwnPropertyNames is almost the same as Object.keys one key feature
//  is that it returns hidden properties, since that can't be implemented,
//  this feature gets reduced so it just shows the length property on arrays
function propertyShim(object) {
  if (notObject(object)) {
    throw new TypeError("Object.getOwnPropertyNames called on a non-object");
  }

  var result = keysShim(object);
  if (exports.isArray(object) && exports.indexOf(object, 'length') === -1) {
    result.push('length');
  }
  return result;
}

var keys = typeof Object.keys === 'function' ? Object.keys : keysShim;
var getOwnPropertyNames = typeof Object.getOwnPropertyNames === 'function' ?
  Object.getOwnPropertyNames : propertyShim;

if (new Error().hasOwnProperty('description')) {
  var ERROR_PROPERTY_FILTER = function (obj, array) {
    if (toString.call(obj) === '[object Error]') {
      array = exports.filter(array, function (name) {
        return name !== 'description' && name !== 'number' && name !== 'message';
      });
    }
    return array;
  };

  exports.keys = function (object) {
    return ERROR_PROPERTY_FILTER(object, keys(object));
  };
  exports.getOwnPropertyNames = function (object) {
    return ERROR_PROPERTY_FILTER(object, getOwnPropertyNames(object));
  };
} else {
  exports.keys = keys;
  exports.getOwnPropertyNames = getOwnPropertyNames;
}

// Object.getOwnPropertyDescriptor - supported in IE8 but only on dom elements
function valueObject(value, key) {
  return { value: value[key] };
}

if (typeof Object.getOwnPropertyDescriptor === 'function') {
  try {
    Object.getOwnPropertyDescriptor({'a': 1}, 'a');
    exports.getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  } catch (e) {
    // IE8 dom element issue - use a try catch and default to valueObject
    exports.getOwnPropertyDescriptor = function (value, key) {
      try {
        return Object.getOwnPropertyDescriptor(value, key);
      } catch (e) {
        return valueObject(value, key);
      }
    };
  }
} else {
  exports.getOwnPropertyDescriptor = valueObject;
}

},{}],18:[function(require,module,exports){

// not implemented
// The reason for having an empty file and not throwing is to allow
// untraditional implementation of this module.

},{}],19:[function(require,module,exports){
var process=require("__browserify_process");// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = require('util');
var shims = require('_shims');

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (!util.isString(path)) {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(shims.filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = shims.substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(shims.filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(shims.filter(paths, function(p, index) {
    if (!util.isString(p)) {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

},{"__browserify_process":30,"_shims":17,"util":21}],20:[function(require,module,exports){
module.exports=require(18)
},{}],21:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var shims = require('_shims');

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  shims.forEach(array, function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = shims.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = shims.getOwnPropertyNames(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }

  shims.forEach(keys, function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = shims.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }

  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (shims.indexOf(ctx.seen, desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = shims.reduce(output, function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return shims.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) && objectToString(e) === '[object Error]';
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.binarySlice === 'function'
  ;
}
exports.isBuffer = isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = function(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = shims.create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
};

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = shims.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

},{"_shims":17}],22:[function(require,module,exports){
var global=typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};/*
  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012-2013 Michael Ficarra <escodegen.copyright@michael.ficarra.me>
  Copyright (C) 2012-2013 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2013 Irakli Gozalishvili <rfobic@gmail.com>
  Copyright (C) 2012 Robert Gust-Bardon <donate@robert.gust-bardon.org>
  Copyright (C) 2012 John Freeman <jfreeman08@gmail.com>
  Copyright (C) 2011-2012 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*global exports:true, generateStatement:true, generateExpression:true, require:true, global:true*/
(function () {
    'use strict';

    var Syntax,
        Precedence,
        BinaryPrecedence,
        SourceNode,
        estraverse,
        esutils,
        isArray,
        base,
        indent,
        json,
        renumber,
        hexadecimal,
        quotes,
        escapeless,
        newline,
        space,
        parentheses,
        semicolons,
        safeConcatenation,
        directive,
        extra,
        parse,
        sourceMap,
        FORMAT_MINIFY,
        FORMAT_DEFAULTS;

    estraverse = require('estraverse');
    esutils = require('esutils');

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ComprehensionBlock: 'ComprehensionBlock',
        ComprehensionExpression: 'ComprehensionExpression',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DirectiveStatement: 'DirectiveStatement',
        DoWhileStatement: 'DoWhileStatement',
        DebuggerStatement: 'DebuggerStatement',
        EmptyStatement: 'EmptyStatement',
        ExportDeclaration: 'ExportDeclaration',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        ForOfStatement: 'ForOfStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        GeneratorExpression: 'GeneratorExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        ImportDeclaration: 'ImportDeclaration',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        Program: 'Program',
        Property: 'Property',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'
    };

    Precedence = {
        Sequence: 0,
        Yield: 1,
        Assignment: 1,
        Conditional: 2,
        ArrowFunction: 2,
        LogicalOR: 3,
        LogicalAND: 4,
        BitwiseOR: 5,
        BitwiseXOR: 6,
        BitwiseAND: 7,
        Equality: 8,
        Relational: 9,
        BitwiseSHIFT: 10,
        Additive: 11,
        Multiplicative: 12,
        Unary: 13,
        Postfix: 14,
        Call: 15,
        New: 16,
        Member: 17,
        Primary: 18
    };

    BinaryPrecedence = {
        '||': Precedence.LogicalOR,
        '&&': Precedence.LogicalAND,
        '|': Precedence.BitwiseOR,
        '^': Precedence.BitwiseXOR,
        '&': Precedence.BitwiseAND,
        '==': Precedence.Equality,
        '!=': Precedence.Equality,
        '===': Precedence.Equality,
        '!==': Precedence.Equality,
        'is': Precedence.Equality,
        'isnt': Precedence.Equality,
        '<': Precedence.Relational,
        '>': Precedence.Relational,
        '<=': Precedence.Relational,
        '>=': Precedence.Relational,
        'in': Precedence.Relational,
        'instanceof': Precedence.Relational,
        '<<': Precedence.BitwiseSHIFT,
        '>>': Precedence.BitwiseSHIFT,
        '>>>': Precedence.BitwiseSHIFT,
        '+': Precedence.Additive,
        '-': Precedence.Additive,
        '*': Precedence.Multiplicative,
        '%': Precedence.Multiplicative,
        '/': Precedence.Multiplicative
    };

    function getDefaultOptions() {
        // default options
        return {
            indent: null,
            base: null,
            parse: null,
            comment: false,
            format: {
                indent: {
                    style: '    ',
                    base: 0,
                    adjustMultilineComment: false
                },
                newline: '\n',
                space: ' ',
                json: false,
                renumber: false,
                hexadecimal: false,
                quotes: 'single',
                escapeless: false,
                compact: false,
                parentheses: true,
                semicolons: true,
                safeConcatenation: false
            },
            moz: {
                comprehensionExpressionStartsWithAssignment: false,
                starlessGenerator: false,
                parenthesizedComprehensionBlock: false
            },
            sourceMap: null,
            sourceMapRoot: null,
            sourceMapWithCode: false,
            directive: false,
            raw: true,
            verbatim: null
        };
    }

    function stringRepeat(str, num) {
        var result = '';

        for (num |= 0; num > 0; num >>>= 1, str += str) {
            if (num & 1) {
                result += str;
            }
        }

        return result;
    }

    isArray = Array.isArray;
    if (!isArray) {
        isArray = function isArray(array) {
            return Object.prototype.toString.call(array) === '[object Array]';
        };
    }

    function hasLineTerminator(str) {
        return (/[\r\n]/g).test(str);
    }

    function endsWithLineTerminator(str) {
        var len = str.length;
        return len && esutils.code.isLineTerminator(str.charCodeAt(len - 1));
    }

    function updateDeeply(target, override) {
        var key, val;

        function isHashObject(target) {
            return typeof target === 'object' && target instanceof Object && !(target instanceof RegExp);
        }

        for (key in override) {
            if (override.hasOwnProperty(key)) {
                val = override[key];
                if (isHashObject(val)) {
                    if (isHashObject(target[key])) {
                        updateDeeply(target[key], val);
                    } else {
                        target[key] = updateDeeply({}, val);
                    }
                } else {
                    target[key] = val;
                }
            }
        }
        return target;
    }

    function generateNumber(value) {
        var result, point, temp, exponent, pos;

        if (value !== value) {
            throw new Error('Numeric literal whose value is NaN');
        }
        if (value < 0 || (value === 0 && 1 / value < 0)) {
            throw new Error('Numeric literal whose value is negative');
        }

        if (value === 1 / 0) {
            return json ? 'null' : renumber ? '1e400' : '1e+400';
        }

        result = '' + value;
        if (!renumber || result.length < 3) {
            return result;
        }

        point = result.indexOf('.');
        if (!json && result.charCodeAt(0) === 0x30  /* 0 */ && point === 1) {
            point = 0;
            result = result.slice(1);
        }
        temp = result;
        result = result.replace('e+', 'e');
        exponent = 0;
        if ((pos = temp.indexOf('e')) > 0) {
            exponent = +temp.slice(pos + 1);
            temp = temp.slice(0, pos);
        }
        if (point >= 0) {
            exponent -= temp.length - point - 1;
            temp = +(temp.slice(0, point) + temp.slice(point + 1)) + '';
        }
        pos = 0;
        while (temp.charCodeAt(temp.length + pos - 1) === 0x30  /* 0 */) {
            --pos;
        }
        if (pos !== 0) {
            exponent -= pos;
            temp = temp.slice(0, pos);
        }
        if (exponent !== 0) {
            temp += 'e' + exponent;
        }
        if ((temp.length < result.length ||
                    (hexadecimal && value > 1e12 && Math.floor(value) === value && (temp = '0x' + value.toString(16)).length < result.length)) &&
                +temp === value) {
            result = temp;
        }

        return result;
    }

    // Generate valid RegExp expression.
    // This function is based on https://github.com/Constellation/iv Engine

    function escapeRegExpCharacter(ch, previousIsBackslash) {
        // not handling '\' and handling \u2028 or \u2029 to unicode escape sequence
        if ((ch & ~1) === 0x2028) {
            return (previousIsBackslash ? 'u' : '\\u') + ((ch === 0x2028) ? '2028' : '2029');
        } else if (ch === 10 || ch === 13) {  // \n, \r
            return (previousIsBackslash ? '' : '\\') + ((ch === 10) ? 'n' : 'r');
        }
        return String.fromCharCode(ch);
    }

    function generateRegExp(reg) {
        var match, result, flags, i, iz, ch, characterInBrack, previousIsBackslash;

        result = reg.toString();

        if (reg.source) {
            // extract flag from toString result
            match = result.match(/\/([^/]*)$/);
            if (!match) {
                return result;
            }

            flags = match[1];
            result = '';

            characterInBrack = false;
            previousIsBackslash = false;
            for (i = 0, iz = reg.source.length; i < iz; ++i) {
                ch = reg.source.charCodeAt(i);

                if (!previousIsBackslash) {
                    if (characterInBrack) {
                        if (ch === 93) {  // ]
                            characterInBrack = false;
                        }
                    } else {
                        if (ch === 47) {  // /
                            result += '\\';
                        } else if (ch === 91) {  // [
                            characterInBrack = true;
                        }
                    }
                    result += escapeRegExpCharacter(ch, previousIsBackslash);
                    previousIsBackslash = ch === 92;  // \
                } else {
                    // if new RegExp("\\\n') is provided, create /\n/
                    result += escapeRegExpCharacter(ch, previousIsBackslash);
                    // prevent like /\\[/]/
                    previousIsBackslash = false;
                }
            }

            return '/' + result + '/' + flags;
        }

        return result;
    }

    function escapeAllowedCharacter(code, next) {
        var hex, result = '\\';

        switch (code) {
        case 0x08  /* \b */:
            result += 'b';
            break;
        case 0x0C  /* \f */:
            result += 'f';
            break;
        case 0x09  /* \t */:
            result += 't';
            break;
        default:
            hex = code.toString(16).toUpperCase();
            if (json || code > 0xFF) {
                result += 'u' + '0000'.slice(hex.length) + hex;
            } else if (code === 0x0000 && !esutils.code.isDecimalDigit(next)) {
                result += '0';
            } else if (code === 0x000B  /* \v */) { // '\v'
                result += 'x0B';
            } else {
                result += 'x' + '00'.slice(hex.length) + hex;
            }
            break;
        }

        return result;
    }

    function escapeDisallowedCharacter(code) {
        var result = '\\';
        switch (code) {
        case 0x5C  /* \ */:
            result += '\\';
            break;
        case 0x0A  /* \n */:
            result += 'n';
            break;
        case 0x0D  /* \r */:
            result += 'r';
            break;
        case 0x2028:
            result += 'u2028';
            break;
        case 0x2029:
            result += 'u2029';
            break;
        default:
            throw new Error('Incorrectly classified character');
        }

        return result;
    }

    function escapeDirective(str) {
        var i, iz, code, quote;

        quote = quotes === 'double' ? '"' : '\'';
        for (i = 0, iz = str.length; i < iz; ++i) {
            code = str.charCodeAt(i);
            if (code === 0x27  /* ' */) {
                quote = '"';
                break;
            } else if (code === 0x22  /* " */) {
                quote = '\'';
                break;
            } else if (code === 0x5C  /* \ */) {
                ++i;
            }
        }

        return quote + str + quote;
    }

    function escapeString(str) {
        var result = '', i, len, code, singleQuotes = 0, doubleQuotes = 0, single, quote;

        for (i = 0, len = str.length; i < len; ++i) {
            code = str.charCodeAt(i);
            if (code === 0x27  /* ' */) {
                ++singleQuotes;
            } else if (code === 0x22  /* " */) {
                ++doubleQuotes;
            } else if (code === 0x2F  /* / */ && json) {
                result += '\\';
            } else if (esutils.code.isLineTerminator(code) || code === 0x5C  /* \ */) {
                result += escapeDisallowedCharacter(code);
                continue;
            } else if ((json && code < 0x20  /* SP */) || !(json || escapeless || (code >= 0x20  /* SP */ && code <= 0x7E  /* ~ */))) {
                result += escapeAllowedCharacter(code, str.charCodeAt(i + 1));
                continue;
            }
            result += String.fromCharCode(code);
        }

        single = !(quotes === 'double' || (quotes === 'auto' && doubleQuotes < singleQuotes));
        quote = single ? '\'' : '"';

        if (!(single ? singleQuotes : doubleQuotes)) {
            return quote + result + quote;
        }

        str = result;
        result = quote;

        for (i = 0, len = str.length; i < len; ++i) {
            code = str.charCodeAt(i);
            if ((code === 0x27  /* ' */ && single) || (code === 0x22  /* " */ && !single)) {
                result += '\\';
            }
            result += String.fromCharCode(code);
        }

        return result + quote;
    }

    /**
     * flatten an array to a string, where the array can contain
     * either strings or nested arrays
     */
    function flattenToString(arr) {
        var i, iz, elem, result = '';
        for (i = 0, iz = arr.length; i < iz; ++i) {
            elem = arr[i];
            result += isArray(elem) ? flattenToString(elem) : elem;
        }
        return result;
    }

    /**
     * convert generated to a SourceNode when source maps are enabled.
     */
    function toSourceNodeWhenNeeded(generated, node) {
        if (!sourceMap) {
            // with no source maps, generated is either an
            // array or a string.  if an array, flatten it.
            // if a string, just return it
            if (isArray(generated)) {
                return flattenToString(generated);
            } else {
                return generated;
            }
        }
        if (node == null) {
            if (generated instanceof SourceNode) {
                return generated;
            } else {
                node = {};
            }
        }
        if (node.loc == null) {
            return new SourceNode(null, null, sourceMap, generated, node.name || null);
        }
        return new SourceNode(node.loc.start.line, node.loc.start.column, (sourceMap === true ? node.loc.source || null : sourceMap), generated, node.name || null);
    }

    function noEmptySpace() {
        return (space) ? space : ' ';
    }

    function join(left, right) {
        var leftSource = toSourceNodeWhenNeeded(left).toString(),
            rightSource = toSourceNodeWhenNeeded(right).toString(),
            leftCharCode = leftSource.charCodeAt(leftSource.length - 1),
            rightCharCode = rightSource.charCodeAt(0);

        if ((leftCharCode === 0x2B  /* + */ || leftCharCode === 0x2D  /* - */) && leftCharCode === rightCharCode ||
        esutils.code.isIdentifierPart(leftCharCode) && esutils.code.isIdentifierPart(rightCharCode) ||
        leftCharCode === 0x2F  /* / */ && rightCharCode === 0x69  /* i */) { // infix word operators all start with `i`
            return [left, noEmptySpace(), right];
        } else if (esutils.code.isWhiteSpace(leftCharCode) || esutils.code.isLineTerminator(leftCharCode) ||
                esutils.code.isWhiteSpace(rightCharCode) || esutils.code.isLineTerminator(rightCharCode)) {
            return [left, right];
        }
        return [left, space, right];
    }

    function addIndent(stmt) {
        return [base, stmt];
    }

    function withIndent(fn) {
        var previousBase, result;
        previousBase = base;
        base += indent;
        result = fn.call(this, base);
        base = previousBase;
        return result;
    }

    function calculateSpaces(str) {
        var i;
        for (i = str.length - 1; i >= 0; --i) {
            if (esutils.code.isLineTerminator(str.charCodeAt(i))) {
                break;
            }
        }
        return (str.length - 1) - i;
    }

    function adjustMultilineComment(value, specialBase) {
        var array, i, len, line, j, spaces, previousBase, sn;

        array = value.split(/\r\n|[\r\n]/);
        spaces = Number.MAX_VALUE;

        // first line doesn't have indentation
        for (i = 1, len = array.length; i < len; ++i) {
            line = array[i];
            j = 0;
            while (j < line.length && esutils.code.isWhiteSpace(line.charCodeAt(j))) {
                ++j;
            }
            if (spaces > j) {
                spaces = j;
            }
        }

        if (typeof specialBase !== 'undefined') {
            // pattern like
            // {
            //   var t = 20;  /*
            //                 * this is comment
            //                 */
            // }
            previousBase = base;
            if (array[1][spaces] === '*') {
                specialBase += ' ';
            }
            base = specialBase;
        } else {
            if (spaces & 1) {
                // /*
                //  *
                //  */
                // If spaces are odd number, above pattern is considered.
                // We waste 1 space.
                --spaces;
            }
            previousBase = base;
        }

        for (i = 1, len = array.length; i < len; ++i) {
            sn = toSourceNodeWhenNeeded(addIndent(array[i].slice(spaces)));
            array[i] = sourceMap ? sn.join('') : sn;
        }

        base = previousBase;

        return array.join('\n');
    }

    function generateComment(comment, specialBase) {
        if (comment.type === 'Line') {
            if (endsWithLineTerminator(comment.value)) {
                return '//' + comment.value;
            } else {
                // Always use LineTerminator
                return '//' + comment.value + '\n';
            }
        }
        if (extra.format.indent.adjustMultilineComment && /[\n\r]/.test(comment.value)) {
            return adjustMultilineComment('/*' + comment.value + '*/', specialBase);
        }
        return '/*' + comment.value + '*/';
    }

    function addComments(stmt, result) {
        var i, len, comment, save, tailingToStatement, specialBase, fragment;

        if (stmt.leadingComments && stmt.leadingComments.length > 0) {
            save = result;

            comment = stmt.leadingComments[0];
            result = [];
            if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {
                result.push('\n');
            }
            result.push(generateComment(comment));
            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push('\n');
            }

            for (i = 1, len = stmt.leadingComments.length; i < len; ++i) {
                comment = stmt.leadingComments[i];
                fragment = [generateComment(comment)];
                if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                    fragment.push('\n');
                }
                result.push(addIndent(fragment));
            }

            result.push(addIndent(save));
        }

        if (stmt.trailingComments) {
            tailingToStatement = !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
            specialBase = stringRepeat(' ', calculateSpaces(toSourceNodeWhenNeeded([base, result, indent]).toString()));
            for (i = 0, len = stmt.trailingComments.length; i < len; ++i) {
                comment = stmt.trailingComments[i];
                if (tailingToStatement) {
                    // We assume target like following script
                    //
                    // var t = 20;  /**
                    //               * This is comment of t
                    //               */
                    if (i === 0) {
                        // first case
                        result = [result, indent];
                    } else {
                        result = [result, specialBase];
                    }
                    result.push(generateComment(comment, specialBase));
                } else {
                    result = [result, addIndent(generateComment(comment))];
                }
                if (i !== len - 1 && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                    result = [result, '\n'];
                }
            }
        }

        return result;
    }

    function parenthesize(text, current, should) {
        if (current < should) {
            return ['(', text, ')'];
        }
        return text;
    }

    function maybeBlock(stmt, semicolonOptional, functionBody) {
        var result, noLeadingComment;

        noLeadingComment = !extra.comment || !stmt.leadingComments;

        if (stmt.type === Syntax.BlockStatement && noLeadingComment) {
            return [space, generateStatement(stmt, { functionBody: functionBody })];
        }

        if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {
            return ';';
        }

        withIndent(function () {
            result = [newline, addIndent(generateStatement(stmt, { semicolonOptional: semicolonOptional, functionBody: functionBody }))];
        });

        return result;
    }

    function maybeBlockSuffix(stmt, result) {
        var ends = endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
        if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {
            return [result, space];
        }
        if (ends) {
            return [result, base];
        }
        return [result, newline, base];
    }

    function generateVerbatimString(string) {
        var i, iz, result;
        result = string.split(/\r\n|\n/);
        for (i = 1, iz = result.length; i < iz; i++) {
            result[i] = newline + base + result[i];
        }
        return result;
    }

    function generateVerbatim(expr, option) {
        var verbatim, result, prec;
        verbatim = expr[extra.verbatim];

        if (typeof verbatim === 'string') {
            result = parenthesize(generateVerbatimString(verbatim), Precedence.Sequence, option.precedence);
        } else {
            // verbatim is object
            result = generateVerbatimString(verbatim.content);
            prec = (verbatim.precedence != null) ? verbatim.precedence : Precedence.Sequence;
            result = parenthesize(result, prec, option.precedence);
        }

        return toSourceNodeWhenNeeded(result, expr);
    }

    function generateIdentifier(node) {
        return toSourceNodeWhenNeeded(node.name, node);
    }

    function generatePattern(node, options) {
        var result;

        if (node.type === Syntax.Identifier) {
            result = generateIdentifier(node);
        } else {
            result = generateExpression(node, {
                precedence: options.precedence,
                allowIn: options.allowIn,
                allowCall: true
            });
        }

        return result;
    }

    function generateFunctionBody(node) {
        var result, i, len, expr, arrow;

        arrow = node.type === Syntax.ArrowFunctionExpression;

        if (arrow && node.params.length === 1 && node.params[0].type === Syntax.Identifier) {
            // arg => { } case
            result = [generateIdentifier(node.params[0])];
        } else {
            result = ['('];
            for (i = 0, len = node.params.length; i < len; ++i) {
                result.push(generatePattern(node.params[i], {
                    precedence: Precedence.Assignment,
                    allowIn: true
                }));
                if (i + 1 < len) {
                    result.push(',' + space);
                }
            }
            result.push(')');
        }

        if (arrow) {
            result.push(space);
            result.push('=>');
        }

        if (node.expression) {
            result.push(space);
            expr = generateExpression(node.body, {
                precedence: Precedence.Assignment,
                allowIn: true,
                allowCall: true
            });
            if (expr.toString().charAt(0) === '{') {
                expr = ['(', expr, ')'];
            }
            result.push(expr);
        } else {
            result.push(maybeBlock(node.body, false, true));
        }
        return result;
    }

    function generateIterationForStatement(operator, stmt, semicolonIsNotNeeded) {
        var result = ['for' + space + '('];
        withIndent(function () {
            if (stmt.left.type === Syntax.VariableDeclaration) {
                withIndent(function () {
                    result.push(stmt.left.kind + noEmptySpace());
                    result.push(generateStatement(stmt.left.declarations[0], {
                        allowIn: false
                    }));
                });
            } else {
                result.push(generateExpression(stmt.left, {
                    precedence: Precedence.Call,
                    allowIn: true,
                    allowCall: true
                }));
            }

            result = join(result, operator);
            result = [join(
                result,
                generateExpression(stmt.right, {
                    precedence: Precedence.Sequence,
                    allowIn: true,
                    allowCall: true
                })
            ), ')'];
        });
        result.push(maybeBlock(stmt.body, semicolonIsNotNeeded));
        return result;
    }

    function generateLiteral(expr) {
        var raw;
        if (expr.hasOwnProperty('raw') && parse && extra.raw) {
            try {
                raw = parse(expr.raw).body[0].expression;
                if (raw.type === Syntax.Literal) {
                    if (raw.value === expr.value) {
                        return expr.raw;
                    }
                }
            } catch (e) {
                // not use raw property
            }
        }

        if (expr.value === null) {
            return 'null';
        }

        if (typeof expr.value === 'string') {
            return escapeString(expr.value);
        }

        if (typeof expr.value === 'number') {
            return generateNumber(expr.value);
        }

        if (typeof expr.value === 'boolean') {
            return expr.value ? 'true' : 'false';
        }

        return generateRegExp(expr.value);
    }

    function generateExpression(expr, option) {
        var result,
            precedence,
            type,
            currentPrecedence,
            i,
            len,
            fragment,
            multiline,
            leftCharCode,
            leftSource,
            rightCharCode,
            allowIn,
            allowCall,
            allowUnparenthesizedNew,
            property,
            isGenerator;

        precedence = option.precedence;
        allowIn = option.allowIn;
        allowCall = option.allowCall;
        type = expr.type || option.type;

        if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {
            return generateVerbatim(expr, option);
        }

        switch (type) {
        case Syntax.SequenceExpression:
            result = [];
            allowIn |= (Precedence.Sequence < precedence);
            for (i = 0, len = expr.expressions.length; i < len; ++i) {
                result.push(generateExpression(expr.expressions[i], {
                    precedence: Precedence.Assignment,
                    allowIn: allowIn,
                    allowCall: true
                }));
                if (i + 1 < len) {
                    result.push(',' + space);
                }
            }
            result = parenthesize(result, Precedence.Sequence, precedence);
            break;

        case Syntax.AssignmentExpression:
            allowIn |= (Precedence.Assignment < precedence);
            result = parenthesize(
                [
                    generateExpression(expr.left, {
                        precedence: Precedence.Call,
                        allowIn: allowIn,
                        allowCall: true
                    }),
                    space + expr.operator + space,
                    generateExpression(expr.right, {
                        precedence: Precedence.Assignment,
                        allowIn: allowIn,
                        allowCall: true
                    })
                ],
                Precedence.Assignment,
                precedence
            );
            break;

        case Syntax.ArrowFunctionExpression:
            allowIn |= (Precedence.ArrowFunction < precedence);
            result = parenthesize(generateFunctionBody(expr), Precedence.ArrowFunction, precedence);
            break;

        case Syntax.ConditionalExpression:
            allowIn |= (Precedence.Conditional < precedence);
            result = parenthesize(
                [
                    generateExpression(expr.test, {
                        precedence: Precedence.LogicalOR,
                        allowIn: allowIn,
                        allowCall: true
                    }),
                    space + '?' + space,
                    generateExpression(expr.consequent, {
                        precedence: Precedence.Assignment,
                        allowIn: allowIn,
                        allowCall: true
                    }),
                    space + ':' + space,
                    generateExpression(expr.alternate, {
                        precedence: Precedence.Assignment,
                        allowIn: allowIn,
                        allowCall: true
                    })
                ],
                Precedence.Conditional,
                precedence
            );
            break;

        case Syntax.LogicalExpression:
        case Syntax.BinaryExpression:
            currentPrecedence = BinaryPrecedence[expr.operator];

            allowIn |= (currentPrecedence < precedence);

            fragment = generateExpression(expr.left, {
                precedence: currentPrecedence,
                allowIn: allowIn,
                allowCall: true
            });

            leftSource = fragment.toString();

            if (leftSource.charCodeAt(leftSource.length - 1) === 0x2F /* / */ && esutils.code.isIdentifierPart(expr.operator.charCodeAt(0))) {
                result = [fragment, noEmptySpace(), expr.operator];
            } else {
                result = join(fragment, expr.operator);
            }

            fragment = generateExpression(expr.right, {
                precedence: currentPrecedence + 1,
                allowIn: allowIn,
                allowCall: true
            });

            if (expr.operator === '/' && fragment.toString().charAt(0) === '/' ||
            expr.operator.slice(-1) === '<' && fragment.toString().slice(0, 3) === '!--') {
                // If '/' concats with '/' or `<` concats with `!--`, it is interpreted as comment start
                result.push(noEmptySpace());
                result.push(fragment);
            } else {
                result = join(result, fragment);
            }

            if (expr.operator === 'in' && !allowIn) {
                result = ['(', result, ')'];
            } else {
                result = parenthesize(result, currentPrecedence, precedence);
            }

            break;

        case Syntax.CallExpression:
            result = [generateExpression(expr.callee, {
                precedence: Precedence.Call,
                allowIn: true,
                allowCall: true,
                allowUnparenthesizedNew: false
            })];

            result.push('(');
            for (i = 0, len = expr['arguments'].length; i < len; ++i) {
                result.push(generateExpression(expr['arguments'][i], {
                    precedence: Precedence.Assignment,
                    allowIn: true,
                    allowCall: true
                }));
                if (i + 1 < len) {
                    result.push(',' + space);
                }
            }
            result.push(')');

            if (!allowCall) {
                result = ['(', result, ')'];
            } else {
                result = parenthesize(result, Precedence.Call, precedence);
            }
            break;

        case Syntax.NewExpression:
            len = expr['arguments'].length;
            allowUnparenthesizedNew = option.allowUnparenthesizedNew === undefined || option.allowUnparenthesizedNew;

            result = join(
                'new',
                generateExpression(expr.callee, {
                    precedence: Precedence.New,
                    allowIn: true,
                    allowCall: false,
                    allowUnparenthesizedNew: allowUnparenthesizedNew && !parentheses && len === 0
                })
            );

            if (!allowUnparenthesizedNew || parentheses || len > 0) {
                result.push('(');
                for (i = 0; i < len; ++i) {
                    result.push(generateExpression(expr['arguments'][i], {
                        precedence: Precedence.Assignment,
                        allowIn: true,
                        allowCall: true
                    }));
                    if (i + 1 < len) {
                        result.push(',' + space);
                    }
                }
                result.push(')');
            }

            result = parenthesize(result, Precedence.New, precedence);
            break;

        case Syntax.MemberExpression:
            result = [generateExpression(expr.object, {
                precedence: Precedence.Call,
                allowIn: true,
                allowCall: allowCall,
                allowUnparenthesizedNew: false
            })];

            if (expr.computed) {
                result.push('[');
                result.push(generateExpression(expr.property, {
                    precedence: Precedence.Sequence,
                    allowIn: true,
                    allowCall: allowCall
                }));
                result.push(']');
            } else {
                if (expr.object.type === Syntax.Literal && typeof expr.object.value === 'number') {
                    fragment = toSourceNodeWhenNeeded(result).toString();
                    // When the following conditions are all true,
                    //   1. No floating point
                    //   2. Don't have exponents
                    //   3. The last character is a decimal digit
                    //   4. Not hexadecimal OR octal number literal
                    // we should add a floating point.
                    if (
                            fragment.indexOf('.') < 0 &&
                            !/[eExX]/.test(fragment) &&
                            esutils.code.isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) &&
                            !(fragment.length >= 2 && fragment.charCodeAt(0) === 48)  // '0'
                            ) {
                        result.push('.');
                    }
                }
                result.push('.');
                result.push(generateIdentifier(expr.property));
            }

            result = parenthesize(result, Precedence.Member, precedence);
            break;

        case Syntax.UnaryExpression:
            fragment = generateExpression(expr.argument, {
                precedence: Precedence.Unary,
                allowIn: true,
                allowCall: true
            });

            if (space === '') {
                result = join(expr.operator, fragment);
            } else {
                result = [expr.operator];
                if (expr.operator.length > 2) {
                    // delete, void, typeof
                    // get `typeof []`, not `typeof[]`
                    result = join(result, fragment);
                } else {
                    // Prevent inserting spaces between operator and argument if it is unnecessary
                    // like, `!cond`
                    leftSource = toSourceNodeWhenNeeded(result).toString();
                    leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
                    rightCharCode = fragment.toString().charCodeAt(0);

                    if (((leftCharCode === 0x2B  /* + */ || leftCharCode === 0x2D  /* - */) && leftCharCode === rightCharCode) ||
                            (esutils.code.isIdentifierPart(leftCharCode) && esutils.code.isIdentifierPart(rightCharCode))) {
                        result.push(noEmptySpace());
                        result.push(fragment);
                    } else {
                        result.push(fragment);
                    }
                }
            }
            result = parenthesize(result, Precedence.Unary, precedence);
            break;

        case Syntax.YieldExpression:
            if (expr.delegate) {
                result = 'yield*';
            } else {
                result = 'yield';
            }
            if (expr.argument) {
                result = join(
                    result,
                    generateExpression(expr.argument, {
                        precedence: Precedence.Yield,
                        allowIn: true,
                        allowCall: true
                    })
                );
            }
            result = parenthesize(result, Precedence.Yield, precedence);
            break;

        case Syntax.UpdateExpression:
            if (expr.prefix) {
                result = parenthesize(
                    [
                        expr.operator,
                        generateExpression(expr.argument, {
                            precedence: Precedence.Unary,
                            allowIn: true,
                            allowCall: true
                        })
                    ],
                    Precedence.Unary,
                    precedence
                );
            } else {
                result = parenthesize(
                    [
                        generateExpression(expr.argument, {
                            precedence: Precedence.Postfix,
                            allowIn: true,
                            allowCall: true
                        }),
                        expr.operator
                    ],
                    Precedence.Postfix,
                    precedence
                );
            }
            break;

        case Syntax.FunctionExpression:
            isGenerator = expr.generator && !extra.moz.starlessGenerator;
            result = isGenerator ? 'function*' : 'function';

            if (expr.id) {
                result = [result, (isGenerator) ? space : noEmptySpace(),
                          generateIdentifier(expr.id),
                          generateFunctionBody(expr)];
            } else {
                result = [result + space, generateFunctionBody(expr)];
            }

            break;

        case Syntax.ArrayPattern:
        case Syntax.ArrayExpression:
            if (!expr.elements.length) {
                result = '[]';
                break;
            }
            multiline = expr.elements.length > 1;
            result = ['[', multiline ? newline : ''];
            withIndent(function (indent) {
                for (i = 0, len = expr.elements.length; i < len; ++i) {
                    if (!expr.elements[i]) {
                        if (multiline) {
                            result.push(indent);
                        }
                        if (i + 1 === len) {
                            result.push(',');
                        }
                    } else {
                        result.push(multiline ? indent : '');
                        result.push(generateExpression(expr.elements[i], {
                            precedence: Precedence.Assignment,
                            allowIn: true,
                            allowCall: true
                        }));
                    }
                    if (i + 1 < len) {
                        result.push(',' + (multiline ? newline : space));
                    }
                }
            });
            if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
            }
            result.push(multiline ? base : '');
            result.push(']');
            break;

        case Syntax.Property:
            if (expr.kind === 'get' || expr.kind === 'set') {
                result = [
                    expr.kind, noEmptySpace(),
                    generateExpression(expr.key, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }),
                    generateFunctionBody(expr.value)
                ];
            } else {
                if (expr.shorthand) {
                    result = generateExpression(expr.key, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    });
                } else if (expr.method) {
                    result = [];
                    if (expr.value.generator) {
                        result.push('*');
                    }
                    result.push(generateExpression(expr.key, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }));
                    result.push(generateFunctionBody(expr.value));
                } else {
                    result = [
                        generateExpression(expr.key, {
                            precedence: Precedence.Sequence,
                            allowIn: true,
                            allowCall: true
                        }),
                        ':' + space,
                        generateExpression(expr.value, {
                            precedence: Precedence.Assignment,
                            allowIn: true,
                            allowCall: true
                        })
                    ];
                }
            }
            break;

        case Syntax.ObjectExpression:
            if (!expr.properties.length) {
                result = '{}';
                break;
            }
            multiline = expr.properties.length > 1;

            withIndent(function () {
                fragment = generateExpression(expr.properties[0], {
                    precedence: Precedence.Sequence,
                    allowIn: true,
                    allowCall: true,
                    type: Syntax.Property
                });
            });

            if (!multiline) {
                // issues 4
                // Do not transform from
                //   dejavu.Class.declare({
                //       method2: function () {}
                //   });
                // to
                //   dejavu.Class.declare({method2: function () {
                //       }});
                if (!hasLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                    result = [ '{', space, fragment, space, '}' ];
                    break;
                }
            }

            withIndent(function (indent) {
                result = [ '{', newline, indent, fragment ];

                if (multiline) {
                    result.push(',' + newline);
                    for (i = 1, len = expr.properties.length; i < len; ++i) {
                        result.push(indent);
                        result.push(generateExpression(expr.properties[i], {
                            precedence: Precedence.Sequence,
                            allowIn: true,
                            allowCall: true,
                            type: Syntax.Property
                        }));
                        if (i + 1 < len) {
                            result.push(',' + newline);
                        }
                    }
                }
            });

            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
            }
            result.push(base);
            result.push('}');
            break;

        case Syntax.ObjectPattern:
            if (!expr.properties.length) {
                result = '{}';
                break;
            }

            multiline = false;
            if (expr.properties.length === 1) {
                property = expr.properties[0];
                if (property.value.type !== Syntax.Identifier) {
                    multiline = true;
                }
            } else {
                for (i = 0, len = expr.properties.length; i < len; ++i) {
                    property = expr.properties[i];
                    if (!property.shorthand) {
                        multiline = true;
                        break;
                    }
                }
            }
            result = ['{', multiline ? newline : '' ];

            withIndent(function (indent) {
                for (i = 0, len = expr.properties.length; i < len; ++i) {
                    result.push(multiline ? indent : '');
                    result.push(generateExpression(expr.properties[i], {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }));
                    if (i + 1 < len) {
                        result.push(',' + (multiline ? newline : space));
                    }
                }
            });

            if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
            }
            result.push(multiline ? base : '');
            result.push('}');
            break;

        case Syntax.ThisExpression:
            result = 'this';
            break;

        case Syntax.Identifier:
            result = generateIdentifier(expr);
            break;

        case Syntax.Literal:
            result = generateLiteral(expr);
            break;

        case Syntax.GeneratorExpression:
        case Syntax.ComprehensionExpression:
            // GeneratorExpression should be parenthesized with (...), ComprehensionExpression with [...]
            // Due to https://bugzilla.mozilla.org/show_bug.cgi?id=883468 position of expr.body can differ in Spidermonkey and ES6
            result = (type === Syntax.GeneratorExpression) ? ['('] : ['['];

            if (extra.moz.comprehensionExpressionStartsWithAssignment) {
                fragment = generateExpression(expr.body, {
                    precedence: Precedence.Assignment,
                    allowIn: true,
                    allowCall: true
                });

                result.push(fragment);
            }

            if (expr.blocks) {
                withIndent(function () {
                    for (i = 0, len = expr.blocks.length; i < len; ++i) {
                        fragment = generateExpression(expr.blocks[i], {
                            precedence: Precedence.Sequence,
                            allowIn: true,
                            allowCall: true
                        });

                        if (i > 0 || extra.moz.comprehensionExpressionStartsWithAssignment) {
                            result = join(result, fragment);
                        } else {
                            result.push(fragment);
                        }
                    }
                });
            }

            if (expr.filter) {
                result = join(result, 'if' + space);
                fragment = generateExpression(expr.filter, {
                    precedence: Precedence.Sequence,
                    allowIn: true,
                    allowCall: true
                });
                if (extra.moz.parenthesizedComprehensionBlock) {
                    result = join(result, [ '(', fragment, ')' ]);
                } else {
                    result = join(result, fragment);
                }
            }

            if (!extra.moz.comprehensionExpressionStartsWithAssignment) {
                fragment = generateExpression(expr.body, {
                    precedence: Precedence.Assignment,
                    allowIn: true,
                    allowCall: true
                });

                result = join(result, fragment);
            }

            result.push((type === Syntax.GeneratorExpression) ? ')' : ']');
            break;

        case Syntax.ComprehensionBlock:
            if (expr.left.type === Syntax.VariableDeclaration) {
                fragment = [
                    expr.left.kind, noEmptySpace(),
                    generateStatement(expr.left.declarations[0], {
                        allowIn: false
                    })
                ];
            } else {
                fragment = generateExpression(expr.left, {
                    precedence: Precedence.Call,
                    allowIn: true,
                    allowCall: true
                });
            }

            fragment = join(fragment, expr.of ? 'of' : 'in');
            fragment = join(fragment, generateExpression(expr.right, {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
            }));

            if (extra.moz.parenthesizedComprehensionBlock) {
                result = [ 'for' + space + '(', fragment, ')' ];
            } else {
                result = join('for' + space, fragment);
            }
            break;

        default:
            throw new Error('Unknown expression type: ' + expr.type);
        }

        if (extra.comment) {
            result = addComments(expr,result);
        }
        return toSourceNodeWhenNeeded(result, expr);
    }

    function generateStatement(stmt, option) {
        var i,
            len,
            result,
            node,
            specifier,
            allowIn,
            functionBody,
            directiveContext,
            fragment,
            semicolon,
            isGenerator;

        allowIn = true;
        semicolon = ';';
        functionBody = false;
        directiveContext = false;
        if (option) {
            allowIn = option.allowIn === undefined || option.allowIn;
            if (!semicolons && option.semicolonOptional === true) {
                semicolon = '';
            }
            functionBody = option.functionBody;
            directiveContext = option.directiveContext;
        }

        switch (stmt.type) {
        case Syntax.BlockStatement:
            result = ['{', newline];

            withIndent(function () {
                for (i = 0, len = stmt.body.length; i < len; ++i) {
                    fragment = addIndent(generateStatement(stmt.body[i], {
                        semicolonOptional: i === len - 1,
                        directiveContext: functionBody
                    }));
                    result.push(fragment);
                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        result.push(newline);
                    }
                }
            });

            result.push(addIndent('}'));
            break;

        case Syntax.BreakStatement:
            if (stmt.label) {
                result = 'break ' + stmt.label.name + semicolon;
            } else {
                result = 'break' + semicolon;
            }
            break;

        case Syntax.ContinueStatement:
            if (stmt.label) {
                result = 'continue ' + stmt.label.name + semicolon;
            } else {
                result = 'continue' + semicolon;
            }
            break;

        case Syntax.DirectiveStatement:
            if (extra.raw && stmt.raw) {
                result = stmt.raw + semicolon;
            } else {
                result = escapeDirective(stmt.directive) + semicolon;
            }
            break;

        case Syntax.DoWhileStatement:
            // Because `do 42 while (cond)` is Syntax Error. We need semicolon.
            result = join('do', maybeBlock(stmt.body));
            result = maybeBlockSuffix(stmt.body, result);
            result = join(result, [
                'while' + space + '(',
                generateExpression(stmt.test, {
                    precedence: Precedence.Sequence,
                    allowIn: true,
                    allowCall: true
                }),
                ')' + semicolon
            ]);
            break;

        case Syntax.CatchClause:
            withIndent(function () {
                var guard;

                result = [
                    'catch' + space + '(',
                    generateExpression(stmt.param, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }),
                    ')'
                ];

                if (stmt.guard) {
                    guard = generateExpression(stmt.guard, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    });

                    result.splice(2, 0, ' if ', guard);
                }
            });
            result.push(maybeBlock(stmt.body));
            break;

        case Syntax.DebuggerStatement:
            result = 'debugger' + semicolon;
            break;

        case Syntax.EmptyStatement:
            result = ';';
            break;

        case Syntax.ExportDeclaration:
            result = 'export ';
            if (stmt.declaration) {
                // FunctionDeclaration or VariableDeclaration
                result = [result, generateStatement(stmt.declaration, { semicolonOptional: semicolon === '' })];
                break;
            }
            break;

        case Syntax.ExpressionStatement:
            result = [generateExpression(stmt.expression, {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
            })];
            // 12.4 '{', 'function' is not allowed in this position.
            // wrap expression with parentheses
            fragment = toSourceNodeWhenNeeded(result).toString();
            if (fragment.charAt(0) === '{' ||  // ObjectExpression
                    (fragment.slice(0, 8) === 'function' && '* ('.indexOf(fragment.charAt(8)) >= 0) ||  // function or generator
                    (directive && directiveContext && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === 'string')) {
                result = ['(', result, ')' + semicolon];
            } else {
                result.push(semicolon);
            }
            break;

        case Syntax.ImportDeclaration:
            // ES6: 15.2.1 valid import declarations:
            //     - import ImportClause FromClause ;
            //     - import ModuleSpecifier ;
            // If no ImportClause is present,
            // this should be `import ModuleSpecifier` so skip `from`
            //
            // ModuleSpecifier is StringLiteral.
            if (stmt.specifiers.length === 0) {
                // import ModuleSpecifier ;
                result = [
                    'import',
                    space,
                    generateLiteral(stmt.source)
                ];
            } else {
                // import ImportClause FromClause ;
                if (stmt.kind === 'default') {
                    // import ... from "...";
                    result = [
                        'import',
                        noEmptySpace(),
                        stmt.specifiers[0].id.name,
                        noEmptySpace()
                    ];
                } else {
                    // stmt.kind === 'named'
                    result = [
                        'import',
                        space,
                        '{',
                    ];

                    if (stmt.specifiers.length === 1) {
                        // import { ... } from "...";
                        specifier = stmt.specifiers[0];
                        result.push(space + specifier.id.name);
                        if (specifier.name) {
                            result.push(noEmptySpace() + 'as' + noEmptySpace() + specifier.name.name);
                        }
                        result.push(space + '}' + space);
                    } else {
                        // import {
                        //    ...,
                        //    ...,
                        // } from "...";
                        withIndent(function (indent) {
                            var i, iz;
                            result.push(newline);
                            for (i = 0, iz = stmt.specifiers.length; i < iz; ++i) {
                                specifier = stmt.specifiers[i];
                                result.push(indent + specifier.id.name);
                                if (specifier.name) {
                                    result.push(noEmptySpace() + 'as' + noEmptySpace() + specifier.name.name);
                                }

                                if (i + 1 < iz) {
                                    result.push(',' + newline);
                                }
                            }
                        });
                        if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                            result.push(newline);
                        }
                        result.push(base + '}' + space);
                    }
                }

                result.push('from' + space);
                result.push(generateLiteral(stmt.source));
            }
            result.push(semicolon);
            break;

        case Syntax.VariableDeclarator:
            if (stmt.init) {
                result = [
                    generateExpression(stmt.id, {
                        precedence: Precedence.Assignment,
                        allowIn: allowIn,
                        allowCall: true
                    }),
                    space,
                    '=',
                    space,
                    generateExpression(stmt.init, {
                        precedence: Precedence.Assignment,
                        allowIn: allowIn,
                        allowCall: true
                    })
                ];
            } else {
                result = generatePattern(stmt.id, {
                    precedence: Precedence.Assignment,
                    allowIn: allowIn
                });
            }
            break;

        case Syntax.VariableDeclaration:
            result = [stmt.kind];
            // special path for
            // var x = function () {
            // };
            if (stmt.declarations.length === 1 && stmt.declarations[0].init &&
                    stmt.declarations[0].init.type === Syntax.FunctionExpression) {
                result.push(noEmptySpace());
                result.push(generateStatement(stmt.declarations[0], {
                    allowIn: allowIn
                }));
            } else {
                // VariableDeclarator is typed as Statement,
                // but joined with comma (not LineTerminator).
                // So if comment is attached to target node, we should specialize.
                withIndent(function () {
                    node = stmt.declarations[0];
                    if (extra.comment && node.leadingComments) {
                        result.push('\n');
                        result.push(addIndent(generateStatement(node, {
                            allowIn: allowIn
                        })));
                    } else {
                        result.push(noEmptySpace());
                        result.push(generateStatement(node, {
                            allowIn: allowIn
                        }));
                    }

                    for (i = 1, len = stmt.declarations.length; i < len; ++i) {
                        node = stmt.declarations[i];
                        if (extra.comment && node.leadingComments) {
                            result.push(',' + newline);
                            result.push(addIndent(generateStatement(node, {
                                allowIn: allowIn
                            })));
                        } else {
                            result.push(',' + space);
                            result.push(generateStatement(node, {
                                allowIn: allowIn
                            }));
                        }
                    }
                });
            }
            result.push(semicolon);
            break;

        case Syntax.ThrowStatement:
            result = [join(
                'throw',
                generateExpression(stmt.argument, {
                    precedence: Precedence.Sequence,
                    allowIn: true,
                    allowCall: true
                })
            ), semicolon];
            break;

        case Syntax.TryStatement:
            result = ['try', maybeBlock(stmt.block)];
            result = maybeBlockSuffix(stmt.block, result);

            if (stmt.handlers) {
                // old interface
                for (i = 0, len = stmt.handlers.length; i < len; ++i) {
                    result = join(result, generateStatement(stmt.handlers[i]));
                    if (stmt.finalizer || i + 1 !== len) {
                        result = maybeBlockSuffix(stmt.handlers[i].body, result);
                    }
                }
            } else {
                stmt.guardedHandlers = stmt.guardedHandlers || [];

                for (i = 0, len = stmt.guardedHandlers.length; i < len; ++i) {
                    result = join(result, generateStatement(stmt.guardedHandlers[i]));
                    if (stmt.finalizer || i + 1 !== len) {
                        result = maybeBlockSuffix(stmt.guardedHandlers[i].body, result);
                    }
                }

                // new interface
                if (stmt.handler) {
                    if (isArray(stmt.handler)) {
                        for (i = 0, len = stmt.handler.length; i < len; ++i) {
                            result = join(result, generateStatement(stmt.handler[i]));
                            if (stmt.finalizer || i + 1 !== len) {
                                result = maybeBlockSuffix(stmt.handler[i].body, result);
                            }
                        }
                    } else {
                        result = join(result, generateStatement(stmt.handler));
                        if (stmt.finalizer) {
                            result = maybeBlockSuffix(stmt.handler.body, result);
                        }
                    }
                }
            }
            if (stmt.finalizer) {
                result = join(result, ['finally', maybeBlock(stmt.finalizer)]);
            }
            break;

        case Syntax.SwitchStatement:
            withIndent(function () {
                result = [
                    'switch' + space + '(',
                    generateExpression(stmt.discriminant, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }),
                    ')' + space + '{' + newline
                ];
            });
            if (stmt.cases) {
                for (i = 0, len = stmt.cases.length; i < len; ++i) {
                    fragment = addIndent(generateStatement(stmt.cases[i], {semicolonOptional: i === len - 1}));
                    result.push(fragment);
                    if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        result.push(newline);
                    }
                }
            }
            result.push(addIndent('}'));
            break;

        case Syntax.SwitchCase:
            withIndent(function () {
                if (stmt.test) {
                    result = [
                        join('case', generateExpression(stmt.test, {
                            precedence: Precedence.Sequence,
                            allowIn: true,
                            allowCall: true
                        })),
                        ':'
                    ];
                } else {
                    result = ['default:'];
                }

                i = 0;
                len = stmt.consequent.length;
                if (len && stmt.consequent[0].type === Syntax.BlockStatement) {
                    fragment = maybeBlock(stmt.consequent[0]);
                    result.push(fragment);
                    i = 1;
                }

                if (i !== len && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                    result.push(newline);
                }

                for (; i < len; ++i) {
                    fragment = addIndent(generateStatement(stmt.consequent[i], {semicolonOptional: i === len - 1 && semicolon === ''}));
                    result.push(fragment);
                    if (i + 1 !== len && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                        result.push(newline);
                    }
                }
            });
            break;

        case Syntax.IfStatement:
            withIndent(function () {
                result = [
                    'if' + space + '(',
                    generateExpression(stmt.test, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }),
                    ')'
                ];
            });
            if (stmt.alternate) {
                result.push(maybeBlock(stmt.consequent));
                result = maybeBlockSuffix(stmt.consequent, result);
                if (stmt.alternate.type === Syntax.IfStatement) {
                    result = join(result, ['else ', generateStatement(stmt.alternate, {semicolonOptional: semicolon === ''})]);
                } else {
                    result = join(result, join('else', maybeBlock(stmt.alternate, semicolon === '')));
                }
            } else {
                result.push(maybeBlock(stmt.consequent, semicolon === ''));
            }
            break;

        case Syntax.ForStatement:
            withIndent(function () {
                result = ['for' + space + '('];
                if (stmt.init) {
                    if (stmt.init.type === Syntax.VariableDeclaration) {
                        result.push(generateStatement(stmt.init, {allowIn: false}));
                    } else {
                        result.push(generateExpression(stmt.init, {
                            precedence: Precedence.Sequence,
                            allowIn: false,
                            allowCall: true
                        }));
                        result.push(';');
                    }
                } else {
                    result.push(';');
                }

                if (stmt.test) {
                    result.push(space);
                    result.push(generateExpression(stmt.test, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }));
                    result.push(';');
                } else {
                    result.push(';');
                }

                if (stmt.update) {
                    result.push(space);
                    result.push(generateExpression(stmt.update, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }));
                    result.push(')');
                } else {
                    result.push(')');
                }
            });

            result.push(maybeBlock(stmt.body, semicolon === ''));
            break;

        case Syntax.ForInStatement:
            result = generateIterationForStatement('in', stmt, semicolon === '');
            break;

        case Syntax.ForOfStatement:
            result = generateIterationForStatement('of', stmt, semicolon === '');
            break;

        case Syntax.LabeledStatement:
            result = [stmt.label.name + ':', maybeBlock(stmt.body, semicolon === '')];
            break;

        case Syntax.Program:
            len = stmt.body.length;
            result = [safeConcatenation && len > 0 ? '\n' : ''];
            for (i = 0; i < len; ++i) {
                fragment = addIndent(
                    generateStatement(stmt.body[i], {
                        semicolonOptional: !safeConcatenation && i === len - 1,
                        directiveContext: true
                    })
                );
                result.push(fragment);
                if (i + 1 < len && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                    result.push(newline);
                }
            }
            break;

        case Syntax.FunctionDeclaration:
            isGenerator = stmt.generator && !extra.moz.starlessGenerator;
            result = [
                (isGenerator ? 'function*' : 'function'),
                (isGenerator ? space : noEmptySpace()),
                generateIdentifier(stmt.id),
                generateFunctionBody(stmt)
            ];
            break;

        case Syntax.ReturnStatement:
            if (stmt.argument) {
                result = [join(
                    'return',
                    generateExpression(stmt.argument, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    })
                ), semicolon];
            } else {
                result = ['return' + semicolon];
            }
            break;

        case Syntax.WhileStatement:
            withIndent(function () {
                result = [
                    'while' + space + '(',
                    generateExpression(stmt.test, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }),
                    ')'
                ];
            });
            result.push(maybeBlock(stmt.body, semicolon === ''));
            break;

        case Syntax.WithStatement:
            withIndent(function () {
                result = [
                    'with' + space + '(',
                    generateExpression(stmt.object, {
                        precedence: Precedence.Sequence,
                        allowIn: true,
                        allowCall: true
                    }),
                    ')'
                ];
            });
            result.push(maybeBlock(stmt.body, semicolon === ''));
            break;

        default:
            throw new Error('Unknown statement type: ' + stmt.type);
        }

        // Attach comments

        if (extra.comment) {
            result = addComments(stmt, result);
        }

        fragment = toSourceNodeWhenNeeded(result).toString();
        if (stmt.type === Syntax.Program && !safeConcatenation && newline === '' &&  fragment.charAt(fragment.length - 1) === '\n') {
            result = sourceMap ? toSourceNodeWhenNeeded(result).replaceRight(/\s+$/, '') : fragment.replace(/\s+$/, '');
        }

        return toSourceNodeWhenNeeded(result, stmt);
    }

    function generate(node, options) {
        var defaultOptions = getDefaultOptions(), result, pair;

        if (options != null) {
            // Obsolete options
            //
            //   `options.indent`
            //   `options.base`
            //
            // Instead of them, we can use `option.format.indent`.
            if (typeof options.indent === 'string') {
                defaultOptions.format.indent.style = options.indent;
            }
            if (typeof options.base === 'number') {
                defaultOptions.format.indent.base = options.base;
            }
            options = updateDeeply(defaultOptions, options);
            indent = options.format.indent.style;
            if (typeof options.base === 'string') {
                base = options.base;
            } else {
                base = stringRepeat(indent, options.format.indent.base);
            }
        } else {
            options = defaultOptions;
            indent = options.format.indent.style;
            base = stringRepeat(indent, options.format.indent.base);
        }
        json = options.format.json;
        renumber = options.format.renumber;
        hexadecimal = json ? false : options.format.hexadecimal;
        quotes = json ? 'double' : options.format.quotes;
        escapeless = options.format.escapeless;
        newline = options.format.newline;
        space = options.format.space;
        if (options.format.compact) {
            newline = space = indent = base = '';
        }
        parentheses = options.format.parentheses;
        semicolons = options.format.semicolons;
        safeConcatenation = options.format.safeConcatenation;
        directive = options.directive;
        parse = json ? null : options.parse;
        sourceMap = options.sourceMap;
        extra = options;

        if (sourceMap) {
            if (!exports.browser) {
                // We assume environment is node.js
                // And prevent from including source-map by browserify
                SourceNode = require('source-map').SourceNode;
            } else {
                SourceNode = global.sourceMap.SourceNode;
            }
        }

        switch (node.type) {
        case Syntax.BlockStatement:
        case Syntax.BreakStatement:
        case Syntax.CatchClause:
        case Syntax.ContinueStatement:
        case Syntax.DirectiveStatement:
        case Syntax.DoWhileStatement:
        case Syntax.DebuggerStatement:
        case Syntax.EmptyStatement:
        case Syntax.ExpressionStatement:
        case Syntax.ForStatement:
        case Syntax.ForInStatement:
        case Syntax.ForOfStatement:
        case Syntax.FunctionDeclaration:
        case Syntax.IfStatement:
        case Syntax.LabeledStatement:
        case Syntax.Program:
        case Syntax.ReturnStatement:
        case Syntax.SwitchStatement:
        case Syntax.SwitchCase:
        case Syntax.ThrowStatement:
        case Syntax.TryStatement:
        case Syntax.VariableDeclaration:
        case Syntax.VariableDeclarator:
        case Syntax.WhileStatement:
        case Syntax.WithStatement:
            result = generateStatement(node);
            break;

        case Syntax.AssignmentExpression:
        case Syntax.ArrayExpression:
        case Syntax.ArrayPattern:
        case Syntax.BinaryExpression:
        case Syntax.CallExpression:
        case Syntax.ConditionalExpression:
        case Syntax.FunctionExpression:
        case Syntax.Identifier:
        case Syntax.Literal:
        case Syntax.LogicalExpression:
        case Syntax.MemberExpression:
        case Syntax.NewExpression:
        case Syntax.ObjectExpression:
        case Syntax.ObjectPattern:
        case Syntax.Property:
        case Syntax.SequenceExpression:
        case Syntax.ThisExpression:
        case Syntax.UnaryExpression:
        case Syntax.UpdateExpression:
        case Syntax.YieldExpression:

            result = generateExpression(node, {
                precedence: Precedence.Sequence,
                allowIn: true,
                allowCall: true
            });
            break;

        default:
            throw new Error('Unknown node type: ' + node.type);
        }

        if (!sourceMap) {
            pair = {code: result.toString(), map: null};
            return options.sourceMapWithCode ? pair : pair.code;
        }


        pair = result.toStringWithSourceMap({
            file: options.file,
            sourceRoot: options.sourceMapRoot
        });

        if (options.sourceContent) {
            pair.map.setSourceContent(options.sourceMap,
                                      options.sourceContent);
        }

        if (options.sourceMapWithCode) {
            return pair;
        }

        return pair.map.toString();
    }

    FORMAT_MINIFY = {
        indent: {
            style: '',
            base: 0
        },
        renumber: true,
        hexadecimal: true,
        quotes: 'auto',
        escapeless: true,
        compact: true,
        parentheses: false,
        semicolons: false
    };

    FORMAT_DEFAULTS = getDefaultOptions().format;

    exports.version = require('./package.json').version;
    exports.generate = generate;
    exports.attachComments = estraverse.attachComments;
    exports.Precedence = updateDeeply({}, Precedence);
    exports.browser = false;
    exports.FORMAT_MINIFY = FORMAT_MINIFY;
    exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{"./package.json":23,"estraverse":24,"esutils":27,"source-map":31}],23:[function(require,module,exports){
module.exports={
  "_from": "git://github.com/Constellation/escodegen.git#41fbbe5058849b5e082542c5cfce76c2d67792e6",
  "_id": "escodegen@1.3.4-dev",
  "_inBundle": false,
  "_location": "/escodegen",
  "_phantomChildren": {},
  "_requested": {
    "type": "git",
    "raw": "escodegen@git://github.com/Constellation/escodegen.git#41fbbe5058849b5e082542c5cfce76c2d67792e6",
    "name": "escodegen",
    "escapedName": "escodegen",
    "rawSpec": "git://github.com/Constellation/escodegen.git#41fbbe5058849b5e082542c5cfce76c2d67792e6",
    "saveSpec": "git://github.com/Constellation/escodegen.git#41fbbe5058849b5e082542c5cfce76c2d67792e6",
    "fetchSpec": "git://github.com/Constellation/escodegen.git",
    "gitCommittish": "41fbbe5058849b5e082542c5cfce76c2d67792e6"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "git://github.com/Constellation/escodegen.git#41fbbe5058849b5e082542c5cfce76c2d67792e6",
  "_spec": "escodegen@git://github.com/Constellation/escodegen.git#41fbbe5058849b5e082542c5cfce76c2d67792e6",
  "_where": "/home/chrism/dev/wisp",
  "bin": {
    "esgenerate": "./bin/esgenerate.js",
    "escodegen": "./bin/escodegen.js"
  },
  "bugs": {
    "url": "https://github.com/Constellation/escodegen/issues"
  },
  "bundleDependencies": false,
  "dependencies": {
    "esprima": "~1.1.1",
    "estraverse": "~1.5.0",
    "esutils": "~1.0.0",
    "source-map": "~0.1.33"
  },
  "deprecated": false,
  "description": "ECMAScript code generator",
  "devDependencies": {
    "bluebird": "~1.2.0",
    "bower-registry-client": "~0.2.0",
    "chai": "~1.7.2",
    "commonjs-everywhere": "~0.9.6",
    "esprima-moz": "*",
    "gulp": "~3.5.0",
    "gulp-eslint": "~0.1.2",
    "gulp-jshint": "~1.4.0",
    "gulp-mocha": "~0.4.1",
    "jshint-stylish": "~0.1.5",
    "semver": "*"
  },
  "engines": {
    "node": ">=0.10.0"
  },
  "homepage": "http://github.com/Constellation/escodegen",
  "licenses": [
    {
      "type": "BSD",
      "url": "http://github.com/Constellation/escodegen/raw/master/LICENSE.BSD"
    }
  ],
  "main": "escodegen.js",
  "maintainers": [
    {
      "name": "Yusuke Suzuki",
      "email": "utatane.tea@gmail.com",
      "url": "http://github.com/Constellation"
    }
  ],
  "name": "escodegen",
  "optionalDependencies": {
    "source-map": "~0.1.33"
  },
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/Constellation/escodegen.git"
  },
  "scripts": {
    "build": "cjsify -a path: tools/entry-point.js > escodegen.browser.js",
    "build-min": "cjsify -ma path: tools/entry-point.js > escodegen.browser.min.js",
    "lint": "gulp lint",
    "release": "node tools/release.js",
    "test": "gulp travis",
    "unit-test": "gulp test"
  },
  "version": "1.3.4-dev"
}

},{}],24:[function(require,module,exports){
/*
  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/*jslint vars:false, bitwise:true*/
/*jshint indent:4*/
/*global exports:true, define:true*/
(function (root, factory) {
    'use strict';

    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
    // and plain browser loading,
    if (typeof define === 'function' && define.amd) {
        define(['exports'], factory);
    } else if (typeof exports !== 'undefined') {
        factory(exports);
    } else {
        factory((root.estraverse = {}));
    }
}(this, function (exports) {
    'use strict';

    var Syntax,
        isArray,
        VisitorOption,
        VisitorKeys,
        BREAK,
        SKIP;

    Syntax = {
        AssignmentExpression: 'AssignmentExpression',
        ArrayExpression: 'ArrayExpression',
        ArrayPattern: 'ArrayPattern',
        ArrowFunctionExpression: 'ArrowFunctionExpression',
        BlockStatement: 'BlockStatement',
        BinaryExpression: 'BinaryExpression',
        BreakStatement: 'BreakStatement',
        CallExpression: 'CallExpression',
        CatchClause: 'CatchClause',
        ClassBody: 'ClassBody',
        ClassDeclaration: 'ClassDeclaration',
        ClassExpression: 'ClassExpression',
        ConditionalExpression: 'ConditionalExpression',
        ContinueStatement: 'ContinueStatement',
        DebuggerStatement: 'DebuggerStatement',
        DirectiveStatement: 'DirectiveStatement',
        DoWhileStatement: 'DoWhileStatement',
        EmptyStatement: 'EmptyStatement',
        ExpressionStatement: 'ExpressionStatement',
        ForStatement: 'ForStatement',
        ForInStatement: 'ForInStatement',
        FunctionDeclaration: 'FunctionDeclaration',
        FunctionExpression: 'FunctionExpression',
        Identifier: 'Identifier',
        IfStatement: 'IfStatement',
        Literal: 'Literal',
        LabeledStatement: 'LabeledStatement',
        LogicalExpression: 'LogicalExpression',
        MemberExpression: 'MemberExpression',
        MethodDefinition: 'MethodDefinition',
        NewExpression: 'NewExpression',
        ObjectExpression: 'ObjectExpression',
        ObjectPattern: 'ObjectPattern',
        Program: 'Program',
        Property: 'Property',
        ReturnStatement: 'ReturnStatement',
        SequenceExpression: 'SequenceExpression',
        SwitchStatement: 'SwitchStatement',
        SwitchCase: 'SwitchCase',
        ThisExpression: 'ThisExpression',
        ThrowStatement: 'ThrowStatement',
        TryStatement: 'TryStatement',
        UnaryExpression: 'UnaryExpression',
        UpdateExpression: 'UpdateExpression',
        VariableDeclaration: 'VariableDeclaration',
        VariableDeclarator: 'VariableDeclarator',
        WhileStatement: 'WhileStatement',
        WithStatement: 'WithStatement',
        YieldExpression: 'YieldExpression'
    };

    function ignoreJSHintError() { }

    isArray = Array.isArray;
    if (!isArray) {
        isArray = function isArray(array) {
            return Object.prototype.toString.call(array) === '[object Array]';
        };
    }

    function deepCopy(obj) {
        var ret = {}, key, val;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                val = obj[key];
                if (typeof val === 'object' && val !== null) {
                    ret[key] = deepCopy(val);
                } else {
                    ret[key] = val;
                }
            }
        }
        return ret;
    }

    function shallowCopy(obj) {
        var ret = {}, key;
        for (key in obj) {
            if (obj.hasOwnProperty(key)) {
                ret[key] = obj[key];
            }
        }
        return ret;
    }
    ignoreJSHintError(shallowCopy);

    // based on LLVM libc++ upper_bound / lower_bound
    // MIT License

    function upperBound(array, func) {
        var diff, len, i, current;

        len = array.length;
        i = 0;

        while (len) {
            diff = len >>> 1;
            current = i + diff;
            if (func(array[current])) {
                len = diff;
            } else {
                i = current + 1;
                len -= diff + 1;
            }
        }
        return i;
    }

    function lowerBound(array, func) {
        var diff, len, i, current;

        len = array.length;
        i = 0;

        while (len) {
            diff = len >>> 1;
            current = i + diff;
            if (func(array[current])) {
                i = current + 1;
                len -= diff + 1;
            } else {
                len = diff;
            }
        }
        return i;
    }
    ignoreJSHintError(lowerBound);

    VisitorKeys = {
        AssignmentExpression: ['left', 'right'],
        ArrayExpression: ['elements'],
        ArrayPattern: ['elements'],
        ArrowFunctionExpression: ['params', 'defaults', 'rest', 'body'],
        BlockStatement: ['body'],
        BinaryExpression: ['left', 'right'],
        BreakStatement: ['label'],
        CallExpression: ['callee', 'arguments'],
        CatchClause: ['param', 'body'],
        ClassBody: ['body'],
        ClassDeclaration: ['id', 'body', 'superClass'],
        ClassExpression: ['id', 'body', 'superClass'],
        ConditionalExpression: ['test', 'consequent', 'alternate'],
        ContinueStatement: ['label'],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: ['body', 'test'],
        EmptyStatement: [],
        ExpressionStatement: ['expression'],
        ForStatement: ['init', 'test', 'update', 'body'],
        ForInStatement: ['left', 'right', 'body'],
        ForOfStatement: ['left', 'right', 'body'],
        FunctionDeclaration: ['id', 'params', 'defaults', 'rest', 'body'],
        FunctionExpression: ['id', 'params', 'defaults', 'rest', 'body'],
        Identifier: [],
        IfStatement: ['test', 'consequent', 'alternate'],
        Literal: [],
        LabeledStatement: ['label', 'body'],
        LogicalExpression: ['left', 'right'],
        MemberExpression: ['object', 'property'],
        MethodDefinition: ['key', 'value'],
        NewExpression: ['callee', 'arguments'],
        ObjectExpression: ['properties'],
        ObjectPattern: ['properties'],
        Program: ['body'],
        Property: ['key', 'value'],
        ReturnStatement: ['argument'],
        SequenceExpression: ['expressions'],
        SwitchStatement: ['discriminant', 'cases'],
        SwitchCase: ['test', 'consequent'],
        ThisExpression: [],
        ThrowStatement: ['argument'],
        TryStatement: ['block', 'handlers', 'handler', 'guardedHandlers', 'finalizer'],
        UnaryExpression: ['argument'],
        UpdateExpression: ['argument'],
        VariableDeclaration: ['declarations'],
        VariableDeclarator: ['id', 'init'],
        WhileStatement: ['test', 'body'],
        WithStatement: ['object', 'body'],
        YieldExpression: ['argument']
    };

    // unique id
    BREAK = {};
    SKIP = {};

    VisitorOption = {
        Break: BREAK,
        Skip: SKIP
    };

    function Reference(parent, key) {
        this.parent = parent;
        this.key = key;
    }

    Reference.prototype.replace = function replace(node) {
        this.parent[this.key] = node;
    };

    function Element(node, path, wrap, ref) {
        this.node = node;
        this.path = path;
        this.wrap = wrap;
        this.ref = ref;
    }

    function Controller() { }

    // API:
    // return property path array from root to current node
    Controller.prototype.path = function path() {
        var i, iz, j, jz, result, element;

        function addToPath(result, path) {
            if (isArray(path)) {
                for (j = 0, jz = path.length; j < jz; ++j) {
                    result.push(path[j]);
                }
            } else {
                result.push(path);
            }
        }

        // root node
        if (!this.__current.path) {
            return null;
        }

        // first node is sentinel, second node is root element
        result = [];
        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
            element = this.__leavelist[i];
            addToPath(result, element.path);
        }
        addToPath(result, this.__current.path);
        return result;
    };

    // API:
    // return array of parent elements
    Controller.prototype.parents = function parents() {
        var i, iz, result;

        // first node is sentinel
        result = [];
        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
            result.push(this.__leavelist[i].node);
        }

        return result;
    };

    // API:
    // return current node
    Controller.prototype.current = function current() {
        return this.__current.node;
    };

    Controller.prototype.__execute = function __execute(callback, element) {
        var previous, result;

        result = undefined;

        previous  = this.__current;
        this.__current = element;
        this.__state = null;
        if (callback) {
            result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
        }
        this.__current = previous;

        return result;
    };

    // API:
    // notify control skip / break
    Controller.prototype.notify = function notify(flag) {
        this.__state = flag;
    };

    // API:
    // skip child nodes of current node
    Controller.prototype.skip = function () {
        this.notify(SKIP);
    };

    // API:
    // break traversals
    Controller.prototype['break'] = function () {
        this.notify(BREAK);
    };

    Controller.prototype.__initialize = function(root, visitor) {
        this.visitor = visitor;
        this.root = root;
        this.__worklist = [];
        this.__leavelist = [];
        this.__current = null;
        this.__state = null;
    };

    Controller.prototype.traverse = function traverse(root, visitor) {
        var worklist,
            leavelist,
            element,
            node,
            nodeType,
            ret,
            key,
            current,
            current2,
            candidates,
            candidate,
            sentinel;

        this.__initialize(root, visitor);

        sentinel = {};

        // reference
        worklist = this.__worklist;
        leavelist = this.__leavelist;

        // initialize
        worklist.push(new Element(root, null, null, null));
        leavelist.push(new Element(null, null, null, null));

        while (worklist.length) {
            element = worklist.pop();

            if (element === sentinel) {
                element = leavelist.pop();

                ret = this.__execute(visitor.leave, element);

                if (this.__state === BREAK || ret === BREAK) {
                    return;
                }
                continue;
            }

            if (element.node) {

                ret = this.__execute(visitor.enter, element);

                if (this.__state === BREAK || ret === BREAK) {
                    return;
                }

                worklist.push(sentinel);
                leavelist.push(element);

                if (this.__state === SKIP || ret === SKIP) {
                    continue;
                }

                node = element.node;
                nodeType = element.wrap || node.type;
                candidates = VisitorKeys[nodeType];

                current = candidates.length;
                while ((current -= 1) >= 0) {
                    key = candidates[current];
                    candidate = node[key];
                    if (!candidate) {
                        continue;
                    }

                    if (!isArray(candidate)) {
                        worklist.push(new Element(candidate, key, null, null));
                        continue;
                    }

                    current2 = candidate.length;
                    while ((current2 -= 1) >= 0) {
                        if (!candidate[current2]) {
                            continue;
                        }
                        if ((nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === candidates[current]) {
                            element = new Element(candidate[current2], [key, current2], 'Property', null);
                        } else {
                            element = new Element(candidate[current2], [key, current2], null, null);
                        }
                        worklist.push(element);
                    }
                }
            }
        }
    };

    Controller.prototype.replace = function replace(root, visitor) {
        var worklist,
            leavelist,
            node,
            nodeType,
            target,
            element,
            current,
            current2,
            candidates,
            candidate,
            sentinel,
            outer,
            key;

        this.__initialize(root, visitor);

        sentinel = {};

        // reference
        worklist = this.__worklist;
        leavelist = this.__leavelist;

        // initialize
        outer = {
            root: root
        };
        element = new Element(root, null, null, new Reference(outer, 'root'));
        worklist.push(element);
        leavelist.push(element);

        while (worklist.length) {
            element = worklist.pop();

            if (element === sentinel) {
                element = leavelist.pop();

                target = this.__execute(visitor.leave, element);

                // node may be replaced with null,
                // so distinguish between undefined and null in this place
                if (target !== undefined && target !== BREAK && target !== SKIP) {
                    // replace
                    element.ref.replace(target);
                }

                if (this.__state === BREAK || target === BREAK) {
                    return outer.root;
                }
                continue;
            }

            target = this.__execute(visitor.enter, element);

            // node may be replaced with null,
            // so distinguish between undefined and null in this place
            if (target !== undefined && target !== BREAK && target !== SKIP) {
                // replace
                element.ref.replace(target);
                element.node = target;
            }

            if (this.__state === BREAK || target === BREAK) {
                return outer.root;
            }

            // node may be null
            node = element.node;
            if (!node) {
                continue;
            }

            worklist.push(sentinel);
            leavelist.push(element);

            if (this.__state === SKIP || target === SKIP) {
                continue;
            }

            nodeType = element.wrap || node.type;
            candidates = VisitorKeys[nodeType];

            current = candidates.length;
            while ((current -= 1) >= 0) {
                key = candidates[current];
                candidate = node[key];
                if (!candidate) {
                    continue;
                }

                if (!isArray(candidate)) {
                    worklist.push(new Element(candidate, key, null, new Reference(node, key)));
                    continue;
                }

                current2 = candidate.length;
                while ((current2 -= 1) >= 0) {
                    if (!candidate[current2]) {
                        continue;
                    }
                    if (nodeType === Syntax.ObjectExpression && 'properties' === candidates[current]) {
                        element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));
                    } else {
                        element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
                    }
                    worklist.push(element);
                }
            }
        }

        return outer.root;
    };

    function traverse(root, visitor) {
        var controller = new Controller();
        return controller.traverse(root, visitor);
    }

    function replace(root, visitor) {
        var controller = new Controller();
        return controller.replace(root, visitor);
    }

    function extendCommentRange(comment, tokens) {
        var target;

        target = upperBound(tokens, function search(token) {
            return token.range[0] > comment.range[0];
        });

        comment.extendedRange = [comment.range[0], comment.range[1]];

        if (target !== tokens.length) {
            comment.extendedRange[1] = tokens[target].range[0];
        }

        target -= 1;
        if (target >= 0) {
            comment.extendedRange[0] = tokens[target].range[1];
        }

        return comment;
    }

    function attachComments(tree, providedComments, tokens) {
        // At first, we should calculate extended comment ranges.
        var comments = [], comment, len, i, cursor;

        if (!tree.range) {
            throw new Error('attachComments needs range information');
        }

        // tokens array is empty, we attach comments to tree as 'leadingComments'
        if (!tokens.length) {
            if (providedComments.length) {
                for (i = 0, len = providedComments.length; i < len; i += 1) {
                    comment = deepCopy(providedComments[i]);
                    comment.extendedRange = [0, tree.range[0]];
                    comments.push(comment);
                }
                tree.leadingComments = comments;
            }
            return tree;
        }

        for (i = 0, len = providedComments.length; i < len; i += 1) {
            comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
        }

        // This is based on John Freeman's implementation.
        cursor = 0;
        traverse(tree, {
            enter: function (node) {
                var comment;

                while (cursor < comments.length) {
                    comment = comments[cursor];
                    if (comment.extendedRange[1] > node.range[0]) {
                        break;
                    }

                    if (comment.extendedRange[1] === node.range[0]) {
                        if (!node.leadingComments) {
                            node.leadingComments = [];
                        }
                        node.leadingComments.push(comment);
                        comments.splice(cursor, 1);
                    } else {
                        cursor += 1;
                    }
                }

                // already out of owned node
                if (cursor === comments.length) {
                    return VisitorOption.Break;
                }

                if (comments[cursor].extendedRange[0] > node.range[1]) {
                    return VisitorOption.Skip;
                }
            }
        });

        cursor = 0;
        traverse(tree, {
            leave: function (node) {
                var comment;

                while (cursor < comments.length) {
                    comment = comments[cursor];
                    if (node.range[1] < comment.extendedRange[0]) {
                        break;
                    }

                    if (node.range[1] === comment.extendedRange[0]) {
                        if (!node.trailingComments) {
                            node.trailingComments = [];
                        }
                        node.trailingComments.push(comment);
                        comments.splice(cursor, 1);
                    } else {
                        cursor += 1;
                    }
                }

                // already out of owned node
                if (cursor === comments.length) {
                    return VisitorOption.Break;
                }

                if (comments[cursor].extendedRange[0] > node.range[1]) {
                    return VisitorOption.Skip;
                }
            }
        });

        return tree;
    }

    exports.version = '1.5.1-dev';
    exports.Syntax = Syntax;
    exports.traverse = traverse;
    exports.replace = replace;
    exports.attachComments = attachComments;
    exports.VisitorKeys = VisitorKeys;
    exports.VisitorOption = VisitorOption;
    exports.Controller = Controller;
}));
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],25:[function(require,module,exports){
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    var Regex;

    // See also tools/generate-unicode-regex.py.
    Regex = {
        NonAsciiIdentifierStart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]'),
        NonAsciiIdentifierPart: new RegExp('[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0\u08A2-\u08AC\u08E4-\u08FE\u0900-\u0963\u0966-\u096F\u0971-\u0977\u0979-\u097F\u0981-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C01-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C82\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D02\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191C\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1D00-\u1DE6\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA697\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A\uAA7B\uAA80-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE26\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]')
    };

    function isDecimalDigit(ch) {
        return (ch >= 48 && ch <= 57);   // 0..9
    }

    function isHexDigit(ch) {
        return isDecimalDigit(ch) || (97 <= ch && ch <= 102) || (65 <= ch && ch <= 70);
    }

    function isOctalDigit(ch) {
        return (ch >= 48 && ch <= 55);   // 0..7
    }

    // 7.2 White Space

    function isWhiteSpace(ch) {
        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||
            (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);
    }

    // 7.3 Line Terminators

    function isLineTerminator(ch) {
        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);
    }

    // 7.6 Identifier Names and Identifiers

    function isIdentifierStart(ch) {
        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)
            (ch >= 65 && ch <= 90) ||         // A..Z
            (ch >= 97 && ch <= 122) ||        // a..z
            (ch === 92) ||                    // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));
    }

    function isIdentifierPart(ch) {
        return (ch === 36) || (ch === 95) ||  // $ (dollar) and _ (underscore)
            (ch >= 65 && ch <= 90) ||         // A..Z
            (ch >= 97 && ch <= 122) ||        // a..z
            (ch >= 48 && ch <= 57) ||         // 0..9
            (ch === 92) ||                    // \ (backslash)
            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));
    }

    module.exports = {
        isDecimalDigit: isDecimalDigit,
        isHexDigit: isHexDigit,
        isOctalDigit: isOctalDigit,
        isWhiteSpace: isWhiteSpace,
        isLineTerminator: isLineTerminator,
        isIdentifierStart: isIdentifierStart,
        isIdentifierPart: isIdentifierPart
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{}],26:[function(require,module,exports){
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    var code = require('./code');

    function isStrictModeReservedWordES6(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'let':
            return true;
        default:
            return false;
        }
    }

    function isKeywordES5(id, strict) {
        // yield should not be treated as keyword under non-strict mode.
        if (!strict && id === 'yield') {
            return false;
        }
        return isKeywordES6(id, strict);
    }

    function isKeywordES6(id, strict) {
        if (strict && isStrictModeReservedWordES6(id)) {
            return true;
        }

        switch (id.length) {
        case 2:
            return (id === 'if') || (id === 'in') || (id === 'do');
        case 3:
            return (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');
        case 4:
            return (id === 'this') || (id === 'else') || (id === 'case') ||
                (id === 'void') || (id === 'with') || (id === 'enum');
        case 5:
            return (id === 'while') || (id === 'break') || (id === 'catch') ||
                (id === 'throw') || (id === 'const') || (id === 'yield') ||
                (id === 'class') || (id === 'super');
        case 6:
            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                (id === 'switch') || (id === 'export') || (id === 'import');
        case 7:
            return (id === 'default') || (id === 'finally') || (id === 'extends');
        case 8:
            return (id === 'function') || (id === 'continue') || (id === 'debugger');
        case 10:
            return (id === 'instanceof');
        default:
            return false;
        }
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    function isIdentifierName(id) {
        var i, iz, ch;

        if (id.length === 0) {
            return false;
        }

        ch = id.charCodeAt(0);
        if (!code.isIdentifierStart(ch) || ch === 92) {  // \ (backslash)
            return false;
        }

        for (i = 1, iz = id.length; i < iz; ++i) {
            ch = id.charCodeAt(i);
            if (!code.isIdentifierPart(ch) || ch === 92) {  // \ (backslash)
                return false;
            }
        }
        return true;
    }

    module.exports = {
        isKeywordES5: isKeywordES5,
        isKeywordES6: isKeywordES6,
        isRestrictedWord: isRestrictedWord,
        isIdentifierName: isIdentifierName
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{"./code":25}],27:[function(require,module,exports){
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


(function () {
    'use strict';

    exports.code = require('./code');
    exports.keyword = require('./keyword');
}());
/* vim: set sw=4 ts=4 et tw=80 : */

},{"./code":25,"./keyword":26}],28:[function(require,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],29:[function(require,module,exports){
require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
exports.readIEEE754 = function(buffer, offset, isBE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isBE ? 0 : (nBytes - 1),
      d = isBE ? 1 : -1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.writeIEEE754 = function(buffer, value, offset, isBE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isBE ? (nBytes - 1) : 0,
      d = isBE ? -1 : 1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],"q9TxCC":[function(require,module,exports){
var assert;
exports.Buffer = Buffer;
exports.SlowBuffer = Buffer;
Buffer.poolSize = 8192;
exports.INSPECT_MAX_BYTES = 50;

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function Buffer(subject, encoding, offset) {
  if(!assert) assert= require('assert');
  if (!(this instanceof Buffer)) {
    return new Buffer(subject, encoding, offset);
  }
  this.parent = this;
  this.offset = 0;

  // Work-around: node's base64 implementation
  // allows for non-padded strings while base64-js
  // does not..
  if (encoding == "base64" && typeof subject == "string") {
    subject = stringtrim(subject);
    while (subject.length % 4 != 0) {
      subject = subject + "="; 
    }
  }

  var type;

  // Are we slicing?
  if (typeof offset === 'number') {
    this.length = coerce(encoding);
    // slicing works, with limitations (no parent tracking/update)
    // check https://github.com/toots/buffer-browserify/issues/19
    for (var i = 0; i < this.length; i++) {
        this[i] = subject.get(i+offset);
    }
  } else {
    // Find the length
    switch (type = typeof subject) {
      case 'number':
        this.length = coerce(subject);
        break;

      case 'string':
        this.length = Buffer.byteLength(subject, encoding);
        break;

      case 'object': // Assume object is an array
        this.length = coerce(subject.length);
        break;

      default:
        throw new Error('First argument needs to be a number, ' +
                        'array or string.');
    }

    // Treat array-ish objects as a byte array.
    if (isArrayIsh(subject)) {
      for (var i = 0; i < this.length; i++) {
        if (subject instanceof Buffer) {
          this[i] = subject.readUInt8(i);
        }
        else {
          this[i] = subject[i];
        }
      }
    } else if (type == 'string') {
      // We are a string
      this.length = this.write(subject, 0, encoding);
    } else if (type === 'number') {
      for (var i = 0; i < this.length; i++) {
        this[i] = 0;
      }
    }
  }
}

Buffer.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this[i];
};

Buffer.prototype.set = function set(i, v) {
  if (i < 0 || i >= this.length) throw new Error('oob');
  return this[i] = v;
};

Buffer.byteLength = function (str, encoding) {
  switch (encoding || "utf8") {
    case 'hex':
      return str.length / 2;

    case 'utf8':
    case 'utf-8':
      return utf8ToBytes(str).length;

    case 'ascii':
    case 'binary':
      return str.length;

    case 'base64':
      return base64ToBytes(str).length;

    default:
      throw new Error('Unknown encoding');
  }
};

Buffer.prototype.utf8Write = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten =  blitBuffer(utf8ToBytes(string), this, offset, length);
};

Buffer.prototype.asciiWrite = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten =  blitBuffer(asciiToBytes(string), this, offset, length);
};

Buffer.prototype.binaryWrite = Buffer.prototype.asciiWrite;

Buffer.prototype.base64Write = function (string, offset, length) {
  var bytes, pos;
  return Buffer._charsWritten = blitBuffer(base64ToBytes(string), this, offset, length);
};

Buffer.prototype.base64Slice = function (start, end) {
  var bytes = Array.prototype.slice.apply(this, arguments)
  return require("base64-js").fromByteArray(bytes);
};

Buffer.prototype.utf8Slice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var res = "";
  var tmp = "";
  var i = 0;
  while (i < bytes.length) {
    if (bytes[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(bytes[i]);
      tmp = "";
    } else
      tmp += "%" + bytes[i].toString(16);

    i++;
  }

  return res + decodeUtf8Char(tmp);
}

Buffer.prototype.asciiSlice = function () {
  var bytes = Array.prototype.slice.apply(this, arguments);
  var ret = "";
  for (var i = 0; i < bytes.length; i++)
    ret += String.fromCharCode(bytes[i]);
  return ret;
}

Buffer.prototype.binarySlice = Buffer.prototype.asciiSlice;

Buffer.prototype.inspect = function() {
  var out = [],
      len = this.length;
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i]);
    if (i == exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...';
      break;
    }
  }
  return '<Buffer ' + out.join(' ') + '>';
};


Buffer.prototype.hexSlice = function(start, end) {
  var len = this.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; i++) {
    out += toHex(this[i]);
  }
  return out;
};


Buffer.prototype.toString = function(encoding, start, end) {
  encoding = String(encoding || 'utf8').toLowerCase();
  start = +start || 0;
  if (typeof end == 'undefined') end = this.length;

  // Fastpath empty strings
  if (+end == start) {
    return '';
  }

  switch (encoding) {
    case 'hex':
      return this.hexSlice(start, end);

    case 'utf8':
    case 'utf-8':
      return this.utf8Slice(start, end);

    case 'ascii':
      return this.asciiSlice(start, end);

    case 'binary':
      return this.binarySlice(start, end);

    case 'base64':
      return this.base64Slice(start, end);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Slice(start, end);

    default:
      throw new Error('Unknown encoding');
  }
};


Buffer.prototype.hexWrite = function(string, offset, length) {
  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2) {
    throw new Error('Invalid hex string');
  }
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(byte)) throw new Error('Invalid hex string');
    this[offset + i] = byte;
  }
  Buffer._charsWritten = i * 2;
  return i;
};


Buffer.prototype.write = function(string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length;
      length = undefined;
    }
  } else {  // legacy
    var swap = encoding;
    encoding = offset;
    offset = length;
    length = swap;
  }

  offset = +offset || 0;
  var remaining = this.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = +length;
    if (length > remaining) {
      length = remaining;
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase();

  switch (encoding) {
    case 'hex':
      return this.hexWrite(string, offset, length);

    case 'utf8':
    case 'utf-8':
      return this.utf8Write(string, offset, length);

    case 'ascii':
      return this.asciiWrite(string, offset, length);

    case 'binary':
      return this.binaryWrite(string, offset, length);

    case 'base64':
      return this.base64Write(string, offset, length);

    case 'ucs2':
    case 'ucs-2':
      return this.ucs2Write(string, offset, length);

    default:
      throw new Error('Unknown encoding');
  }
};

// slice(start, end)
function clamp(index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue;
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len;
  if (index >= 0) return index;
  index += len;
  if (index >= 0) return index;
  return 0;
}

Buffer.prototype.slice = function(start, end) {
  var len = this.length;
  start = clamp(start, len, 0);
  end = clamp(end, len, len);
  return new Buffer(this, end - start, +start);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function(target, target_start, start, end) {
  var source = this;
  start || (start = 0);
  if (end === undefined || isNaN(end)) {
    end = this.length;
  }
  target_start || (target_start = 0);

  if (end < start) throw new Error('sourceEnd < sourceStart');

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length == 0 || source.length == 0) return 0;

  if (target_start < 0 || target_start >= target.length) {
    throw new Error('targetStart out of bounds');
  }

  if (start < 0 || start >= source.length) {
    throw new Error('sourceStart out of bounds');
  }

  if (end < 0 || end > source.length) {
    throw new Error('sourceEnd out of bounds');
  }

  // Are we oob?
  if (end > this.length) {
    end = this.length;
  }

  if (target.length - target_start < end - start) {
    end = target.length - target_start + start;
  }

  var temp = [];
  for (var i=start; i<end; i++) {
    assert.ok(typeof this[i] !== 'undefined', "copying undefined buffer bytes!");
    temp.push(this[i]);
  }

  for (var i=target_start; i<target_start+temp.length; i++) {
    target[i] = temp[i-target_start];
  }
};

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill(value, start, end) {
  value || (value = 0);
  start || (start = 0);
  end || (end = this.length);

  if (typeof value === 'string') {
    value = value.charCodeAt(0);
  }
  if (!(typeof value === 'number') || isNaN(value)) {
    throw new Error('value is not a number');
  }

  if (end < start) throw new Error('end < start');

  // Fill 0 bytes; we're done
  if (end === start) return 0;
  if (this.length == 0) return 0;

  if (start < 0 || start >= this.length) {
    throw new Error('start out of bounds');
  }

  if (end < 0 || end > this.length) {
    throw new Error('end out of bounds');
  }

  for (var i = start; i < end; i++) {
    this[i] = value;
  }
}

// Static methods
Buffer.isBuffer = function isBuffer(b) {
  return b instanceof Buffer || b instanceof Buffer;
};

Buffer.concat = function (list, totalLength) {
  if (!isArray(list)) {
    throw new Error("Usage: Buffer.concat(list, [totalLength])\n \
      list should be an Array.");
  }

  if (list.length === 0) {
    return new Buffer(0);
  } else if (list.length === 1) {
    return list[0];
  }

  if (typeof totalLength !== 'number') {
    totalLength = 0;
    for (var i = 0; i < list.length; i++) {
      var buf = list[i];
      totalLength += buf.length;
    }
  }

  var buffer = new Buffer(totalLength);
  var pos = 0;
  for (var i = 0; i < list.length; i++) {
    var buf = list[i];
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};

Buffer.isEncoding = function(encoding) {
  switch ((encoding + '').toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
    case 'raw':
      return true;

    default:
      return false;
  }
};

// helpers

function coerce(length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length);
  return length < 0 ? 0 : length;
}

function isArray(subject) {
  return (Array.isArray ||
    function(subject){
      return {}.toString.apply(subject) == '[object Array]'
    })
    (subject)
}

function isArrayIsh(subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
         subject && typeof subject === 'object' &&
         typeof subject.length === 'number';
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; i++)
    if (str.charCodeAt(i) <= 0x7F)
      byteArray.push(str.charCodeAt(i));
    else {
      var h = encodeURIComponent(str.charAt(i)).substr(1).split('%');
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16));
    }

  return byteArray;
}

function asciiToBytes(str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++ )
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push( str.charCodeAt(i) & 0xFF );

  return byteArray;
}

function base64ToBytes(str) {
  return require("base64-js").toByteArray(str);
}

function blitBuffer(src, dst, offset, length) {
  var pos, i = 0;
  while (i < length) {
    if ((i+offset >= dst.length) || (i >= src.length))
      break;

    dst[i + offset] = src[i];
    i++;
  }
  return i;
}

function decodeUtf8Char(str) {
  try {
    return decodeURIComponent(str);
  } catch (err) {
    return String.fromCharCode(0xFFFD); // UTF 8 invalid char
  }
}

// read/write bit-twiddling

Buffer.prototype.readUInt8 = function(offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  return buffer[offset];
};

function readUInt16(buffer, offset, isBigEndian, noAssert) {
  var val = 0;


  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    val = buffer[offset] << 8;
    if (offset + 1 < buffer.length) {
      val |= buffer[offset + 1];
    }
  } else {
    val = buffer[offset];
    if (offset + 1 < buffer.length) {
      val |= buffer[offset + 1] << 8;
    }
  }

  return val;
}

Buffer.prototype.readUInt16LE = function(offset, noAssert) {
  return readUInt16(this, offset, false, noAssert);
};

Buffer.prototype.readUInt16BE = function(offset, noAssert) {
  return readUInt16(this, offset, true, noAssert);
};

function readUInt32(buffer, offset, isBigEndian, noAssert) {
  var val = 0;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return 0;

  if (isBigEndian) {
    if (offset + 1 < buffer.length)
      val = buffer[offset + 1] << 16;
    if (offset + 2 < buffer.length)
      val |= buffer[offset + 2] << 8;
    if (offset + 3 < buffer.length)
      val |= buffer[offset + 3];
    val = val + (buffer[offset] << 24 >>> 0);
  } else {
    if (offset + 2 < buffer.length)
      val = buffer[offset + 2] << 16;
    if (offset + 1 < buffer.length)
      val |= buffer[offset + 1] << 8;
    val |= buffer[offset];
    if (offset + 3 < buffer.length)
      val = val + (buffer[offset + 3] << 24 >>> 0);
  }

  return val;
}

Buffer.prototype.readUInt32LE = function(offset, noAssert) {
  return readUInt32(this, offset, false, noAssert);
};

Buffer.prototype.readUInt32BE = function(offset, noAssert) {
  return readUInt32(this, offset, true, noAssert);
};


/*
 * Signed integer types, yay team! A reminder on how two's complement actually
 * works. The first bit is the signed bit, i.e. tells us whether or not the
 * number should be positive or negative. If the two's complement value is
 * positive, then we're done, as it's equivalent to the unsigned representation.
 *
 * Now if the number is positive, you're pretty much done, you can just leverage
 * the unsigned translations and return those. Unfortunately, negative numbers
 * aren't quite that straightforward.
 *
 * At first glance, one might be inclined to use the traditional formula to
 * translate binary numbers between the positive and negative values in two's
 * complement. (Though it doesn't quite work for the most negative value)
 * Mainly:
 *  - invert all the bits
 *  - add one to the result
 *
 * Of course, this doesn't quite work in Javascript. Take for example the value
 * of -128. This could be represented in 16 bits (big-endian) as 0xff80. But of
 * course, Javascript will do the following:
 *
 * > ~0xff80
 * -65409
 *
 * Whoh there, Javascript, that's not quite right. But wait, according to
 * Javascript that's perfectly correct. When Javascript ends up seeing the
 * constant 0xff80, it has no notion that it is actually a signed number. It
 * assumes that we've input the unsigned value 0xff80. Thus, when it does the
 * binary negation, it casts it into a signed value, (positive 0xff80). Then
 * when you perform binary negation on that, it turns it into a negative number.
 *
 * Instead, we're going to have to use the following general formula, that works
 * in a rather Javascript friendly way. I'm glad we don't support this kind of
 * weird numbering scheme in the kernel.
 *
 * (BIT-MAX - (unsigned)val + 1) * -1
 *
 * The astute observer, may think that this doesn't make sense for 8-bit numbers
 * (really it isn't necessary for them). However, when you get 16-bit numbers,
 * you do. Let's go back to our prior example and see how this will look:
 *
 * (0xffff - 0xff80 + 1) * -1
 * (0x007f + 1) * -1
 * (0x0080) * -1
 */
Buffer.prototype.readInt8 = function(offset, noAssert) {
  var buffer = this;
  var neg;

  if (!noAssert) {
    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to read beyond buffer length');
  }

  if (offset >= buffer.length) return;

  neg = buffer[offset] & 0x80;
  if (!neg) {
    return (buffer[offset]);
  }

  return ((0xff - buffer[offset] + 1) * -1);
};

function readInt16(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt16(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x8000;
  if (!neg) {
    return val;
  }

  return (0xffff - val + 1) * -1;
}

Buffer.prototype.readInt16LE = function(offset, noAssert) {
  return readInt16(this, offset, false, noAssert);
};

Buffer.prototype.readInt16BE = function(offset, noAssert) {
  return readInt16(this, offset, true, noAssert);
};

function readInt32(buffer, offset, isBigEndian, noAssert) {
  var neg, val;

  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  val = readUInt32(buffer, offset, isBigEndian, noAssert);
  neg = val & 0x80000000;
  if (!neg) {
    return (val);
  }

  return (0xffffffff - val + 1) * -1;
}

Buffer.prototype.readInt32LE = function(offset, noAssert) {
  return readInt32(this, offset, false, noAssert);
};

Buffer.prototype.readInt32BE = function(offset, noAssert) {
  return readInt32(this, offset, true, noAssert);
};

function readFloat(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 3 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.readFloatLE = function(offset, noAssert) {
  return readFloat(this, offset, false, noAssert);
};

Buffer.prototype.readFloatBE = function(offset, noAssert) {
  return readFloat(this, offset, true, noAssert);
};

function readDouble(buffer, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset + 7 < buffer.length,
        'Trying to read beyond buffer length');
  }

  return require('./buffer_ieee754').readIEEE754(buffer, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.readDoubleLE = function(offset, noAssert) {
  return readDouble(this, offset, false, noAssert);
};

Buffer.prototype.readDoubleBE = function(offset, noAssert) {
  return readDouble(this, offset, true, noAssert);
};


/*
 * We have to make sure that the value is a valid integer. This means that it is
 * non-negative. It has no fractional component and that it does not exceed the
 * maximum allowed value.
 *
 *      value           The number to check for validity
 *
 *      max             The maximum value
 */
function verifuint(value, max) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value >= 0,
      'specified a negative value for writing an unsigned value');

  assert.ok(value <= max, 'value is larger than maximum value for type');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xff);
  }

  if (offset < buffer.length) {
    buffer[offset] = value;
  }
};

function writeUInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 2); i++) {
    buffer[offset + i] =
        (value & (0xff << (8 * (isBigEndian ? 1 - i : i)))) >>>
            (isBigEndian ? 1 - i : i) * 8;
  }

}

Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
  writeUInt16(this, value, offset, true, noAssert);
};

function writeUInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'trying to write beyond buffer length');

    verifuint(value, 0xffffffff);
  }

  for (var i = 0; i < Math.min(buffer.length - offset, 4); i++) {
    buffer[offset + i] =
        (value >>> (isBigEndian ? 3 - i : i) * 8) & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
  writeUInt32(this, value, offset, true, noAssert);
};


/*
 * We now move onto our friends in the signed number category. Unlike unsigned
 * numbers, we're going to have to worry a bit more about how we put values into
 * arrays. Since we are only worrying about signed 32-bit values, we're in
 * slightly better shape. Unfortunately, we really can't do our favorite binary
 * & in this system. It really seems to do the wrong thing. For example:
 *
 * > -32 & 0xff
 * 224
 *
 * What's happening above is really: 0xe0 & 0xff = 0xe0. However, the results of
 * this aren't treated as a signed number. Ultimately a bad thing.
 *
 * What we're going to want to do is basically create the unsigned equivalent of
 * our representation and pass that off to the wuint* functions. To do that
 * we're going to do the following:
 *
 *  - if the value is positive
 *      we can pass it directly off to the equivalent wuint
 *  - if the value is negative
 *      we do the following computation:
 *         mb + val + 1, where
 *         mb   is the maximum unsigned value in that byte size
 *         val  is the Javascript negative integer
 *
 *
 * As a concrete value, take -128. In signed 16 bits this would be 0xff80. If
 * you do out the computations:
 *
 * 0xffff - 128 + 1
 * 0xffff - 127
 * 0xff80
 *
 * You can then encode this value as the signed version. This is really rather
 * hacky, but it should work and get the job done which is our goal here.
 */

/*
 * A series of checks to make sure we actually have a signed 32-bit number
 */
function verifsint(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');

  assert.ok(Math.floor(value) === value, 'value has a fractional component');
}

function verifIEEE754(value, max, min) {
  assert.ok(typeof (value) == 'number',
      'cannot write a non-number as a number');

  assert.ok(value <= max, 'value larger than maximum allowed value');

  assert.ok(value >= min, 'value smaller than minimum allowed value');
}

Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
  var buffer = this;

  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7f, -0x80);
  }

  if (value >= 0) {
    buffer.writeUInt8(value, offset, noAssert);
  } else {
    buffer.writeUInt8(0xff + value + 1, offset, noAssert);
  }
};

function writeInt16(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 1 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fff, -0x8000);
  }

  if (value >= 0) {
    writeUInt16(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt16(buffer, 0xffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
  writeInt16(this, value, offset, true, noAssert);
};

function writeInt32(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifsint(value, 0x7fffffff, -0x80000000);
  }

  if (value >= 0) {
    writeUInt32(buffer, value, offset, isBigEndian, noAssert);
  } else {
    writeUInt32(buffer, 0xffffffff + value + 1, offset, isBigEndian, noAssert);
  }
}

Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, false, noAssert);
};

Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
  writeInt32(this, value, offset, true, noAssert);
};

function writeFloat(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 3 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      23, 4);
}

Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, false, noAssert);
};

Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
  writeFloat(this, value, offset, true, noAssert);
};

function writeDouble(buffer, value, offset, isBigEndian, noAssert) {
  if (!noAssert) {
    assert.ok(value !== undefined && value !== null,
        'missing value');

    assert.ok(typeof (isBigEndian) === 'boolean',
        'missing or invalid endian');

    assert.ok(offset !== undefined && offset !== null,
        'missing offset');

    assert.ok(offset + 7 < buffer.length,
        'Trying to write beyond buffer length');

    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  require('./buffer_ieee754').writeIEEE754(buffer, value, offset, isBigEndian,
      52, 8);
}

Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, false, noAssert);
};

Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
  writeDouble(this, value, offset, true, noAssert);
};

},{"./buffer_ieee754":1,"assert":6,"base64-js":4}],"buffer-browserify":[function(require,module,exports){
module.exports=require('q9TxCC');
},{}],4:[function(require,module,exports){
(function (exports) {
	'use strict';

	var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	function b64ToByteArray(b64) {
		var i, j, l, tmp, placeHolders, arr;
	
		if (b64.length % 4 > 0) {
			throw 'Invalid string. Length must be a multiple of 4';
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		placeHolders = b64.indexOf('=');
		placeHolders = placeHolders > 0 ? b64.length - placeHolders : 0;

		// base64 is 4/3 + up to two characters of the original data
		arr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length;

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);
			arr.push((tmp & 0xFF0000) >> 16);
			arr.push((tmp & 0xFF00) >> 8);
			arr.push(tmp & 0xFF);
		}

		if (placeHolders === 2) {
			tmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);
			arr.push(tmp & 0xFF);
		} else if (placeHolders === 1) {
			tmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);
			arr.push((tmp >> 8) & 0xFF);
			arr.push(tmp & 0xFF);
		}

		return arr;
	}

	function uint8ToBase64(uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length;

		function tripletToBase64 (num) {
			return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
		};

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
			output += tripletToBase64(temp);
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1];
				output += lookup[temp >> 2];
				output += lookup[(temp << 4) & 0x3F];
				output += '==';
				break;
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);
				output += lookup[temp >> 10];
				output += lookup[(temp >> 4) & 0x3F];
				output += lookup[(temp << 2) & 0x3F];
				output += '=';
				break;
		}

		return output;
	}

	module.exports.toByteArray = b64ToByteArray;
	module.exports.fromByteArray = uint8ToBase64;
}());

},{}],5:[function(require,module,exports){


//
// The shims in this file are not fully implemented shims for the ES5
// features, but do work for the particular usecases there is in
// the other modules.
//

var toString = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

// Array.isArray is supported in IE9
function isArray(xs) {
  return toString.call(xs) === '[object Array]';
}
exports.isArray = typeof Array.isArray === 'function' ? Array.isArray : isArray;

// Array.prototype.indexOf is supported in IE9
exports.indexOf = function indexOf(xs, x) {
  if (xs.indexOf) return xs.indexOf(x);
  for (var i = 0; i < xs.length; i++) {
    if (x === xs[i]) return i;
  }
  return -1;
};

// Array.prototype.filter is supported in IE9
exports.filter = function filter(xs, fn) {
  if (xs.filter) return xs.filter(fn);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    if (fn(xs[i], i, xs)) res.push(xs[i]);
  }
  return res;
};

// Array.prototype.forEach is supported in IE9
exports.forEach = function forEach(xs, fn, self) {
  if (xs.forEach) return xs.forEach(fn, self);
  for (var i = 0; i < xs.length; i++) {
    fn.call(self, xs[i], i, xs);
  }
};

// Array.prototype.map is supported in IE9
exports.map = function map(xs, fn) {
  if (xs.map) return xs.map(fn);
  var out = new Array(xs.length);
  for (var i = 0; i < xs.length; i++) {
    out[i] = fn(xs[i], i, xs);
  }
  return out;
};

// Array.prototype.reduce is supported in IE9
exports.reduce = function reduce(array, callback, opt_initialValue) {
  if (array.reduce) return array.reduce(callback, opt_initialValue);
  var value, isValueSet = false;

  if (2 < arguments.length) {
    value = opt_initialValue;
    isValueSet = true;
  }
  for (var i = 0, l = array.length; l > i; ++i) {
    if (array.hasOwnProperty(i)) {
      if (isValueSet) {
        value = callback(value, array[i], i, array);
      }
      else {
        value = array[i];
        isValueSet = true;
      }
    }
  }

  return value;
};

// String.prototype.substr - negative index don't work in IE8
if ('ab'.substr(-1) !== 'b') {
  exports.substr = function (str, start, length) {
    // did we get a negative start, calculate how much it is from the beginning of the string
    if (start < 0) start = str.length + start;

    // call the original function
    return str.substr(start, length);
  };
} else {
  exports.substr = function (str, start, length) {
    return str.substr(start, length);
  };
}

// String.prototype.trim is supported in IE9
exports.trim = function (str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
};

// Function.prototype.bind is supported in IE9
exports.bind = function () {
  var args = Array.prototype.slice.call(arguments);
  var fn = args.shift();
  if (fn.bind) return fn.bind.apply(fn, args);
  var self = args.shift();
  return function () {
    fn.apply(self, args.concat([Array.prototype.slice.call(arguments)]));
  };
};

// Object.create is supported in IE9
function create(prototype, properties) {
  var object;
  if (prototype === null) {
    object = { '__proto__' : null };
  }
  else {
    if (typeof prototype !== 'object') {
      throw new TypeError(
        'typeof prototype[' + (typeof prototype) + '] != \'object\''
      );
    }
    var Type = function () {};
    Type.prototype = prototype;
    object = new Type();
    object.__proto__ = prototype;
  }
  if (typeof properties !== 'undefined' && Object.defineProperties) {
    Object.defineProperties(object, properties);
  }
  return object;
}
exports.create = typeof Object.create === 'function' ? Object.create : create;

// Object.keys and Object.getOwnPropertyNames is supported in IE9 however
// they do show a description and number property on Error objects
function notObject(object) {
  return ((typeof object != "object" && typeof object != "function") || object === null);
}

function keysShim(object) {
  if (notObject(object)) {
    throw new TypeError("Object.keys called on a non-object");
  }

  var result = [];
  for (var name in object) {
    if (hasOwnProperty.call(object, name)) {
      result.push(name);
    }
  }
  return result;
}

// getOwnPropertyNames is almost the same as Object.keys one key feature
//  is that it returns hidden properties, since that can't be implemented,
//  this feature gets reduced so it just shows the length property on arrays
function propertyShim(object) {
  if (notObject(object)) {
    throw new TypeError("Object.getOwnPropertyNames called on a non-object");
  }

  var result = keysShim(object);
  if (exports.isArray(object) && exports.indexOf(object, 'length') === -1) {
    result.push('length');
  }
  return result;
}

var keys = typeof Object.keys === 'function' ? Object.keys : keysShim;
var getOwnPropertyNames = typeof Object.getOwnPropertyNames === 'function' ?
  Object.getOwnPropertyNames : propertyShim;

if (new Error().hasOwnProperty('description')) {
  var ERROR_PROPERTY_FILTER = function (obj, array) {
    if (toString.call(obj) === '[object Error]') {
      array = exports.filter(array, function (name) {
        return name !== 'description' && name !== 'number' && name !== 'message';
      });
    }
    return array;
  };

  exports.keys = function (object) {
    return ERROR_PROPERTY_FILTER(object, keys(object));
  };
  exports.getOwnPropertyNames = function (object) {
    return ERROR_PROPERTY_FILTER(object, getOwnPropertyNames(object));
  };
} else {
  exports.keys = keys;
  exports.getOwnPropertyNames = getOwnPropertyNames;
}

// Object.getOwnPropertyDescriptor - supported in IE8 but only on dom elements
function valueObject(value, key) {
  return { value: value[key] };
}

if (typeof Object.getOwnPropertyDescriptor === 'function') {
  try {
    Object.getOwnPropertyDescriptor({'a': 1}, 'a');
    exports.getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  } catch (e) {
    // IE8 dom element issue - use a try catch and default to valueObject
    exports.getOwnPropertyDescriptor = function (value, key) {
      try {
        return Object.getOwnPropertyDescriptor(value, key);
      } catch (e) {
        return valueObject(value, key);
      }
    };
  }
} else {
  exports.getOwnPropertyDescriptor = valueObject;
}

},{}],6:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// UTILITY
var util = require('util');
var shims = require('_shims');
var pSlice = Array.prototype.slice;

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  this.message = options.message || getMessage(this);
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (util.isUndefined(value)) {
    return '' + value;
  }
  if (util.isNumber(value) && (isNaN(value) || !isFinite(value))) {
    return value.toString();
  }
  if (util.isFunction(value) || util.isRegExp(value)) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (util.isString(s)) {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function getMessage(self) {
  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!util.isObject(actual) && !util.isObject(expected)) {
    return actual == expected;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  try {
    var ka = shims.keys(a),
        kb = shims.keys(b),
        key, i;
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (util.isString(expected)) {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};
},{"_shims":5,"util":7}],7:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var shims = require('_shims');

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  shims.forEach(array, function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = shims.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = shims.getOwnPropertyNames(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }

  shims.forEach(keys, function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = shims.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }

  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (shims.indexOf(ctx.seen, desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = shims.reduce(output, function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return shims.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) && objectToString(e) === '[object Error]';
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

function isBuffer(arg) {
  return arg instanceof Buffer;
}
exports.isBuffer = isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = function(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = shims.create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
};

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = shims.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

},{"_shims":5}]},{},[])
;;module.exports=require("buffer-browserify")

},{}],30:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],31:[function(require,module,exports){
/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = require('./source-map/source-map-generator').SourceMapGenerator;
exports.SourceMapConsumer = require('./source-map/source-map-consumer').SourceMapConsumer;
exports.SourceNode = require('./source-map/source-node').SourceNode;

},{"./source-map/source-map-consumer":37,"./source-map/source-map-generator":38,"./source-map/source-node":39}],32:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');

  /**
   * A data structure which is a combination of an array and a set. Adding a new
   * member is O(1), testing for membership is O(1), and finding the index of an
   * element is O(1). Removing elements from the set is not supported. Only
   * strings are supported for membership.
   */
  function ArraySet() {
    this._array = [];
    this._set = {};
  }

  /**
   * Static method for creating ArraySet instances from an existing array.
   */
  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet();
    for (var i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }
    return set;
  };

  /**
   * Add the given string to this set.
   *
   * @param String aStr
   */
  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var isDuplicate = this.has(aStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      this._set[util.toSetString(aStr)] = idx;
    }
  };

  /**
   * Is the given string a member of this set?
   *
   * @param String aStr
   */
  ArraySet.prototype.has = function ArraySet_has(aStr) {
    return Object.prototype.hasOwnProperty.call(this._set,
                                                util.toSetString(aStr));
  };

  /**
   * What is the index of the given string in the array?
   *
   * @param String aStr
   */
  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (this.has(aStr)) {
      return this._set[util.toSetString(aStr)];
    }
    throw new Error('"' + aStr + '" is not in the set.');
  };

  /**
   * What is the element at the given index?
   *
   * @param Number aIdx
   */
  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error('No element indexed by ' + aIdx);
  };

  /**
   * Returns the array representation of this set (which has the proper indices
   * indicated by indexOf). Note that this is a copy of the internal array used
   * for storing the members so that no one can mess with internal state.
   */
  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };

  exports.ArraySet = ArraySet;

});

},{"./util":40,"amdefine":15}],33:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var base64 = require('./base64');

  // A single base 64 digit can contain 6 bits of data. For the base 64 variable
  // length quantities we use in the source map spec, the first bit is the sign,
  // the next four bits are the actual value, and the 6th bit is the
  // continuation bit. The continuation bit tells us whether there are more
  // digits in this value following this digit.
  //
  //   Continuation
  //   |    Sign
  //   |    |
  //   V    V
  //   101011

  var VLQ_BASE_SHIFT = 5;

  // binary: 100000
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

  // binary: 011111
  var VLQ_BASE_MASK = VLQ_BASE - 1;

  // binary: 100000
  var VLQ_CONTINUATION_BIT = VLQ_BASE;

  /**
   * Converts from a two-complement value to a value where the sign bit is
   * placed in the least significant bit.  For example, as decimals:
   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
   */
  function toVLQSigned(aValue) {
    return aValue < 0
      ? ((-aValue) << 1) + 1
      : (aValue << 1) + 0;
  }

  /**
   * Converts to a two-complement value from a value where the sign bit is
   * placed in the least significant bit.  For example, as decimals:
   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
   */
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative
      ? -shifted
      : shifted;
  }

  /**
   * Returns the base 64 VLQ encoded value.
   */
  exports.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;

    var vlq = toVLQSigned(aValue);

    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        // There are still more digits in this value, so we must make sure the
        // continuation bit is marked.
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base64.encode(digit);
    } while (vlq > 0);

    return encoded;
  };

  /**
   * Decodes the next base 64 VLQ value from the given string and returns the
   * value and the rest of the string via the out parameter.
   */
  exports.decode = function base64VLQ_decode(aStr, aOutParam) {
    var i = 0;
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;

    do {
      if (i >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }
      digit = base64.decode(aStr.charAt(i++));
      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);

    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aStr.slice(i);
  };

});

},{"./base64":34,"amdefine":15}],34:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var charToIntMap = {};
  var intToCharMap = {};

  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    .split('')
    .forEach(function (ch, index) {
      charToIntMap[ch] = index;
      intToCharMap[index] = ch;
    });

  /**
   * Encode an integer in the range of 0 to 63 to a single base 64 digit.
   */
  exports.encode = function base64_encode(aNumber) {
    if (aNumber in intToCharMap) {
      return intToCharMap[aNumber];
    }
    throw new TypeError("Must be between 0 and 63: " + aNumber);
  };

  /**
   * Decode a single base 64 digit to an integer.
   */
  exports.decode = function base64_decode(aChar) {
    if (aChar in charToIntMap) {
      return charToIntMap[aChar];
    }
    throw new TypeError("Not a valid base 64 digit: " + aChar);
  };

});

},{"amdefine":15}],35:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  /**
   * Recursive implementation of binary search.
   *
   * @param aLow Indices here and lower do not contain the needle.
   * @param aHigh Indices here and higher do not contain the needle.
   * @param aNeedle The element being searched for.
   * @param aHaystack The non-empty array being searched.
   * @param aCompare Function which takes two elements and returns -1, 0, or 1.
   */
  function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare) {
    // This function terminates when one of the following is true:
    //
    //   1. We find the exact element we are looking for.
    //
    //   2. We did not find the exact element, but we can return the index of
    //      the next closest element that is less than that element.
    //
    //   3. We did not find the exact element, and there is no next-closest
    //      element which is less than the one we are searching for, so we
    //      return -1.
    var mid = Math.floor((aHigh - aLow) / 2) + aLow;
    var cmp = aCompare(aNeedle, aHaystack[mid], true);
    if (cmp === 0) {
      // Found the element we are looking for.
      return mid;
    }
    else if (cmp > 0) {
      // aHaystack[mid] is greater than our needle.
      if (aHigh - mid > 1) {
        // The element is in the upper half.
        return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare);
      }
      // We did not find an exact match, return the next closest one
      // (termination case 2).
      return mid;
    }
    else {
      // aHaystack[mid] is less than our needle.
      if (mid - aLow > 1) {
        // The element is in the lower half.
        return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare);
      }
      // The exact needle element was not found in this haystack. Determine if
      // we are in termination case (2) or (3) and return the appropriate thing.
      return aLow < 0 ? -1 : aLow;
    }
  }

  /**
   * This is an implementation of binary search which will always try and return
   * the index of next lowest value checked if there is no exact hit. This is
   * because mappings between original and generated line/col pairs are single
   * points, and there is an implicit region between each of them, so a miss
   * just means that you aren't on the very start of a region.
   *
   * @param aNeedle The element you are looking for.
   * @param aHaystack The array that is being searched.
   * @param aCompare A function which takes the needle and an element in the
   *     array and returns -1, 0, or 1 depending on whether the needle is less
   *     than, equal to, or greater than the element, respectively.
   */
  exports.search = function search(aNeedle, aHaystack, aCompare) {
    if (aHaystack.length === 0) {
      return -1;
    }
    return recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare)
  };

});

},{"amdefine":15}],36:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');

  /**
   * Determine whether mappingB is after mappingA with respect to generated
   * position.
   */
  function generatedPositionAfter(mappingA, mappingB) {
    // Optimized for most common case
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA ||
           util.compareByGeneratedPositions(mappingA, mappingB) <= 0;
  }

  /**
   * A data structure to provide a sorted view of accumulated mappings in a
   * performance conscious manner. It trades a neglibable overhead in general
   * case for a large speedup in case of mappings being added in order.
   */
  function MappingList() {
    this._array = [];
    this._sorted = true;
    // Serves as infimum
    this._last = {generatedLine: -1, generatedColumn: 0};
  }

  /**
   * Iterate through internal items. This method takes the same arguments that
   * `Array.prototype.forEach` takes.
   *
   * NOTE: The order of the mappings is NOT guaranteed.
   */
  MappingList.prototype.unsortedForEach =
    function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };

  /**
   * Add the given source mapping.
   *
   * @param Object aMapping
   */
  MappingList.prototype.add = function MappingList_add(aMapping) {
    var mapping;
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;
      this._array.push(aMapping);
    } else {
      this._sorted = false;
      this._array.push(aMapping);
    }
  };

  /**
   * Returns the flat, sorted array of mappings. The mappings are sorted by
   * generated position.
   *
   * WARNING: This method returns internal data without copying, for
   * performance. The return value must NOT be mutated, and should be treated as
   * an immutable borrow. If you want to take ownership, you must make your own
   * copy.
   */
  MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util.compareByGeneratedPositions);
      this._sorted = true;
    }
    return this._array;
  };

  exports.MappingList = MappingList;

});

},{"./util":40,"amdefine":15}],37:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var util = require('./util');
  var binarySearch = require('./binary-search');
  var ArraySet = require('./array-set').ArraySet;
  var base64VLQ = require('./base64-vlq');

  /**
   * A SourceMapConsumer instance represents a parsed source map which we can
   * query for information about the original file positions by giving it a file
   * position in the generated source.
   *
   * The only parameter is the raw source map (either as a JSON string, or
   * already parsed to an object). According to the spec, source maps have the
   * following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - sources: An array of URLs to the original source files.
   *   - names: An array of identifiers which can be referrenced by individual mappings.
   *   - sourceRoot: Optional. The URL root from which all sources are relative.
   *   - sourcesContent: Optional. An array of contents of the original source files.
   *   - mappings: A string of base64 VLQs which contain the actual mappings.
   *   - file: Optional. The generated file this source map is associated with.
   *
   * Here is an example source map, taken from the source map spec[0]:
   *
   *     {
   *       version : 3,
   *       file: "out.js",
   *       sourceRoot : "",
   *       sources: ["foo.js", "bar.js"],
   *       names: ["src", "maps", "are", "fun"],
   *       mappings: "AA,AB;;ABCDE;"
   *     }
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
   */
  function SourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;
    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    var version = util.getArg(sourceMap, 'version');
    var sources = util.getArg(sourceMap, 'sources');
    // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
    // requires the array) to play nice here.
    var names = util.getArg(sourceMap, 'names', []);
    var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
    var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
    var mappings = util.getArg(sourceMap, 'mappings');
    var file = util.getArg(sourceMap, 'file', null);

    // Once again, Sass deviates from the spec and supplies the version as a
    // string rather than a number, so we use loose equality checking here.
    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    // Some source maps produce relative source paths like "./foo.js" instead of
    // "foo.js".  Normalize these first so that future comparisons will succeed.
    // See bugzil.la/1090768.
    sources = sources.map(util.normalize);

    // Pass `true` below to allow duplicate names and sources. While source maps
    // are intended to be compressed and deduplicated, the TypeScript compiler
    // sometimes generates source maps with duplicates in them. See Github issue
    // #72 and bugzil.la/889492.
    this._names = ArraySet.fromArray(names, true);
    this._sources = ArraySet.fromArray(sources, true);

    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this.file = file;
  }

  /**
   * Create a SourceMapConsumer from a SourceMapGenerator.
   *
   * @param SourceMapGenerator aSourceMap
   *        The source map that will be consumed.
   * @returns SourceMapConsumer
   */
  SourceMapConsumer.fromSourceMap =
    function SourceMapConsumer_fromSourceMap(aSourceMap) {
      var smc = Object.create(SourceMapConsumer.prototype);

      smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                              smc.sourceRoot);
      smc.file = aSourceMap._file;

      smc.__generatedMappings = aSourceMap._mappings.toArray().slice();
      smc.__originalMappings = aSourceMap._mappings.toArray().slice()
        .sort(util.compareByOriginalPositions);

      return smc;
    };

  /**
   * The version of the source mapping spec that we are consuming.
   */
  SourceMapConsumer.prototype._version = 3;

  /**
   * The list of original sources.
   */
  Object.defineProperty(SourceMapConsumer.prototype, 'sources', {
    get: function () {
      return this._sources.toArray().map(function (s) {
        return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
      }, this);
    }
  });

  // `__generatedMappings` and `__originalMappings` are arrays that hold the
  // parsed mapping coordinates from the source map's "mappings" attribute. They
  // are lazily instantiated, accessed via the `_generatedMappings` and
  // `_originalMappings` getters respectively, and we only parse the mappings
  // and create these arrays once queried for a source location. We jump through
  // these hoops because there can be many thousands of mappings, and parsing
  // them is expensive, so we only want to do it if we must.
  //
  // Each object in the arrays is of the form:
  //
  //     {
  //       generatedLine: The line number in the generated code,
  //       generatedColumn: The column number in the generated code,
  //       source: The path to the original source file that generated this
  //               chunk of code,
  //       originalLine: The line number in the original source that
  //                     corresponds to this chunk of generated code,
  //       originalColumn: The column number in the original source that
  //                       corresponds to this chunk of generated code,
  //       name: The name of the original symbol which generated this chunk of
  //             code.
  //     }
  //
  // All properties except for `generatedLine` and `generatedColumn` can be
  // `null`.
  //
  // `_generatedMappings` is ordered by the generated positions.
  //
  // `_originalMappings` is ordered by the original positions.

  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
    get: function () {
      if (!this.__generatedMappings) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__generatedMappings;
    }
  });

  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
    get: function () {
      if (!this.__originalMappings) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__originalMappings;
    }
  });

  SourceMapConsumer.prototype._nextCharIsMappingSeparator =
    function SourceMapConsumer_nextCharIsMappingSeparator(aStr) {
      var c = aStr.charAt(0);
      return c === ";" || c === ",";
    };

  /**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  SourceMapConsumer.prototype._parseMappings =
    function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var str = aStr;
      var temp = {};
      var mapping;

      while (str.length > 0) {
        if (str.charAt(0) === ';') {
          generatedLine++;
          str = str.slice(1);
          previousGeneratedColumn = 0;
        }
        else if (str.charAt(0) === ',') {
          str = str.slice(1);
        }
        else {
          mapping = {};
          mapping.generatedLine = generatedLine;

          // Generated column.
          base64VLQ.decode(str, temp);
          mapping.generatedColumn = previousGeneratedColumn + temp.value;
          previousGeneratedColumn = mapping.generatedColumn;
          str = temp.rest;

          if (str.length > 0 && !this._nextCharIsMappingSeparator(str)) {
            // Original source.
            base64VLQ.decode(str, temp);
            mapping.source = this._sources.at(previousSource + temp.value);
            previousSource += temp.value;
            str = temp.rest;
            if (str.length === 0 || this._nextCharIsMappingSeparator(str)) {
              throw new Error('Found a source, but no line and column');
            }

            // Original line.
            base64VLQ.decode(str, temp);
            mapping.originalLine = previousOriginalLine + temp.value;
            previousOriginalLine = mapping.originalLine;
            // Lines are stored 0-based
            mapping.originalLine += 1;
            str = temp.rest;
            if (str.length === 0 || this._nextCharIsMappingSeparator(str)) {
              throw new Error('Found a source and line, but no column');
            }

            // Original column.
            base64VLQ.decode(str, temp);
            mapping.originalColumn = previousOriginalColumn + temp.value;
            previousOriginalColumn = mapping.originalColumn;
            str = temp.rest;

            if (str.length > 0 && !this._nextCharIsMappingSeparator(str)) {
              // Original name.
              base64VLQ.decode(str, temp);
              mapping.name = this._names.at(previousName + temp.value);
              previousName += temp.value;
              str = temp.rest;
            }
          }

          this.__generatedMappings.push(mapping);
          if (typeof mapping.originalLine === 'number') {
            this.__originalMappings.push(mapping);
          }
        }
      }

      this.__generatedMappings.sort(util.compareByGeneratedPositions);
      this.__originalMappings.sort(util.compareByOriginalPositions);
    };

  /**
   * Find the mapping that best matches the hypothetical "needle" mapping that
   * we are searching for in the given "haystack" of mappings.
   */
  SourceMapConsumer.prototype._findMapping =
    function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                           aColumnName, aComparator) {
      // To return the position we are searching for, we must first find the
      // mapping for the given position and then return the opposite position it
      // points to. Because the mappings are sorted, we can use binary search to
      // find the best mapping.

      if (aNeedle[aLineName] <= 0) {
        throw new TypeError('Line must be greater than or equal to 1, got '
                            + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError('Column must be greater than or equal to 0, got '
                            + aNeedle[aColumnName]);
      }

      return binarySearch.search(aNeedle, aMappings, aComparator);
    };

  /**
   * Compute the last column for each generated mapping. The last column is
   * inclusive.
   */
  SourceMapConsumer.prototype.computeColumnSpans =
    function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];

        // Mappings do not contain a field for the last generated columnt. We
        // can come up with an optimistic estimate, however, by assuming that
        // mappings are contiguous (i.e. given two consecutive mappings, the
        // first mapping ends where the second one starts).
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];

          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }

        // The last mapping for each line spans the entire line.
        mapping.lastGeneratedColumn = Infinity;
      }
    };

  /**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.
   *   - column: The column number in the generated source.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.
   *   - column: The column number in the original source, or null.
   *   - name: The original identifier, or null.
   */
  SourceMapConsumer.prototype.originalPositionFor =
    function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, 'line'),
        generatedColumn: util.getArg(aArgs, 'column')
      };

      var index = this._findMapping(needle,
                                    this._generatedMappings,
                                    "generatedLine",
                                    "generatedColumn",
                                    util.compareByGeneratedPositions);

      if (index >= 0) {
        var mapping = this._generatedMappings[index];

        if (mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, 'source', null);
          if (source != null && this.sourceRoot != null) {
            source = util.join(this.sourceRoot, source);
          }
          return {
            source: source,
            line: util.getArg(mapping, 'originalLine', null),
            column: util.getArg(mapping, 'originalColumn', null),
            name: util.getArg(mapping, 'name', null)
          };
        }
      }

      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };

  /**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * availible.
   */
  SourceMapConsumer.prototype.sourceContentFor =
    function SourceMapConsumer_sourceContentFor(aSource) {
      if (!this.sourcesContent) {
        return null;
      }

      if (this.sourceRoot != null) {
        aSource = util.relative(this.sourceRoot, aSource);
      }

      if (this._sources.has(aSource)) {
        return this.sourcesContent[this._sources.indexOf(aSource)];
      }

      var url;
      if (this.sourceRoot != null
          && (url = util.urlParse(this.sourceRoot))) {
        // XXX: file:// URIs and absolute paths lead to unexpected behavior for
        // many users. We can help them out when they expect file:// URIs to
        // behave like it would if they were running a local HTTP server. See
        // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
        var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
        if (url.scheme == "file"
            && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
        }

        if ((!url.path || url.path == "/")
            && this._sources.has("/" + aSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + aSource)];
        }
      }

      throw new Error('"' + aSource + '" is not in the SourceMap.');
    };

  /**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *   - column: The column number in the original source.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  SourceMapConsumer.prototype.generatedPositionFor =
    function SourceMapConsumer_generatedPositionFor(aArgs) {
      var needle = {
        source: util.getArg(aArgs, 'source'),
        originalLine: util.getArg(aArgs, 'line'),
        originalColumn: util.getArg(aArgs, 'column')
      };

      if (this.sourceRoot != null) {
        needle.source = util.relative(this.sourceRoot, needle.source);
      }

      var index = this._findMapping(needle,
                                    this._originalMappings,
                                    "originalLine",
                                    "originalColumn",
                                    util.compareByOriginalPositions);

      if (index >= 0) {
        var mapping = this._originalMappings[index];

        return {
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }

      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };

  /**
   * Returns all generated line and column information for the original source
   * and line provided. The only argument is an object with the following
   * properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.
   *
   * and an array of objects is returned, each with the following properties:
   *
   *   - line: The line number in the generated source, or null.
   *   - column: The column number in the generated source, or null.
   */
  SourceMapConsumer.prototype.allGeneratedPositionsFor =
    function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      // When there is no exact match, SourceMapConsumer.prototype._findMapping
      // returns the index of the closest mapping less than the needle. By
      // setting needle.originalColumn to Infinity, we thus find the last
      // mapping for the given line, provided such a mapping exists.
      var needle = {
        source: util.getArg(aArgs, 'source'),
        originalLine: util.getArg(aArgs, 'line'),
        originalColumn: Infinity
      };

      if (this.sourceRoot != null) {
        needle.source = util.relative(this.sourceRoot, needle.source);
      }

      var mappings = [];

      var index = this._findMapping(needle,
                                    this._originalMappings,
                                    "originalLine",
                                    "originalColumn",
                                    util.compareByOriginalPositions);
      if (index >= 0) {
        var mapping = this._originalMappings[index];

        while (mapping && mapping.originalLine === needle.originalLine) {
          mappings.push({
            line: util.getArg(mapping, 'generatedLine', null),
            column: util.getArg(mapping, 'generatedColumn', null),
            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
          });

          mapping = this._originalMappings[--index];
        }
      }

      return mappings.reverse();
    };

  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;

  /**
   * Iterate over each mapping between an original source/line/column and a
   * generated line/column in this source map.
   *
   * @param Function aCallback
   *        The function that is called with each mapping.
   * @param Object aContext
   *        Optional. If specified, this object will be the value of `this` every
   *        time that `aCallback` is called.
   * @param aOrder
   *        Either `SourceMapConsumer.GENERATED_ORDER` or
   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
   *        iterate over the mappings sorted by the generated file's line/column
   *        order or the original's source/line/column order, respectively. Defaults to
   *        `SourceMapConsumer.GENERATED_ORDER`.
   */
  SourceMapConsumer.prototype.eachMapping =
    function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

      var mappings;
      switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
      }

      var sourceRoot = this.sourceRoot;
      mappings.map(function (mapping) {
        var source = mapping.source;
        if (source != null && sourceRoot != null) {
          source = util.join(sourceRoot, source);
        }
        return {
          source: source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name
        };
      }).forEach(aCallback, context);
    };

  exports.SourceMapConsumer = SourceMapConsumer;

});

},{"./array-set":32,"./base64-vlq":33,"./binary-search":35,"./util":40,"amdefine":15}],38:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var base64VLQ = require('./base64-vlq');
  var util = require('./util');
  var ArraySet = require('./array-set').ArraySet;
  var MappingList = require('./mapping-list').MappingList;

  /**
   * An instance of the SourceMapGenerator represents a source map which is
   * being built incrementally. You may pass an object with the following
   * properties:
   *
   *   - file: The filename of the generated source.
   *   - sourceRoot: A root for all relative URLs in this source map.
   */
  function SourceMapGenerator(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util.getArg(aArgs, 'file', null);
    this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
    this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = new MappingList();
    this._sourcesContents = null;
  }

  SourceMapGenerator.prototype._version = 3;

  /**
   * Creates a new SourceMapGenerator based on a SourceMapConsumer
   *
   * @param aSourceMapConsumer The SourceMap.
   */
  SourceMapGenerator.fromSourceMap =
    function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot: sourceRoot
      });
      aSourceMapConsumer.eachMapping(function (mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };

        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }

          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };

          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }

        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };

  /**
   * Add a single mapping from original source line and column to the generated
   * source's line and column for this source map being created. The mapping
   * object should have the following properties:
   *
   *   - generated: An object with the generated line and column positions.
   *   - original: An object with the original line and column positions.
   *   - source: The original source file (relative to the sourceRoot).
   *   - name: An optional original token name for this mapping.
   */
  SourceMapGenerator.prototype.addMapping =
    function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, 'generated');
      var original = util.getArg(aArgs, 'original', null);
      var source = util.getArg(aArgs, 'source', null);
      var name = util.getArg(aArgs, 'name', null);

      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name);
      }

      if (source != null && !this._sources.has(source)) {
        this._sources.add(source);
      }

      if (name != null && !this._names.has(name)) {
        this._names.add(name);
      }

      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source: source,
        name: name
      });
    };

  /**
   * Set the source content for a source file.
   */
  SourceMapGenerator.prototype.setSourceContent =
    function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }

      if (aSourceContent != null) {
        // Add the source content to the _sourcesContents map.
        // Create a new _sourcesContents map if the property is null.
        if (!this._sourcesContents) {
          this._sourcesContents = {};
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        // Remove the source file from the _sourcesContents map.
        // If the _sourcesContents map is empty, set the property to null.
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };

  /**
   * Applies the mappings of a sub-source-map for a specific source file to the
   * source map being generated. Each mapping to the supplied source file is
   * rewritten using the supplied source map. Note: The resolution for the
   * resulting mappings is the minimium of this map and the supplied map.
   *
   * @param aSourceMapConsumer The source map to be applied.
   * @param aSourceFile Optional. The filename of the source file.
   *        If omitted, SourceMapConsumer's file property will be used.
   * @param aSourceMapPath Optional. The dirname of the path to the source map
   *        to be applied. If relative, it is relative to the SourceMapConsumer.
   *        This parameter is needed when the two source maps aren't in the same
   *        directory, and the source map to be applied contains relative source
   *        paths. If so, those relative source paths need to be rewritten
   *        relative to the SourceMapGenerator.
   */
  SourceMapGenerator.prototype.applySourceMap =
    function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      // If aSourceFile is omitted, we will use the file property of the SourceMap
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
            'or the source map\'s "file" property. Both were omitted.'
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      // Make "sourceFile" relative if an absolute Url is passed.
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      // Applying the SourceMap can add and remove items from the sources and
      // the names array.
      var newSources = new ArraySet();
      var newNames = new ArraySet();

      // Find mappings for the "sourceFile"
      this._mappings.unsortedForEach(function (mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          // Check if it can be mapped by the source map, then update the mapping.
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            // Copy mapping
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source)
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }

        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }

        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }

      }, this);
      this._sources = newSources;
      this._names = newNames;

      // Copy sourcesContents of applied map.
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile = util.join(aSourceMapPath, sourceFile);
          }
          if (sourceRoot != null) {
            sourceFile = util.relative(sourceRoot, sourceFile);
          }
          this.setSourceContent(sourceFile, content);
        }
      }, this);
    };

  /**
   * A mapping can have one of the three levels of data:
   *
   *   1. Just the generated position.
   *   2. The Generated position, original position, and original source.
   *   3. Generated and original position, original source, as well as a name
   *      token.
   *
   * To maintain consistency, we validate that any new mapping being added falls
   * in to one of these categories.
   */
  SourceMapGenerator.prototype._validateMapping =
    function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                                aName) {
      if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
          && aGenerated.line > 0 && aGenerated.column >= 0
          && !aOriginal && !aSource && !aName) {
        // Case 1.
        return;
      }
      else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
               && aOriginal && 'line' in aOriginal && 'column' in aOriginal
               && aGenerated.line > 0 && aGenerated.column >= 0
               && aOriginal.line > 0 && aOriginal.column >= 0
               && aSource) {
        // Cases 2 and 3.
        return;
      }
      else {
        throw new Error('Invalid mapping: ' + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };

  /**
   * Serialize the accumulated mappings in to the stream of base 64 VLQs
   * specified by the source map format.
   */
  SourceMapGenerator.prototype._serializeMappings =
    function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = '';
      var mapping;

      var mappings = this._mappings.toArray();

      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];

        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            result += ';';
            previousGeneratedLine++;
          }
        }
        else {
          if (i > 0) {
            if (!util.compareByGeneratedPositions(mapping, mappings[i - 1])) {
              continue;
            }
            result += ',';
          }
        }

        result += base64VLQ.encode(mapping.generatedColumn
                                   - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;

        if (mapping.source != null) {
          result += base64VLQ.encode(this._sources.indexOf(mapping.source)
                                     - previousSource);
          previousSource = this._sources.indexOf(mapping.source);

          // lines are stored 0-based in SourceMap spec version 3
          result += base64VLQ.encode(mapping.originalLine - 1
                                     - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;

          result += base64VLQ.encode(mapping.originalColumn
                                     - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;

          if (mapping.name != null) {
            result += base64VLQ.encode(this._names.indexOf(mapping.name)
                                       - previousName);
            previousName = this._names.indexOf(mapping.name);
          }
        }
      }

      return result;
    };

  SourceMapGenerator.prototype._generateSourcesContent =
    function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function (source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents,
                                                    key)
          ? this._sourcesContents[key]
          : null;
      }, this);
    };

  /**
   * Externalize the source map.
   */
  SourceMapGenerator.prototype.toJSON =
    function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }

      return map;
    };

  /**
   * Render the source map being generated to a string.
   */
  SourceMapGenerator.prototype.toString =
    function SourceMapGenerator_toString() {
      return JSON.stringify(this);
    };

  exports.SourceMapGenerator = SourceMapGenerator;

});

},{"./array-set":32,"./base64-vlq":33,"./mapping-list":36,"./util":40,"amdefine":15}],39:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;
  var util = require('./util');

  // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
  // operating systems these days (capturing the result).
  var REGEX_NEWLINE = /(\r?\n)/;

  // Newline character code for charCodeAt() comparisons
  var NEWLINE_CODE = 10;

  // Private symbol for identifying `SourceNode`s when multiple versions of
  // the source-map library are loaded. This MUST NOT CHANGE across
  // versions!
  var isSourceNode = "$$$isSourceNode$$$";

  /**
   * SourceNodes provide a way to abstract over interpolating/concatenating
   * snippets of generated JavaScript source code while maintaining the line and
   * column information associated with the original source code.
   *
   * @param aLine The original line number.
   * @param aColumn The original column number.
   * @param aSource The original source's filename.
   * @param aChunks Optional. An array of strings which are snippets of
   *        generated JS, or other SourceNodes.
   * @param aName The original identifier.
   */
  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null) this.add(aChunks);
  }

  /**
   * Creates a SourceNode from generated code and a SourceMapConsumer.
   *
   * @param aGeneratedCode The generated code
   * @param aSourceMapConsumer The SourceMap for the generated code
   * @param aRelativePath Optional. The path that relative sources in the
   *        SourceMapConsumer should be relative to.
   */
  SourceNode.fromStringWithSourceMap =
    function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      // The SourceNode we want to fill with the generated code
      // and the SourceMap
      var node = new SourceNode();

      // All even indices of this array are one line of the generated code,
      // while all odd indices are the newlines between two adjacent lines
      // (since `REGEX_NEWLINE` captures its match).
      // Processed fragments are removed from this array, by calling `shiftNextLine`.
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var shiftNextLine = function() {
        var lineContents = remainingLines.shift();
        // The last line of a file might not have a newline.
        var newLine = remainingLines.shift() || "";
        return lineContents + newLine;
      };

      // We need to remember the position of "remainingLines"
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;

      // The generate SourceNodes we need a code range.
      // To extract it current and last mapping is used.
      // Here we store the last mapping.
      var lastMapping = null;

      aSourceMapConsumer.eachMapping(function (mapping) {
        if (lastMapping !== null) {
          // We add the code from "lastMapping" to "mapping":
          // First check if there is a new line in between.
          if (lastGeneratedLine < mapping.generatedLine) {
            var code = "";
            // Associate first line with "lastMapping"
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
            // The remaining code is added without mapping
          } else {
            // There is no new line in between.
            // Associate the code between "lastGeneratedColumn" and
            // "mapping.generatedColumn" with "lastMapping"
            var nextLine = remainingLines[0];
            var code = nextLine.substr(0, mapping.generatedColumn -
                                          lastGeneratedColumn);
            remainingLines[0] = nextLine.substr(mapping.generatedColumn -
                                                lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            // No more remaining code, continue
            lastMapping = mapping;
            return;
          }
        }
        // We add the generated code until the first mapping
        // to the SourceNode without any mapping.
        // Each line is added as separate string.
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[0];
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[0] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      // We have processed all mappings.
      if (remainingLines.length > 0) {
        if (lastMapping) {
          // Associate the remaining code in the current line with "lastMapping"
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        // and add the remaining lines without any mapping
        node.add(remainingLines.join(""));
      }

      // Copy sourcesContent into SourceNode
      aSourceMapConsumer.sources.forEach(function (sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });

      return node;

      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === undefined) {
          node.add(code);
        } else {
          var source = aRelativePath
            ? util.join(aRelativePath, mapping.source)
            : mapping.source;
          node.add(new SourceNode(mapping.originalLine,
                                  mapping.originalColumn,
                                  source,
                                  code,
                                  mapping.name));
        }
      }
    };

  /**
   * Add a chunk of generated JS to this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function (chunk) {
        this.add(chunk);
      }, this);
    }
    else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Add a chunk of generated JS to the beginning of this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length-1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    }
    else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    }
    else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };

  /**
   * Walk over the tree of JS snippets in this node and its children. The
   * walking function is called once for each snippet of JS and is passed that
   * snippet and the its original associated source's line/column location.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for (var i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];
      if (chunk[isSourceNode]) {
        chunk.walk(aFn);
      }
      else {
        if (chunk !== '') {
          aFn(chunk, { source: this.source,
                       line: this.line,
                       column: this.column,
                       name: this.name });
        }
      }
    }
  };

  /**
   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
   * each of `this.children`.
   *
   * @param aSep The separator.
   */
  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i = 0; i < len-1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
    }
    return this;
  };

  /**
   * Call String.prototype.replace on the very right-most source snippet. Useful
   * for trimming whitespace from the end of a source node, etc.
   *
   * @param aPattern The pattern to replace.
   * @param aReplacement The thing to replace the pattern with.
   */
  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild[isSourceNode]) {
      lastChild.replaceRight(aPattern, aReplacement);
    }
    else if (typeof lastChild === 'string') {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    }
    else {
      this.children.push(''.replace(aPattern, aReplacement));
    }
    return this;
  };

  /**
   * Set the source content for a source file. This will be added to the SourceMapGenerator
   * in the sourcesContent field.
   *
   * @param aSourceFile The filename of the source file
   * @param aSourceContent The content of the source file
   */
  SourceNode.prototype.setSourceContent =
    function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };

  /**
   * Walk over the tree of SourceNodes. The walking function is called for each
   * source file content and is passed the filename and source content.
   *
   * @param aFn The traversal function.
   */
  SourceNode.prototype.walkSourceContents =
    function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i][isSourceNode]) {
          this.children[i].walkSourceContents(aFn);
        }
      }

      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };

  /**
   * Return the string representation of this source node. Walks over the tree
   * and concatenates all the various snippets together to one string.
   */
  SourceNode.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function (chunk) {
      str += chunk;
    });
    return str;
  };

  /**
   * Returns the string representation of this source node along with a source
   * map.
   */
  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map = new SourceMapGenerator(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function (chunk, original) {
      generated.code += chunk;
      if (original.source !== null
          && original.line !== null
          && original.column !== null) {
        if(lastOriginalSource !== original.source
           || lastOriginalLine !== original.line
           || lastOriginalColumn !== original.column
           || lastOriginalName !== original.name) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }
      for (var idx = 0, length = chunk.length; idx < length; idx++) {
        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
          generated.line++;
          generated.column = 0;
          // Mappings end at eol
          if (idx + 1 === length) {
            lastOriginalSource = null;
            sourceMappingActive = false;
          } else if (sourceMappingActive) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
        } else {
          generated.column++;
        }
      }
    });
    this.walkSourceContents(function (sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });

    return { code: generated.code, map: map };
  };

  exports.SourceNode = SourceNode;

});

},{"./source-map-generator":38,"./util":40,"amdefine":15}],40:[function(require,module,exports){
/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
if (typeof define !== 'function') {
    var define = require('amdefine')(module, require);
}
define(function (require, exports, module) {

  /**
   * This is a helper function for getting values from parameter/options
   * objects.
   *
   * @param args The object we are extracting values from
   * @param name The name of the property we are getting.
   * @param defaultValue An optional value to return if the property is missing
   * from the object. If this is not specified and the property is missing, an
   * error will be thrown.
   */
  function getArg(aArgs, aName, aDefaultValue) {
    if (aName in aArgs) {
      return aArgs[aName];
    } else if (arguments.length === 3) {
      return aDefaultValue;
    } else {
      throw new Error('"' + aName + '" is a required argument.');
    }
  }
  exports.getArg = getArg;

  var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
  var dataUrlRegexp = /^data:.+\,.+$/;

  function urlParse(aUrl) {
    var match = aUrl.match(urlRegexp);
    if (!match) {
      return null;
    }
    return {
      scheme: match[1],
      auth: match[2],
      host: match[3],
      port: match[4],
      path: match[5]
    };
  }
  exports.urlParse = urlParse;

  function urlGenerate(aParsedUrl) {
    var url = '';
    if (aParsedUrl.scheme) {
      url += aParsedUrl.scheme + ':';
    }
    url += '//';
    if (aParsedUrl.auth) {
      url += aParsedUrl.auth + '@';
    }
    if (aParsedUrl.host) {
      url += aParsedUrl.host;
    }
    if (aParsedUrl.port) {
      url += ":" + aParsedUrl.port
    }
    if (aParsedUrl.path) {
      url += aParsedUrl.path;
    }
    return url;
  }
  exports.urlGenerate = urlGenerate;

  /**
   * Normalizes a path, or the path portion of a URL:
   *
   * - Replaces consequtive slashes with one slash.
   * - Removes unnecessary '.' parts.
   * - Removes unnecessary '<dir>/..' parts.
   *
   * Based on code in the Node.js 'path' core module.
   *
   * @param aPath The path or url to normalize.
   */
  function normalize(aPath) {
    var path = aPath;
    var url = urlParse(aPath);
    if (url) {
      if (!url.path) {
        return aPath;
      }
      path = url.path;
    }
    var isAbsolute = (path.charAt(0) === '/');

    var parts = path.split(/\/+/);
    for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
      part = parts[i];
      if (part === '.') {
        parts.splice(i, 1);
      } else if (part === '..') {
        up++;
      } else if (up > 0) {
        if (part === '') {
          // The first part is blank if the path is absolute. Trying to go
          // above the root is a no-op. Therefore we can remove all '..' parts
          // directly after the root.
          parts.splice(i + 1, up);
          up = 0;
        } else {
          parts.splice(i, 2);
          up--;
        }
      }
    }
    path = parts.join('/');

    if (path === '') {
      path = isAbsolute ? '/' : '.';
    }

    if (url) {
      url.path = path;
      return urlGenerate(url);
    }
    return path;
  }
  exports.normalize = normalize;

  /**
   * Joins two paths/URLs.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be joined with the root.
   *
   * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
   *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
   *   first.
   * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
   *   is updated with the result and aRoot is returned. Otherwise the result
   *   is returned.
   *   - If aPath is absolute, the result is aPath.
   *   - Otherwise the two paths are joined with a slash.
   * - Joining for example 'http://' and 'www.example.com' is also supported.
   */
  function join(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }
    if (aPath === "") {
      aPath = ".";
    }
    var aPathUrl = urlParse(aPath);
    var aRootUrl = urlParse(aRoot);
    if (aRootUrl) {
      aRoot = aRootUrl.path || '/';
    }

    // `join(foo, '//www.example.org')`
    if (aPathUrl && !aPathUrl.scheme) {
      if (aRootUrl) {
        aPathUrl.scheme = aRootUrl.scheme;
      }
      return urlGenerate(aPathUrl);
    }

    if (aPathUrl || aPath.match(dataUrlRegexp)) {
      return aPath;
    }

    // `join('http://', 'www.example.com')`
    if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
      aRootUrl.host = aPath;
      return urlGenerate(aRootUrl);
    }

    var joined = aPath.charAt(0) === '/'
      ? aPath
      : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

    if (aRootUrl) {
      aRootUrl.path = joined;
      return urlGenerate(aRootUrl);
    }
    return joined;
  }
  exports.join = join;

  /**
   * Make a path relative to a URL or another path.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be made relative to aRoot.
   */
  function relative(aRoot, aPath) {
    if (aRoot === "") {
      aRoot = ".";
    }

    aRoot = aRoot.replace(/\/$/, '');

    // XXX: It is possible to remove this block, and the tests still pass!
    var url = urlParse(aRoot);
    if (aPath.charAt(0) == "/" && url && url.path == "/") {
      return aPath.slice(1);
    }

    return aPath.indexOf(aRoot + '/') === 0
      ? aPath.substr(aRoot.length + 1)
      : aPath;
  }
  exports.relative = relative;

  /**
   * Because behavior goes wacky when you set `__proto__` on objects, we
   * have to prefix all the strings in our set with an arbitrary character.
   *
   * See https://github.com/mozilla/source-map/pull/31 and
   * https://github.com/mozilla/source-map/issues/30
   *
   * @param String aStr
   */
  function toSetString(aStr) {
    return '$' + aStr;
  }
  exports.toSetString = toSetString;

  function fromSetString(aStr) {
    return aStr.substr(1);
  }
  exports.fromSetString = fromSetString;

  function strcmp(aStr1, aStr2) {
    var s1 = aStr1 || "";
    var s2 = aStr2 || "";
    return (s1 > s2) - (s1 < s2);
  }

  /**
   * Comparator between two mappings where the original positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same original source/line/column, but different generated
   * line and column the same. Useful when searching for a mapping with a
   * stubbed out mapping.
   */
  function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
    var cmp;

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp || onlyCompareOriginal) {
      return cmp;
    }

    cmp = strcmp(mappingA.name, mappingB.name);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp) {
      return cmp;
    }

    return mappingA.generatedColumn - mappingB.generatedColumn;
  };
  exports.compareByOriginalPositions = compareByOriginalPositions;

  /**
   * Comparator between two mappings where the generated positions are
   * compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same generated line and column, but different
   * source/name/original line and column the same. Useful when searching for a
   * mapping with a stubbed out mapping.
   */
  function compareByGeneratedPositions(mappingA, mappingB, onlyCompareGenerated) {
    var cmp;

    cmp = mappingA.generatedLine - mappingB.generatedLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.generatedColumn - mappingB.generatedColumn;
    if (cmp || onlyCompareGenerated) {
      return cmp;
    }

    cmp = strcmp(mappingA.source, mappingB.source);
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalLine - mappingB.originalLine;
    if (cmp) {
      return cmp;
    }

    cmp = mappingA.originalColumn - mappingB.originalColumn;
    if (cmp) {
      return cmp;
    }

    return strcmp(mappingA.name, mappingB.name);
  };
  exports.compareByGeneratedPositions = compareByGeneratedPositions;

});

},{"amdefine":15}],41:[function(require,module,exports){
var indexOf = require('indexof');

var Object_keys = function (obj) {
    if (Object.keys) return Object.keys(obj)
    else {
        var res = [];
        for (var key in obj) res.push(key)
        return res;
    }
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

var defineProp = (function() {
    try {
        Object.defineProperty({}, '_', {});
        return function(obj, name, value) {
            Object.defineProperty(obj, name, {
                writable: true,
                enumerable: false,
                configurable: true,
                value: value
            })
        };
    } catch(e) {
        return function(obj, name, value) {
            obj[name] = value;
        };
    }
}());

var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

function Context() {}
Context.prototype = {};

var Script = exports.Script = function NodeScript (code) {
    if (!(this instanceof Script)) return new Script(code);
    this.code = code;
};

Script.prototype.runInContext = function (context) {
    if (!(context instanceof Context)) {
        throw new TypeError("needs a 'context' argument.");
    }
    
    var iframe = document.createElement('iframe');
    if (!iframe.style) iframe.style = {};
    iframe.style.display = 'none';
    
    document.body.appendChild(iframe);
    
    var win = iframe.contentWindow;
    var wEval = win.eval, wExecScript = win.execScript;

    if (!wEval && wExecScript) {
        // win.eval() magically appears when this is called in IE:
        wExecScript.call(win, 'null');
        wEval = win.eval;
    }
    
    forEach(Object_keys(context), function (key) {
        win[key] = context[key];
    });
    forEach(globals, function (key) {
        if (context[key]) {
            win[key] = context[key];
        }
    });
    
    var winKeys = Object_keys(win);

    var res = wEval.call(win, this.code);
    
    forEach(Object_keys(win), function (key) {
        // Avoid copying circular objects like `top` and `window` by only
        // updating existing context properties or new properties in the `win`
        // that was only introduced after the eval.
        if (key in context || indexOf(winKeys, key) === -1) {
            context[key] = win[key];
        }
    });

    forEach(globals, function (key) {
        if (!(key in context)) {
            defineProp(context, key, win[key]);
        }
    });
    
    document.body.removeChild(iframe);
    
    return res;
};

Script.prototype.runInThisContext = function () {
    return eval(this.code); // maybe...
};

Script.prototype.runInNewContext = function (context) {
    var ctx = Script.createContext(context);
    var res = this.runInContext(ctx);

    forEach(Object_keys(ctx), function (key) {
        context[key] = ctx[key];
    });

    return res;
};

forEach(Object_keys(Script.prototype), function (name) {
    exports[name] = Script[name] = function (code) {
        var s = Script(code);
        return s[name].apply(s, [].slice.call(arguments, 1));
    };
});

exports.createScript = function (code) {
    return exports.Script(code);
};

exports.createContext = Script.createContext = function (context) {
    var copy = new Context();
    if(typeof context === 'object') {
        forEach(Object_keys(context), function (key) {
            copy[key] = context[key];
        });
    }
    return copy;
};

},{"indexof":28}],"vmsNNR":[function(require,module,exports){
{
    var _ns_ = {
            id: 'wisp.reader',
            doc: 'Reader module provides functions for reading text input\n  as wisp data structures'
        };
    var wisp_sequence = require('./sequence');
    var list = wisp_sequence.list;
    var isList = wisp_sequence.isList;
    var count = wisp_sequence.count;
    var isEmpty = wisp_sequence.isEmpty;
    var first = wisp_sequence.first;
    var second = wisp_sequence.second;
    var third = wisp_sequence.third;
    var rest = wisp_sequence.rest;
    var map = wisp_sequence.map;
    var vec = wisp_sequence.vec;
    var cons = wisp_sequence.cons;
    var conj = wisp_sequence.conj;
    var rest = wisp_sequence.rest;
    var concat = wisp_sequence.concat;
    var last = wisp_sequence.last;
    var butlast = wisp_sequence.butlast;
    var sort = wisp_sequence.sort;
    var lazySeq = wisp_sequence.lazySeq;
    var reduce = wisp_sequence.reduce;
    var wisp_runtime = require('./runtime');
    var isOdd = wisp_runtime.isOdd;
    var dictionary = wisp_runtime.dictionary;
    var keys = wisp_runtime.keys;
    var isNil = wisp_runtime.isNil;
    var inc = wisp_runtime.inc;
    var dec = wisp_runtime.dec;
    var isVector = wisp_runtime.isVector;
    var isString = wisp_runtime.isString;
    var isNumber = wisp_runtime.isNumber;
    var isBoolean = wisp_runtime.isBoolean;
    var isObject = wisp_runtime.isObject;
    var isDictionary = wisp_runtime.isDictionary;
    var rePattern = wisp_runtime.rePattern;
    var reMatches = wisp_runtime.reMatches;
    var reFind = wisp_runtime.reFind;
    var str = wisp_runtime.str;
    var subs = wisp_runtime.subs;
    var char = wisp_runtime.char;
    var vals = wisp_runtime.vals;
    var isEqual = wisp_runtime.isEqual;
    var wisp_ast = require('./ast');
    var isSymbol = wisp_ast.isSymbol;
    var symbol = wisp_ast.symbol;
    var isKeyword = wisp_ast.isKeyword;
    var keyword = wisp_ast.keyword;
    var meta = wisp_ast.meta;
    var withMeta = wisp_ast.withMeta;
    var name = wisp_ast.name;
    var gensym = wisp_ast.gensym;
    var wisp_string = require('./string');
    var split = wisp_string.split;
    var join = wisp_string.join;
}
var pushBackReader = exports.pushBackReader = function pushBackReader(source, uri) {
        return {
            'lines': split(source, '\n'),
            'buffer': '',
            'uri': uri,
            'column': -1,
            'line': 0
        };
    };
var peekChar = exports.peekChar = function peekChar(reader) {
        return function () {
            var lineø1 = (reader || 0)['lines'][(reader || 0)['line']];
            var columnø1 = inc((reader || 0)['column']);
            return isNil(lineø1) ? void 0 : lineø1[columnø1] || '\n';
        }.call(this);
    };
var readChar = exports.readChar = function readChar(reader) {
        return function () {
            var chø1 = peekChar(reader);
            isNewline(peekChar(reader)) ? (function () {
                (reader || 0)['line'] = inc((reader || 0)['line']);
                return (reader || 0)['column'] = -1;
            })() : (reader || 0)['column'] = inc((reader || 0)['column']);
            return chø1;
        }.call(this);
    };
var isNewline = exports.isNewline = function isNewline(ch) {
        return '\n' === ch;
    };
var isBreakingWhitespace = exports.isBreakingWhitespace = function isBreakingWhitespace(ch) {
        return ch === ' ' || ch === '\t' || ch === '\n' || ch === '\r';
    };
var isWhitespace = exports.isWhitespace = function isWhitespace(ch) {
        return isBreakingWhitespace(ch) || ',' === ch;
    };
var isNumeric = exports.isNumeric = function isNumeric(ch) {
        return ch === '0' || ch === '1' || ch === '2' || ch === '3' || ch === '4' || ch === '5' || ch === '6' || ch === '7' || ch === '8' || ch === '9';
    };
var isCommentPrefix = exports.isCommentPrefix = function isCommentPrefix(ch) {
        return ';' === ch;
    };
var isNumberLiteral = exports.isNumberLiteral = function isNumberLiteral(reader, initch) {
        return isNumeric(initch) || ('+' === initch || '-' === initch) && isNumeric(peekChar(reader));
    };
var readerError = exports.readerError = function readerError(reader, message) {
        return function () {
            var textø1 = '' + message + '\n' + 'line:' + (reader || 0)['line'] + '\n' + 'column:' + (reader || 0)['column'];
            var errorø1 = SyntaxError(textø1, (reader || 0)['uri']);
            errorø1.line = (reader || 0)['line'];
            errorø1.column = (reader || 0)['column'];
            errorø1.uri = (reader || 0)['uri'];
            return (function () {
                throw errorø1;
            })();
        }.call(this);
    };
var isMacroTerminating = exports.isMacroTerminating = function isMacroTerminating(ch) {
        return !(ch === '#') && !(ch === '\'') && !(ch === ':') && macros(ch);
    };
var readToken = exports.readToken = function readToken(reader, initch) {
        return function loop() {
            var recur = loop;
            var bufferø1 = initch;
            var chø1 = peekChar(reader);
            do {
                recur = isNil(chø1) || isWhitespace(chø1) || isMacroTerminating(chø1) ? bufferø1 : (loop[0] = '' + bufferø1 + readChar(reader), loop[1] = peekChar(reader), loop);
            } while (bufferø1 = loop[0], chø1 = loop[1], recur === loop);
            return recur;
        }.call(this);
    };
var skipLine = exports.skipLine = function skipLine(reader, _) {
        return function loop() {
            var recur = loop;
            do {
                recur = function () {
                    var chø1 = readChar(reader);
                    return chø1 === '\n' || chø1 === '\r' || isNil(chø1) ? reader : (loop);
                }.call(this);
            } while (recur === loop);
            return recur;
        }.call(this);
    };
var intPattern = exports.intPattern = rePattern('^([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?$');
var ratioPattern = exports.ratioPattern = rePattern('([-+]?[0-9]+)/([0-9]+)');
var floatPattern = exports.floatPattern = rePattern('([-+]?[0-9]+(\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?');
var matchInt = exports.matchInt = function matchInt(s) {
        return function () {
            var groupsø1 = reFind(intPattern, s);
            var group3ø1 = groupsø1[2];
            return !(isNil(group3ø1) || count(group3ø1) < 1) ? 0 : function () {
                var negateø1 = '-' === groupsø1[1] ? -1 : 1;
                var aø1 = groupsø1[3] ? [
                        groupsø1[3],
                        10
                    ] : groupsø1[4] ? [
                        groupsø1[4],
                        16
                    ] : groupsø1[5] ? [
                        groupsø1[5],
                        8
                    ] : groupsø1[7] ? [
                        groupsø1[7],
                        parseInt(groupsø1[7])
                    ] : 'else' ? [
                        void 0,
                        void 0
                    ] : void 0;
                var nø1 = aø1[0];
                var radixø1 = aø1[1];
                return isNil(nø1) ? void 0 : negateø1 * parseInt(nø1, radixø1);
            }.call(this);
        }.call(this);
    };
var matchRatio = exports.matchRatio = function matchRatio(s) {
        return function () {
            var groupsø1 = reFind(ratioPattern, s);
            var numinatorø1 = groupsø1[1];
            var denominatorø1 = groupsø1[2];
            return parseInt(numinatorø1) / parseInt(denominatorø1);
        }.call(this);
    };
var matchFloat = exports.matchFloat = function matchFloat(s) {
        return parseFloat(s);
    };
var matchNumber = exports.matchNumber = function matchNumber(s) {
        return reMatches(intPattern, s) ? matchInt(s) : reMatches(ratioPattern, s) ? matchRatio(s) : reMatches(floatPattern, s) ? matchFloat(s) : void 0;
    };
var escapeCharMap = exports.escapeCharMap = function escapeCharMap(c) {
        return c === 't' ? '\t' : c === 'r' ? '\r' : c === 'n' ? '\n' : c === '\\' ? '\\' : c === '"' ? '"' : c === 'b' ? '\b' : c === 'f' ? '\f' : 'else' ? void 0 : void 0;
    };
var read2Chars = exports.read2Chars = function read2Chars(reader) {
        return '' + readChar(reader) + readChar(reader);
    };
var read4Chars = exports.read4Chars = function read4Chars(reader) {
        return '' + readChar(reader) + readChar(reader) + readChar(reader) + readChar(reader);
    };
var unicode2Pattern = exports.unicode2Pattern = rePattern('[0-9A-Fa-f]{2}');
var unicode4Pattern = exports.unicode4Pattern = rePattern('[0-9A-Fa-f]{4}');
var validateUnicodeEscape = exports.validateUnicodeEscape = function validateUnicodeEscape(unicodePattern, reader, escapeChar, unicodeStr) {
        return reMatches(unicodePattern, unicodeStr) ? unicodeStr : readerError(reader, '' + 'Unexpected unicode escape ' + '\\' + escapeChar + unicodeStr);
    };
var makeUnicodeChar = exports.makeUnicodeChar = function makeUnicodeChar(codeStr, base) {
        return function () {
            var baseø2 = base || 16;
            var codeø1 = parseInt(codeStr, baseø2);
            return char(codeø1);
        }.call(this);
    };
var escapeChar = exports.escapeChar = function escapeChar(buffer, reader) {
        return function () {
            var chø1 = readChar(reader);
            var mapresultø1 = escapeCharMap(chø1);
            return mapresultø1 ? mapresultø1 : chø1 === 'x' ? makeUnicodeChar(validateUnicodeEscape(unicode2Pattern, reader, chø1, read2Chars(reader))) : chø1 === 'u' ? makeUnicodeChar(validateUnicodeEscape(unicode4Pattern, reader, chø1, read4Chars(reader))) : isNumeric(chø1) ? char(chø1) : 'else' ? readerError(reader, '' + 'Unexpected unicode escape ' + '\\' + chø1) : void 0;
        }.call(this);
    };
var readPast = exports.readPast = function readPast(predicate, reader) {
        return function loop() {
            var recur = loop;
            var _ø1 = void 0;
            do {
                recur = predicate(peekChar(reader)) ? (loop[0] = readChar(reader), loop) : peekChar(reader);
            } while (_ø1 = loop[0], recur === loop);
            return recur;
        }.call(this);
    };
var readDelimitedList = exports.readDelimitedList = function readDelimitedList(delim, reader, isRecursive) {
        return function loop() {
            var recur = loop;
            var formsø1 = [];
            do {
                recur = function () {
                    var _ø1 = readPast(isWhitespace, reader);
                    var chø1 = readChar(reader);
                    !chø1 ? readerError(reader, 'EOF') : void 0;
                    return delim === chø1 ? formsø1 : function () {
                        var formø1 = readForm(reader, chø1);
                        return loop[0] = formø1 === reader ? formsø1 : conj(formsø1, formø1), loop;
                    }.call(this);
                }.call(this);
            } while (formsø1 = loop[0], recur === loop);
            return recur;
        }.call(this);
    };
var notImplemented = exports.notImplemented = function notImplemented(reader, ch) {
        return readerError(reader, '' + 'Reader for ' + ch + ' not implemented yet');
    };
var readDispatch = exports.readDispatch = function readDispatch(reader, _) {
        return function () {
            var chø1 = readChar(reader);
            var dmø1 = dispatchMacros(chø1);
            return dmø1 ? dmø1(reader, _) : function () {
                var objectø1 = maybeReadTaggedType(reader, chø1);
                return objectø1 ? objectø1 : readerError(reader, 'No dispatch macro for ', chø1);
            }.call(this);
        }.call(this);
    };
var readUnmatchedDelimiter = exports.readUnmatchedDelimiter = function readUnmatchedDelimiter(rdr, ch) {
        return readerError(rdr, 'Unmatched delimiter ', ch);
    };
var readList = exports.readList = function readList(reader, _) {
        return function () {
            var formø1 = readDelimitedList(')', reader, true);
            return withMeta(list.apply(void 0, formø1), meta(formø1));
        }.call(this);
    };
var readComment = exports.readComment = function readComment(reader, _) {
        return function loop() {
            var recur = loop;
            var bufferø1 = '';
            var chø1 = readChar(reader);
            do {
                recur = isNil(chø1) || '\n' === chø1 ? reader || list(symbol(void 0, 'comment'), bufferø1) : '\\' === chø1 ? (loop[0] = '' + bufferø1 + escapeChar(bufferø1, reader), loop[1] = readChar(reader), loop) : 'else' ? (loop[0] = '' + bufferø1 + chø1, loop[1] = readChar(reader), loop) : void 0;
            } while (bufferø1 = loop[0], chø1 = loop[1], recur === loop);
            return recur;
        }.call(this);
    };
var readVector = exports.readVector = function readVector(reader) {
        return readDelimitedList(']', reader, true);
    };
var readMap = exports.readMap = function readMap(reader) {
        return function () {
            var formø1 = readDelimitedList('}', reader, true);
            return isOdd(count(formø1)) ? readerError(reader, 'Map literal must contain an even number of forms') : withMeta(dictionary.apply(void 0, formø1), meta(formø1));
        }.call(this);
    };
var readSet = exports.readSet = function readSet(reader, _) {
        return function () {
            var formø1 = readDelimitedList('}', reader, true);
            return withMeta(concat([symbol(void 0, 'set')], formø1), meta(formø1));
        }.call(this);
    };
var readNumber = exports.readNumber = function readNumber(reader, initch) {
        return function loop() {
            var recur = loop;
            var bufferø1 = initch;
            var chø1 = peekChar(reader);
            do {
                recur = isNil(chø1) || isWhitespace(chø1) || macros(chø1) ? (function () {
                    var match = matchNumber(bufferø1);
                    return isNil(match) ? readerError(reader, 'Invalid number format [', bufferø1, ']') : new Number(match);
                })() : (loop[0] = '' + bufferø1 + readChar(reader), loop[1] = peekChar(reader), loop);
            } while (bufferø1 = loop[0], chø1 = loop[1], recur === loop);
            return recur;
        }.call(this);
    };
var readString = exports.readString = function readString(reader) {
        return function loop() {
            var recur = loop;
            var bufferø1 = '';
            var chø1 = readChar(reader);
            do {
                recur = isNil(chø1) ? readerError(reader, 'EOF while reading string') : '\\' === chø1 ? (loop[0] = '' + bufferø1 + escapeChar(bufferø1, reader), loop[1] = readChar(reader), loop) : '"' === chø1 ? new String(bufferø1) : 'default' ? (loop[0] = '' + bufferø1 + chø1, loop[1] = readChar(reader), loop) : void 0;
            } while (bufferø1 = loop[0], chø1 = loop[1], recur === loop);
            return recur;
        }.call(this);
    };
var readCharacter = exports.readCharacter = function readCharacter(reader) {
        return new String(readChar(reader));
    };
var readUnquote = exports.readUnquote = function readUnquote(reader) {
        return function () {
            var chø1 = peekChar(reader);
            return !chø1 ? readerError(reader, 'EOF while reading character') : chø1 === '@' ? (function () {
                readChar(reader);
                return list(symbol(void 0, 'unquote-splicing'), read(reader, true, void 0, true));
            })() : list(symbol(void 0, 'unquote'), read(reader, true, void 0, true));
        }.call(this);
    };
var specialSymbols = exports.specialSymbols = function specialSymbols(text, notFound) {
        return text === 'nil' ? void 0 : text === 'true' ? true : text === 'false' ? false : 'else' ? notFound : void 0;
    };
var readSymbol = exports.readSymbol = function readSymbol(reader, initch) {
        return function () {
            var tokenø1 = readToken(reader, initch);
            var partsø1 = split(tokenø1, '/');
            var hasNsø1 = count(partsø1) > 1 && count(tokenø1) > 1;
            var nsø1 = first(partsø1);
            var nameø1 = join('/', rest(partsø1));
            return hasNsø1 ? symbol(nsø1, nameø1) : specialSymbols(tokenø1, symbol(tokenø1));
        }.call(this);
    };
var readKeyword = exports.readKeyword = function readKeyword(reader, initch) {
        return function () {
            var tokenø1 = readToken(reader, readChar(reader));
            var partsø1 = split(tokenø1, '/');
            var nameø1 = last(partsø1);
            var nsø1 = count(partsø1) > 1 ? join('/', butlast(partsø1)) : void 0;
            var issueø1 = last(nsø1) === ':' ? 'namespace can\'t ends with ":"' : last(nameø1) === ':' ? 'name can\'t end with ":"' : last(nameø1) === '/' ? 'name can\'t end with "/"' : count(split(tokenø1, '::')) > 1 ? 'name can\'t contain "::"' : void 0;
            return issueø1 ? readerError(reader, 'Invalid token (', issueø1, '): ', tokenø1) : !nsø1 && first(nameø1) === ':' ? keyword(rest(nameø1)) : keyword(nsø1, nameø1);
        }.call(this);
    };
var desugarMeta = exports.desugarMeta = function desugarMeta(form) {
        return isKeyword(form) ? dictionary(name(form), true) : isSymbol(form) ? { 'tag': form } : isString(form) ? { 'tag': form } : isDictionary(form) ? reduce(function (result, pair) {
            (result || 0)[name(first(pair))] = second(pair);
            return result;
        }, {}, form) : 'else' ? form : void 0;
    };
var wrappingReader = exports.wrappingReader = function wrappingReader(prefix) {
        return function (reader) {
            return list(prefix, read(reader, true, void 0, true));
        };
    };
var throwingReader = exports.throwingReader = function throwingReader(msg) {
        return function (reader) {
            return readerError(reader, msg);
        };
    };
var readMeta = exports.readMeta = function readMeta(reader, _) {
        return function () {
            var metadataø1 = desugarMeta(read(reader, true, void 0, true));
            !isDictionary(metadataø1) ? readerError(reader, 'Metadata must be Symbol, Keyword, String or Map') : void 0;
            return function () {
                var formø1 = read(reader, true, void 0, true);
                return isObject(formø1) ? withMeta(formø1, conj(metadataø1, meta(formø1))) : formø1;
            }.call(this);
        }.call(this);
    };
var readRegex = exports.readRegex = function readRegex(reader) {
        return function loop() {
            var recur = loop;
            var bufferø1 = '';
            var chø1 = readChar(reader);
            do {
                recur = isNil(chø1) ? readerError(reader, 'EOF while reading string') : '\\' === chø1 ? (loop[0] = '' + bufferø1 + chø1 + readChar(reader), loop[1] = readChar(reader), loop) : '"' === chø1 ? rePattern(bufferø1) : 'default' ? (loop[0] = '' + bufferø1 + chø1, loop[1] = readChar(reader), loop) : void 0;
            } while (bufferø1 = loop[0], chø1 = loop[1], recur === loop);
            return recur;
        }.call(this);
    };
var readParam = exports.readParam = function readParam(reader, initch) {
        return function () {
            var formø1 = readSymbol(reader, initch);
            return isEqual(formø1, symbol('%')) ? symbol('%1') : formø1;
        }.call(this);
    };
var isParam = exports.isParam = function isParam(form) {
        return isSymbol(form) && '%' === first(name(form));
    };
var lambdaParamsHash = exports.lambdaParamsHash = function lambdaParamsHash(form) {
        return isParam(form) ? dictionary(form, form) : isDictionary(form) || isVector(form) || isList(form) ? conj.apply(void 0, map(lambdaParamsHash, vec(form))) : 'else' ? {} : void 0;
    };
var lambdaParams = exports.lambdaParams = function lambdaParams(body) {
        return function () {
            var namesø1 = sort(vals(lambdaParamsHash(body)));
            var variadicø1 = isEqual(first(namesø1), symbol('%&'));
            var nø1 = variadicø1 && count(namesø1) === 1 ? 0 : count(namesø1) === 0 ? 0 : 'else' ? parseInt(rest(name(last(namesø1)))) : void 0;
            var paramsø1 = function loop() {
                    var recur = loop;
                    var namesø2 = [];
                    var iø1 = 1;
                    do {
                        recur = iø1 <= nø1 ? (loop[0] = conj(namesø2, symbol('' + '%' + iø1)), loop[1] = inc(iø1), loop) : namesø2;
                    } while (namesø2 = loop[0], iø1 = loop[1], recur === loop);
                    return recur;
                }.call(this);
            return variadicø1 ? conj(paramsø1, symbol(void 0, '&'), symbol(void 0, '%&')) : namesø1;
        }.call(this);
    };
var readLambda = exports.readLambda = function readLambda(reader) {
        return function () {
            var bodyø1 = readList(reader);
            return list(symbol(void 0, 'fn'), lambdaParams(bodyø1), bodyø1);
        }.call(this);
    };
var readDiscard = exports.readDiscard = function readDiscard(reader, _) {
        read(reader, true, void 0, true);
        return reader;
    };
var macros = exports.macros = function macros(c) {
        return c === '"' ? readString : c === '\\' ? readCharacter : c === ':' ? readKeyword : c === ';' ? readComment : c === '\'' ? wrappingReader(symbol(void 0, 'quote')) : c === '@' ? wrappingReader(symbol(void 0, 'deref')) : c === '^' ? readMeta : c === '`' ? wrappingReader(symbol(void 0, 'syntax-quote')) : c === '~' ? readUnquote : c === '(' ? readList : c === ')' ? readUnmatchedDelimiter : c === '[' ? readVector : c === ']' ? readUnmatchedDelimiter : c === '{' ? readMap : c === '}' ? readUnmatchedDelimiter : c === '%' ? readParam : c === '#' ? readDispatch : 'else' ? void 0 : void 0;
    };
var dispatchMacros = exports.dispatchMacros = function dispatchMacros(s) {
        return s === '{' ? readSet : s === '(' ? readLambda : s === '<' ? throwingReader('Unreadable form') : s === '"' ? readRegex : s === '!' ? readComment : s === '_' ? readDiscard : 'else' ? void 0 : void 0;
    };
var readForm = exports.readForm = function readForm(reader, ch) {
        return function () {
            var startø1 = {
                    'line': (reader || 0)['line'],
                    'column': (reader || 0)['column']
                };
            var readMacroø1 = macros(ch);
            var formø1 = readMacroø1 ? readMacroø1(reader, ch) : isNumberLiteral(reader, ch) ? readNumber(reader, ch) : 'else' ? readSymbol(reader, ch) : void 0;
            var endø1 = {
                    'line': (reader || 0)['line'],
                    'column': inc((reader || 0)['column'])
                };
            var locationø1 = {
                    'uri': (reader || 0)['uri'],
                    'start': startø1,
                    'end': endø1
                };
            return formø1 === reader ? formø1 : !(isBoolean(formø1) || isNil(formø1) || isKeyword(formø1)) ? withMeta(formø1, conj(locationø1, meta(formø1))) : 'else' ? formø1 : void 0;
        }.call(this);
    };
var read = exports.read = function read(reader, eofIsError, sentinel, isRecursive) {
        return function loop() {
            var recur = loop;
            do {
                recur = function () {
                    var chø1 = readChar(reader);
                    var formø1 = isNil(chø1) ? eofIsError ? readerError(reader, 'EOF') : sentinel : isWhitespace(chø1) ? reader : isCommentPrefix(chø1) ? read(readComment(reader, chø1), eofIsError, sentinel, isRecursive) : 'else' ? readForm(reader, chø1) : void 0;
                    return formø1 === reader ? (loop) : formø1;
                }.call(this);
            } while (recur === loop);
            return recur;
        }.call(this);
    };
var read_ = exports.read_ = function read_(source, uri) {
        return function () {
            var readerø1 = pushBackReader(source, uri);
            var eofø1 = gensym();
            return function loop() {
                var recur = loop;
                var formsø1 = [];
                var formø1 = read(readerø1, false, eofø1, false);
                do {
                    recur = formø1 === eofø1 ? formsø1 : (loop[0] = conj(formsø1, formø1), loop[1] = read(readerø1, false, eofø1, false), loop);
                } while (formsø1 = loop[0], formø1 = loop[1], recur === loop);
                return recur;
            }.call(this);
        }.call(this);
    };
var readFromString = exports.readFromString = function readFromString(source, uri) {
        return function () {
            var readerø1 = pushBackReader(source, uri);
            return read(readerø1, true, void 0, false);
        }.call(this);
    };
var readUuid = function readUuid(uuid) {
    return isString(uuid) ? list.apply(void 0, [symbol(void 0, 'UUID.')].concat([uuid])) : readerError(void 0, 'UUID literal expects a string as its representation.');
};
var readQueue = function readQueue(items) {
    return isVector(items) ? list.apply(void 0, [symbol(void 0, 'PersistentQueue.')].concat([items])) : readerError(void 0, 'Queue literal expects a vector for its elements.');
};
var __tagTable__ = exports.__tagTable__ = dictionary('uuid', readUuid, 'queue', readQueue);
var maybeReadTaggedType = exports.maybeReadTaggedType = function maybeReadTaggedType(reader, initch) {
        return function () {
            var tagø1 = readSymbol(reader, initch);
            var pfnø1 = (__tagTable__ || 0)[name(tagø1)];
            return pfnø1 ? pfnø1(read(reader, true, void 0, false)) : readerError(reader, '' + 'Could not find tag parser for ' + name(tagø1) + ' in ' + ('' + keys(__tagTable__)));
        }.call(this);
    };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFub255bW91cy53aXNwIl0sIm5hbWVzIjpbIl9uc18iLCJpZCIsImRvYyIsImxpc3QiLCJpc0xpc3QiLCJjb3VudCIsImlzRW1wdHkiLCJmaXJzdCIsInNlY29uZCIsInRoaXJkIiwicmVzdCIsIm1hcCIsInZlYyIsImNvbnMiLCJjb25qIiwiY29uY2F0IiwibGFzdCIsImJ1dGxhc3QiLCJzb3J0IiwibGF6eVNlcSIsInJlZHVjZSIsImlzT2RkIiwiZGljdGlvbmFyeSIsImtleXMiLCJpc05pbCIsImluYyIsImRlYyIsImlzVmVjdG9yIiwiaXNTdHJpbmciLCJpc051bWJlciIsImlzQm9vbGVhbiIsImlzT2JqZWN0IiwiaXNEaWN0aW9uYXJ5IiwicmVQYXR0ZXJuIiwicmVNYXRjaGVzIiwicmVGaW5kIiwic3RyIiwic3VicyIsImNoYXIiLCJ2YWxzIiwiaXNFcXVhbCIsImlzU3ltYm9sIiwic3ltYm9sIiwiaXNLZXl3b3JkIiwia2V5d29yZCIsIm1ldGEiLCJ3aXRoTWV0YSIsIm5hbWUiLCJnZW5zeW0iLCJzcGxpdCIsImpvaW4iLCJwdXNoQmFja1JlYWRlciIsImV4cG9ydHMiLCJzb3VyY2UiLCJ1cmkiLCJwZWVrQ2hhciIsInJlYWRlciIsImxpbmXDuDEiLCJjb2x1bW7DuDEiLCJyZWFkQ2hhciIsImNow7gxIiwiaXNOZXdsaW5lIiwiY2giLCJpc0JyZWFraW5nV2hpdGVzcGFjZSIsImlzV2hpdGVzcGFjZSIsImlzTnVtZXJpYyIsImlzQ29tbWVudFByZWZpeCIsImlzTnVtYmVyTGl0ZXJhbCIsImluaXRjaCIsInJlYWRlckVycm9yIiwibWVzc2FnZSIsInRleHTDuDEiLCJlcnJvcsO4MSIsIlN5bnRheEVycm9yIiwibGluZSIsImNvbHVtbiIsImlzTWFjcm9UZXJtaW5hdGluZyIsIm1hY3JvcyIsInJlYWRUb2tlbiIsImJ1ZmZlcsO4MSIsInNraXBMaW5lIiwiXyIsImludFBhdHRlcm4iLCJyYXRpb1BhdHRlcm4iLCJmbG9hdFBhdHRlcm4iLCJtYXRjaEludCIsInMiLCJncm91cHPDuDEiLCJncm91cDPDuDEiLCJuZWdhdGXDuDEiLCJhw7gxIiwicGFyc2VJbnQiLCJuw7gxIiwicmFkaXjDuDEiLCJtYXRjaFJhdGlvIiwibnVtaW5hdG9yw7gxIiwiZGVub21pbmF0b3LDuDEiLCJtYXRjaEZsb2F0IiwicGFyc2VGbG9hdCIsIm1hdGNoTnVtYmVyIiwiZXNjYXBlQ2hhck1hcCIsImMiLCJyZWFkMkNoYXJzIiwicmVhZDRDaGFycyIsInVuaWNvZGUyUGF0dGVybiIsInVuaWNvZGU0UGF0dGVybiIsInZhbGlkYXRlVW5pY29kZUVzY2FwZSIsInVuaWNvZGVQYXR0ZXJuIiwiZXNjYXBlQ2hhciIsInVuaWNvZGVTdHIiLCJtYWtlVW5pY29kZUNoYXIiLCJjb2RlU3RyIiwiYmFzZSIsImJhc2XDuDIiLCJjb2Rlw7gxIiwiYnVmZmVyIiwibWFwcmVzdWx0w7gxIiwicmVhZFBhc3QiLCJwcmVkaWNhdGUiLCJfw7gxIiwicmVhZERlbGltaXRlZExpc3QiLCJkZWxpbSIsImlzUmVjdXJzaXZlIiwiZm9ybXPDuDEiLCJmb3Jtw7gxIiwicmVhZEZvcm0iLCJub3RJbXBsZW1lbnRlZCIsInJlYWREaXNwYXRjaCIsImRtw7gxIiwiZGlzcGF0Y2hNYWNyb3MiLCJvYmplY3TDuDEiLCJtYXliZVJlYWRUYWdnZWRUeXBlIiwicmVhZFVubWF0Y2hlZERlbGltaXRlciIsInJkciIsInJlYWRMaXN0IiwicmVhZENvbW1lbnQiLCJyZWFkVmVjdG9yIiwicmVhZE1hcCIsInJlYWRTZXQiLCJyZWFkTnVtYmVyIiwibWF0Y2giLCJyZWFkU3RyaW5nIiwicmVhZENoYXJhY3RlciIsInJlYWRVbnF1b3RlIiwicmVhZCIsInNwZWNpYWxTeW1ib2xzIiwidGV4dCIsIm5vdEZvdW5kIiwicmVhZFN5bWJvbCIsInRva2Vuw7gxIiwicGFydHPDuDEiLCJoYXNOc8O4MSIsIm5zw7gxIiwibmFtZcO4MSIsInJlYWRLZXl3b3JkIiwiaXNzdWXDuDEiLCJkZXN1Z2FyTWV0YSIsImZvcm0iLCJyZXN1bHQiLCJwYWlyIiwid3JhcHBpbmdSZWFkZXIiLCJwcmVmaXgiLCJ0aHJvd2luZ1JlYWRlciIsIm1zZyIsInJlYWRNZXRhIiwibWV0YWRhdGHDuDEiLCJyZWFkUmVnZXgiLCJyZWFkUGFyYW0iLCJpc1BhcmFtIiwibGFtYmRhUGFyYW1zSGFzaCIsImxhbWJkYVBhcmFtcyIsImJvZHkiLCJuYW1lc8O4MSIsInZhcmlhZGljw7gxIiwicGFyYW1zw7gxIiwibmFtZXPDuDIiLCJpw7gxIiwicmVhZExhbWJkYSIsImJvZHnDuDEiLCJyZWFkRGlzY2FyZCIsInN0YXJ0w7gxIiwicmVhZE1hY3Jvw7gxIiwiZW5kw7gxIiwibG9jYXRpb27DuDEiLCJlb2ZJc0Vycm9yIiwic2VudGluZWwiLCJyZWFkXyIsInJlYWRlcsO4MSIsImVvZsO4MSIsInJlYWRGcm9tU3RyaW5nIiwicmVhZFV1aWQiLCJ1dWlkIiwicmVhZFF1ZXVlIiwiaXRlbXMiLCJfX3RhZ1RhYmxlX18iLCJ0YWfDuDEiLCJwZm7DuDEiXSwibWFwcGluZ3MiOiI7SUFBQSxJQUFDQSxJLEdBQUQ7QUFBQSxZQUFBQyxFLEVBQUksYUFBSjtBQUFBLFlBQUFDLEcsRUFDRSxvRkFERjtBQUFBLFU7O1FBR21DQyxJQUFBLEcsY0FBQUEsSTtRQUFLQyxNQUFBLEcsY0FBQUEsTTtRQUFNQyxLQUFBLEcsY0FBQUEsSztRQUFNQyxPQUFBLEcsY0FBQUEsTztRQUFPQyxLQUFBLEcsY0FBQUEsSztRQUFNQyxNQUFBLEcsY0FBQUEsTTtRQUFPQyxLQUFBLEcsY0FBQUEsSztRQUNyQ0MsSUFBQSxHLGNBQUFBLEk7UUFBS0MsR0FBQSxHLGNBQUFBLEc7UUFBSUMsR0FBQSxHLGNBQUFBLEc7UUFBSUMsSUFBQSxHLGNBQUFBLEk7UUFBS0MsSUFBQSxHLGNBQUFBLEk7UUFBS0osSUFBQSxHLGNBQUFBLEk7UUFBS0ssTUFBQSxHLGNBQUFBLE07UUFBT0MsSUFBQSxHLGNBQUFBLEk7UUFDbkNDLE9BQUEsRyxjQUFBQSxPO1FBQVFDLElBQUEsRyxjQUFBQSxJO1FBQUtDLE9BQUEs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TUFBQSxFQUNLLHNEQURMLENBRkY7QUFBQSxDQUZGLEM7QUFPQSxJQUFnQjJILFNBQUEsR0FBaEIsU0FBZ0JBLFNBQWhCLENBQ0dDLEtBREgsRUFFRTtBQUFBLFdBQUt0SyxRQUFELENBQVNzSyxLQUFULENBQUosRyxVQUNFLEMsTUFBQSxFLE9BQUUsQyxNQUFBLEUsa0JBQUEsQyxVQUFrQkEsSyxFQUFwQixDQURGLEdBRUc1SCxXQUFELEMsTUFBQSxFQUNLLGtEQURMLENBRkY7QUFBQSxDQUZGLEM7QUFRQSxJQUFLNkgsWUFBQSxHQUFBOUksT0FBQSxDQUFBOEksWUFBQSxHQUNGNUssVUFBRCxDLE1BQUEsRUFBa0J3SyxRQUFsQixFLE9BQUEsRUFDbUJFLFNBRG5CLENBREYsQztBQUlBLElBQU03RCxtQkFBQSxHQUFBL0UsT0FBQSxDQUFBK0UsbUJBQUEsR0FBTixTQUFNQSxtQkFBTixDQUNHM0UsTUFESCxFQUNVWSxNQURWLEVBRUU7QUFBQSxlLFlBQU07QUFBQSxnQkFBQStILEssR0FBSy9DLFVBQUQsQ0FBYTVGLE1BQWIsRUFBb0JZLE1BQXBCLENBQUo7QUFBQSxZQUNBLElBQUFnSSxLLElBQVNGLFksTUFBTCxDQUFvQm5KLElBQUQsQ0FBTW9KLEtBQU4sQ0FBbkIsQ0FBSixDQURBO0FBQUEsWUFFSixPQUFJQyxLQUFKLEdBQ0dBLEtBQUQsQ0FBTXBELElBQUQsQ0FBTXhGLE1BQU4sRSxJQUFBLEUsTUFBQSxFLEtBQUEsQ0FBTCxDQURGLEdBRUdhLFdBQUQsQ0FBY2IsTUFBZCxFLEtBQ21CLGdDLEdBQ0NULElBQUQsQ0FBTW9KLEtBQU4sQyxHQUNBLE1BRkwsR0FHSyxDLEVBQUEsR0FBTTVLLElBQUQsQ0FBTTJLLFlBQU4sQ0FBTCxDQUpuQixDQUZGLENBRkk7QUFBQSxTLEtBQU4sQyxJQUFBO0FBQUEsS0FGRiIsInNvdXJjZXNDb250ZW50IjpbIihucyB3aXNwLnJlYWRlclxuICBcIlJlYWRlciBtb2R1bGUgcHJvdmlkZXMgZnVuY3Rpb25zIGZvciByZWFkaW5nIHRleHQgaW5wdXRcbiAgYXMgd2lzcCBkYXRhIHN0cnVjdHVyZXNcIlxuICAoOnJlcXVpcmUgW3dpc3Auc2VxdWVuY2UgOnJlZmVyIFtsaXN0IGxpc3Q/IGNvdW50IGVtcHR5PyBmaXJzdCBzZWNvbmQgdGhpcmRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdCBtYXAgdmVjIGNvbnMgY29uaiByZXN0IGNvbmNhdCBsYXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dGxhc3Qgc29ydCBsYXp5LXNlcSByZWR1Y2VdXVxuICAgICAgICAgICAgW3dpc3AucnVudGltZSA6cmVmZXIgW29kZD8gZGljdGlvbmFyeSBrZXlzIG5pbD8gaW5jIGRlYyB2ZWN0b3I/IHN0cmluZz9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1iZXI/IGJvb2xlYW4/IG9iamVjdD8gZGljdGlvbmFyeT8gcmUtcGF0dGVyblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlLW1hdGNoZXMgcmUtZmluZCBzdHIgc3VicyBjaGFyIHZhbHMgPV1dXG4gICAgICAgICAgICBbd2lzcC5hc3QgOnJlZmVyIFtzeW1ib2w/IHN5bWJvbCBrZXl3b3JkPyBrZXl3b3JkIG1ldGEgd2l0aC1tZXRhIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbnN5bV1dXG4gICAgICAgICAgICBbd2lzcC5zdHJpbmcgOnJlZmVyIFtzcGxpdCBqb2luXV0pKVxuXG4oZGVmbiBwdXNoLWJhY2stcmVhZGVyXG4gIFwiQ3JlYXRlcyBhIFN0cmluZ1B1c2hiYWNrUmVhZGVyIGZyb20gYSBnaXZlbiBzdHJpbmdcIlxuICBbc291cmNlIHVyaV1cbiAgezpsaW5lcyAoc3BsaXQgc291cmNlIFwiXFxuXCIpIDpidWZmZXIgXCJcIlxuICAgOnVyaSB1cmlcbiAgIDpjb2x1bW4gLTEgOmxpbmUgMH0pXG5cbihkZWZuIHBlZWstY2hhclxuICBcIlJldHVybnMgbmV4dCBjaGFyIGZyb20gdGhlIFJlYWRlciB3aXRob3V0IHJlYWRpbmcgaXQuXG4gIG5pbCBpZiB0aGUgZW5kIG9mIHN0cmVhbSBoYXMgYmVpbmcgcmVhY2hlZC5cIlxuICBbcmVhZGVyXVxuICAobGV0IFtsaW5lIChhZ2V0ICg6bGluZXMgcmVhZGVyKVxuICAgICAgICAgICAgICAgICAgICg6bGluZSByZWFkZXIpKVxuICAgICAgICBjb2x1bW4gKGluYyAoOmNvbHVtbiByZWFkZXIpKV1cbiAgICAoaWYgKG5pbD8gbGluZSlcbiAgICAgIG5pbFxuICAgICAgKG9yIChhZ2V0IGxpbmUgY29sdW1uKSBcIlxcblwiKSkpKVxuXG4oZGVmbiByZWFkLWNoYXJcbiAgXCJSZXR1cm5zIHRoZSBuZXh0IGNoYXIgZnJvbSB0aGUgUmVhZGVyLCBuaWwgaWYgdGhlIGVuZFxuICBvZiBzdHJlYW0gaGFzIGJlZW4gcmVhY2hlZFwiXG4gIFtyZWFkZXJdXG4gIChsZXQgW2NoIChwZWVrLWNoYXIgcmVhZGVyKV1cbiAgICA7OyBVcGRhdGUgbGluZSBjb2x1bW4gZGVwZW5kaW5nIG9uIHdoYXQgaGFzIGJlaW5nIHJlYWQuXG4gICAgKGlmIChuZXdsaW5lPyAocGVlay1jaGFyIHJlYWRlcikpXG4gICAgICAoZG9cbiAgICAgICAgKHNldCEgKDpsaW5lIHJlYWRlcikgKGluYyAoOmxpbmUgcmVhZGVyKSkpXG4gICAgICAgIChzZXQhICg6Y29sdW1uIHJlYWRlcikgLTEpKVxuICAgICAgKHNldCEgKDpjb2x1bW4gcmVhZGVyKSAoaW5jICg6Y29sdW1uIHJlYWRlcikpKSlcbiAgICBjaCkpXG5cbjs7IFByZWRpY2F0ZXNcblxuKGRlZm4gXmJvb2xlYW4gbmV3bGluZT9cbiAgXCJDaGVja3Mgd2hldGhlciB0aGUgY2hhcmFjdGVyIGlzIGEgbmV3bGluZS5cIlxuICBbY2hdXG4gIChpZGVudGljYWw/IFwiXFxuXCIgY2gpKVxuXG4oZGVmbiBeYm9vbGVhbiBicmVha2luZy13aGl0ZXNwYWNlP1xuIFwiQ2hlY2tzIGlmIGEgc3RyaW5nIGlzIGFsbCBicmVha2luZyB3aGl0ZXNwYWNlLlwiXG4gW2NoXVxuIChvciAoaWRlbnRpY2FsPyBjaCBcIiBcIilcbiAgICAgKGlkZW50aWNhbD8gY2ggXCJcXHRcIilcbiAgICAgKGlkZW50aWNhbD8gY2ggXCJcXG5cIilcbiAgICAgKGlkZW50aWNhbD8gY2ggXCJcXHJcIikpKVxuXG4oZGVmbiBeYm9vbGVhbiB3aGl0ZXNwYWNlP1xuICBcIkNoZWNrcyB3aGV0aGVyIGEgZ2l2ZW4gY2hhcmFjdGVyIGlzIHdoaXRlc3BhY2VcIlxuICBbY2hdXG4gIChvciAoYnJlYWtpbmctd2hpdGVzcGFjZT8gY2gpIChpZGVudGljYWw/IFwiLFwiIGNoKSkpXG5cbihkZWZuIF5ib29sZWFuIG51bWVyaWM/XG4gXCJDaGVja3Mgd2hldGhlciBhIGdpdmVuIGNoYXJhY3RlciBpcyBudW1lcmljXCJcbiBbY2hdXG4gKG9yIChpZGVudGljYWw/IGNoIFxcMClcbiAgICAgKGlkZW50aWNhbD8gY2ggXFwxKVxuICAgICAoaWRlbnRpY2FsPyBjaCBcXDIpXG4gICAgIChpZGVudGljYWw/IGNoIFxcMylcbiAgICAgKGlkZW50aWNhbD8gY2ggXFw0KVxuICAgICAoaWRlbnRpY2FsPyBjaCBcXDUpXG4gICAgIChpZGVudGljYWw/IGNoIFxcNilcbiAgICAgKGlkZW50aWNhbD8gY2ggXFw3KVxuICAgICAoaWRlbnRpY2FsPyBjaCBcXDgpXG4gICAgIChpZGVudGljYWw/IGNoIFxcOSkpKVxuXG4oZGVmbiBeYm9vbGVhbiBjb21tZW50LXByZWZpeD9cbiAgXCJDaGVja3Mgd2hldGhlciB0aGUgY2hhcmFjdGVyIGJlZ2lucyBhIGNvbW1lbnQuXCJcbiAgW2NoXVxuICAoaWRlbnRpY2FsPyBcIjtcIiBjaCkpXG5cblxuKGRlZm4gXmJvb2xlYW4gbnVtYmVyLWxpdGVyYWw/XG4gIFwiQ2hlY2tzIHdoZXRoZXIgdGhlIHJlYWRlciBpcyBhdCB0aGUgc3RhcnQgb2YgYSBudW1iZXIgbGl0ZXJhbFwiXG4gIFtyZWFkZXIgaW5pdGNoXVxuICAob3IgKG51bWVyaWM/IGluaXRjaClcbiAgICAgIChhbmQgKG9yIChpZGVudGljYWw/IFxcKyBpbml0Y2gpXG4gICAgICAgICAgICAgICAoaWRlbnRpY2FsPyBcXC0gaW5pdGNoKSlcbiAgICAgICAgICAgKG51bWVyaWM/IChwZWVrLWNoYXIgcmVhZGVyKSkpKSlcblxuXG5cbjs7IHJlYWQgaGVscGVyc1xuXG4oZGVmbiByZWFkZXItZXJyb3JcbiAgW3JlYWRlciBtZXNzYWdlXVxuICAobGV0IFt0ZXh0IChzdHIgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgXCJcXG5cIiBcImxpbmU6XCIgKDpsaW5lIHJlYWRlcilcbiAgICAgICAgICAgICAgICAgIFwiXFxuXCIgXCJjb2x1bW46XCIgKDpjb2x1bW4gcmVhZGVyKSlcbiAgICAgICAgZXJyb3IgKFN5bnRheEVycm9yIHRleHQgKDp1cmkgcmVhZGVyKSldXG4gICAgKHNldCEgZXJyb3IubGluZSAoOmxpbmUgcmVhZGVyKSlcbiAgICAoc2V0ISBlcnJvci5jb2x1bW4gKDpjb2x1bW4gcmVhZGVyKSlcbiAgICAoc2V0ISBlcnJvci51cmkgKDp1cmkgcmVhZGVyKSlcbiAgICAodGhyb3cgZXJyb3IpKSlcblxuKGRlZm4gXmJvb2xlYW4gbWFjcm8tdGVybWluYXRpbmc/IFtjaF1cbiAgKGFuZCAobm90IChpZGVudGljYWw/IGNoIFwiI1wiKSlcbiAgICAgICAobm90IChpZGVudGljYWw/IGNoIFwiJ1wiKSlcbiAgICAgICAobm90IChpZGVudGljYWw/IGNoIFwiOlwiKSlcbiAgICAgICAobWFjcm9zIGNoKSkpXG5cblxuKGRlZm4gcmVhZC10b2tlblxuICBcIlJlYWRzIG91dCBuZXh0IHRva2VuIGZyb20gdGhlIHJlYWRlciBzdHJlYW1cIlxuICBbcmVhZGVyIGluaXRjaF1cbiAgKGxvb3AgW2J1ZmZlciBpbml0Y2hcbiAgICAgICAgIGNoIChwZWVrLWNoYXIgcmVhZGVyKV1cblxuICAgIChpZiAob3IgKG5pbD8gY2gpXG4gICAgICAgICAgICAod2hpdGVzcGFjZT8gY2gpXG4gICAgICAgICAgICAobWFjcm8tdGVybWluYXRpbmc/IGNoKSkgYnVmZmVyXG4gICAgICAgIChyZWN1ciAoc3RyIGJ1ZmZlciAocmVhZC1jaGFyIHJlYWRlcikpXG4gICAgICAgICAgICAgICAocGVlay1jaGFyIHJlYWRlcikpKSkpXG5cbihkZWZuIHNraXAtbGluZVxuICBcIkFkdmFuY2VzIHRoZSByZWFkZXIgdG8gdGhlIGVuZCBvZiBhIGxpbmUuIFJldHVybnMgdGhlIHJlYWRlclwiXG4gIFtyZWFkZXIgX11cbiAgKGxvb3AgW11cbiAgICAobGV0IFtjaCAocmVhZC1jaGFyIHJlYWRlcildXG4gICAgICAoaWYgKG9yIChpZGVudGljYWw/IGNoIFwiXFxuXCIpXG4gICAgICAgICAgICAgIChpZGVudGljYWw/IGNoIFwiXFxyXCIpXG4gICAgICAgICAgICAgIChuaWw/IGNoKSlcbiAgICAgICAgcmVhZGVyXG4gICAgICAgIChyZWN1cikpKSkpXG5cblxuOzsgTm90ZTogSW5wdXQgYmVnaW4gYW5kIGVuZCBtYXRjaGVycyBhcmUgdXNlZCBpbiBhIHBhdHRlcm4gc2luY2Ugb3RoZXJ3aXNlXG47OyBhbnl0aGluZyBiZWdpbmlubmcgd2l0aCBgMGAgd2lsbCBtYXRjaCBqdXN0IGAwYCBjYXVzZSBpdCdzIGxpc3RlZCBmaXJzdC5cbihkZWYgaW50LXBhdHRlcm4gKHJlLXBhdHRlcm4gXCJeKFstK10/KSg/OigwKXwoWzEtOV1bMC05XSopfDBbeFhdKFswLTlBLUZhLWZdKyl8MChbMC03XSspfChbMS05XVswLTldPylbclJdKFswLTlBLVphLXpdKyl8MFswLTldKykoTik/JFwiKSlcbihkZWYgcmF0aW8tcGF0dGVybiAocmUtcGF0dGVybiBcIihbLStdP1swLTldKykvKFswLTldKylcIikpXG4oZGVmIGZsb2F0LXBhdHRlcm4gKHJlLXBhdHRlcm4gXCIoWy0rXT9bMC05XSsoXFxcXC5bMC05XSopPyhbZUVdWy0rXT9bMC05XSspPykoTSk/XCIpKVxuXG4oZGVmbiBtYXRjaC1pbnRcbiAgW3NdXG4gIChsZXQgW2dyb3VwcyAocmUtZmluZCBpbnQtcGF0dGVybiBzKVxuICAgICAgICBncm91cDMgKGFnZXQgZ3JvdXBzIDIpXVxuICAgIChpZiAobm90IChvciAobmlsPyBncm91cDMpXG4gICAgICAgICAgICAgICAgICg8IChjb3VudCBncm91cDMpIDEpKSlcbiAgICAgIDBcbiAgICAgIChsZXQgW25lZ2F0ZSAoaWYgKGlkZW50aWNhbD8gXCItXCIgKGFnZXQgZ3JvdXBzIDEpKSAtMSAxKVxuICAgICAgICAgICAgYSAoY29uZFxuICAgICAgICAgICAgICAgKGFnZXQgZ3JvdXBzIDMpIFsoYWdldCBncm91cHMgMykgMTBdXG4gICAgICAgICAgICAgICAoYWdldCBncm91cHMgNCkgWyhhZ2V0IGdyb3VwcyA0KSAxNl1cbiAgICAgICAgICAgICAgIChhZ2V0IGdyb3VwcyA1KSBbKGFnZXQgZ3JvdXBzIDUpIDhdXG4gICAgICAgICAgICAgICAoYWdldCBncm91cHMgNykgWyhhZ2V0IGdyb3VwcyA3KSAocGFyc2UtaW50IChhZ2V0IGdyb3VwcyA3KSldXG4gICAgICAgICAgICAgICA6ZWxzZSBbbmlsIG5pbF0pXG4gICAgICAgICAgICBuIChhZ2V0IGEgMClcbiAgICAgICAgICAgIHJhZGl4IChhZ2V0IGEgMSldXG4gICAgICAgIChpZiAobmlsPyBuKVxuICAgICAgICAgIG5pbFxuICAgICAgICAgICgqIG5lZ2F0ZSAocGFyc2UtaW50IG4gcmFkaXgpKSkpKSkpXG5cbihkZWZuIG1hdGNoLXJhdGlvXG4gIFtzXVxuICAobGV0IFtncm91cHMgKHJlLWZpbmQgcmF0aW8tcGF0dGVybiBzKVxuICAgICAgICBudW1pbmF0b3IgKGFnZXQgZ3JvdXBzIDEpXG4gICAgICAgIGRlbm9taW5hdG9yIChhZ2V0IGdyb3VwcyAyKV1cbiAgICAoLyAocGFyc2UtaW50IG51bWluYXRvcikgKHBhcnNlLWludCBkZW5vbWluYXRvcikpKSlcblxuKGRlZm4gbWF0Y2gtZmxvYXRcbiAgW3NdXG4gIChwYXJzZS1mbG9hdCBzKSlcblxuXG4oZGVmbiBtYXRjaC1udW1iZXJcbiAgW3NdXG4gIChjb25kXG4gICAocmUtbWF0Y2hlcyBpbnQtcGF0dGVybiBzKSAobWF0Y2gtaW50IHMpXG4gICAocmUtbWF0Y2hlcyByYXRpby1wYXR0ZXJuIHMpIChtYXRjaC1yYXRpbyBzKVxuICAgKHJlLW1hdGNoZXMgZmxvYXQtcGF0dGVybiBzKSAobWF0Y2gtZmxvYXQgcykpKVxuXG4oZGVmbiBlc2NhcGUtY2hhci1tYXAgW2NdXG4gIChjb25kXG4gICAoaWRlbnRpY2FsPyBjIFxcdCkgXCJcXHRcIlxuICAgKGlkZW50aWNhbD8gYyBcXHIpIFwiXFxyXCJcbiAgIChpZGVudGljYWw/IGMgXFxuKSBcIlxcblwiXG4gICAoaWRlbnRpY2FsPyBjIFxcXFwpIFxcXFxcbiAgIChpZGVudGljYWw/IGMgXCJcXFwiXCIpIFwiXFxcIlwiXG4gICAoaWRlbnRpY2FsPyBjIFxcYikgXCJcXGJcIlxuICAgKGlkZW50aWNhbD8gYyBcXGYpIFwiXFxmXCJcbiAgIDplbHNlIG5pbCkpXG5cbjs7IHVuaWNvZGVcblxuKGRlZm4gcmVhZC0yLWNoYXJzIFtyZWFkZXJdXG4gIChzdHIgKHJlYWQtY2hhciByZWFkZXIpXG4gICAgICAgKHJlYWQtY2hhciByZWFkZXIpKSlcblxuKGRlZm4gcmVhZC00LWNoYXJzIFtyZWFkZXJdXG4gIChzdHIgKHJlYWQtY2hhciByZWFkZXIpXG4gICAgICAgKHJlYWQtY2hhciByZWFkZXIpXG4gICAgICAgKHJlYWQtY2hhciByZWFkZXIpXG4gICAgICAgKHJlYWQtY2hhciByZWFkZXIpKSlcblxuKGRlZiB1bmljb2RlLTItcGF0dGVybiAocmUtcGF0dGVybiBcIlswLTlBLUZhLWZdezJ9XCIpKVxuKGRlZiB1bmljb2RlLTQtcGF0dGVybiAocmUtcGF0dGVybiBcIlswLTlBLUZhLWZdezR9XCIpKVxuXG5cbihkZWZuIHZhbGlkYXRlLXVuaWNvZGUtZXNjYXBlXG4gIFwiVmFsaWRhdGVzIHVuaWNvZGUgZXNjYXBlXCJcbiAgW3VuaWNvZGUtcGF0dGVybiByZWFkZXIgZXNjYXBlLWNoYXIgdW5pY29kZS1zdHJdXG4gIChpZiAocmUtbWF0Y2hlcyB1bmljb2RlLXBhdHRlcm4gdW5pY29kZS1zdHIpXG4gICAgdW5pY29kZS1zdHJcbiAgICAocmVhZGVyLWVycm9yXG4gICAgIHJlYWRlclxuICAgICAoc3RyIFwiVW5leHBlY3RlZCB1bmljb2RlIGVzY2FwZSBcIiBcXFxcIGVzY2FwZS1jaGFyIHVuaWNvZGUtc3RyKSkpKVxuXG5cbihkZWZuIG1ha2UtdW5pY29kZS1jaGFyXG4gIFtjb2RlLXN0ciBiYXNlXVxuICAobGV0IFtiYXNlIChvciBiYXNlIDE2KVxuICAgICAgICBjb2RlIChwYXJzZUludCBjb2RlLXN0ciBiYXNlKV1cbiAgICAoY2hhciBjb2RlKSkpXG5cbihkZWZuIGVzY2FwZS1jaGFyXG4gIFwiZXNjYXBlIGNoYXJcIlxuICBbYnVmZmVyIHJlYWRlcl1cbiAgKGxldCBbY2ggKHJlYWQtY2hhciByZWFkZXIpXG4gICAgICAgIG1hcHJlc3VsdCAoZXNjYXBlLWNoYXItbWFwIGNoKV1cbiAgICAoaWYgbWFwcmVzdWx0XG4gICAgICBtYXByZXN1bHRcbiAgICAgIChjb25kXG4gICAgICAgIChpZGVudGljYWw/IGNoIFxceCkgKG1ha2UtdW5pY29kZS1jaGFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHZhbGlkYXRlLXVuaWNvZGUtZXNjYXBlIHVuaWNvZGUtMi1wYXR0ZXJuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocmVhZC0yLWNoYXJzIHJlYWRlcikpKVxuICAgICAgICAoaWRlbnRpY2FsPyBjaCBcXHUpIChtYWtlLXVuaWNvZGUtY2hhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh2YWxpZGF0ZS11bmljb2RlLWVzY2FwZSB1bmljb2RlLTQtcGF0dGVyblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHJlYWQtNC1jaGFycyByZWFkZXIpKSlcbiAgICAgICAgKG51bWVyaWM/IGNoKSAoY2hhciBjaClcbiAgICAgICAgOmVsc2UgKHJlYWRlci1lcnJvciByZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc3RyIFwiVW5leHBlY3RlZCB1bmljb2RlIGVzY2FwZSBcIiBcXFxcIGNoICkpKSkpKVxuXG4oZGVmbiByZWFkLXBhc3RcbiAgXCJSZWFkIHVudGlsIGZpcnN0IGNoYXJhY3RlciB0aGF0IGRvZXNuJ3QgbWF0Y2ggcHJlZCwgcmV0dXJuaW5nXG4gIGNoYXIuXCJcbiAgW3ByZWRpY2F0ZSByZWFkZXJdXG4gIChsb29wIFtfIG5pbF1cbiAgICAoaWYgKHByZWRpY2F0ZSAocGVlay1jaGFyIHJlYWRlcikpXG4gICAgICAocmVjdXIgKHJlYWQtY2hhciByZWFkZXIpKVxuICAgICAgKHBlZWstY2hhciByZWFkZXIpKSkpXG5cblxuOzsgVE9ETzogQ29tcGxldGUgaW1wbGVtZW50YXRpb25cbihkZWZuIHJlYWQtZGVsaW1pdGVkLWxpc3RcbiAgXCJSZWFkcyBvdXQgZGVsaW1pdGVkIGxpc3RcIlxuICBbZGVsaW0gcmVhZGVyIHJlY3Vyc2l2ZT9dXG4gIChsb29wIFtmb3JtcyBbXV1cbiAgICAobGV0IFtfIChyZWFkLXBhc3Qgd2hpdGVzcGFjZT8gcmVhZGVyKVxuICAgICAgICAgIGNoIChyZWFkLWNoYXIgcmVhZGVyKV1cbiAgICAgIChpZiAobm90IGNoKSAocmVhZGVyLWVycm9yIHJlYWRlciA6RU9GKSlcbiAgICAgIChpZiAoaWRlbnRpY2FsPyBkZWxpbSBjaClcbiAgICAgICAgZm9ybXNcbiAgICAgICAgKGxldCBbZm9ybSAocmVhZC1mb3JtIHJlYWRlciBjaCldXG4gICAgICAgICAgKHJlY3VyIChpZiAoaWRlbnRpY2FsPyBmb3JtIHJlYWRlcilcbiAgICAgICAgICAgICAgICAgICBmb3Jtc1xuICAgICAgICAgICAgICAgICAgIChjb25qIGZvcm1zIGZvcm0pKSkpKSkpKVxuXG47OyBkYXRhIHN0cnVjdHVyZSByZWFkZXJzXG5cbihkZWZuIG5vdC1pbXBsZW1lbnRlZFxuICBbcmVhZGVyIGNoXVxuICAocmVhZGVyLWVycm9yIHJlYWRlciAoc3RyIFwiUmVhZGVyIGZvciBcIiBjaCBcIiBub3QgaW1wbGVtZW50ZWQgeWV0XCIpKSlcblxuXG4oZGVmbiByZWFkLWRpc3BhdGNoXG4gIFtyZWFkZXIgX11cbiAgKGxldCBbY2ggKHJlYWQtY2hhciByZWFkZXIpXG4gICAgICAgIGRtIChkaXNwYXRjaC1tYWNyb3MgY2gpXVxuICAgIChpZiBkbVxuICAgICAgKGRtIHJlYWRlciBfKVxuICAgICAgKGxldCBbb2JqZWN0IChtYXliZS1yZWFkLXRhZ2dlZC10eXBlIHJlYWRlciBjaCldXG4gICAgICAgIChpZiBvYmplY3RcbiAgICAgICAgICBvYmplY3RcbiAgICAgICAgICAocmVhZGVyLWVycm9yIHJlYWRlciBcIk5vIGRpc3BhdGNoIG1hY3JvIGZvciBcIiBjaCkpKSkpKVxuXG4oZGVmbiByZWFkLXVubWF0Y2hlZC1kZWxpbWl0ZXJcbiAgW3JkciBjaF1cbiAgKHJlYWRlci1lcnJvciByZHIgXCJVbm1hdGNoZWQgZGVsaW1pdGVyIFwiIGNoKSlcblxuKGRlZm4gcmVhZC1saXN0XG4gIFtyZWFkZXIgX11cbiAgKGxldCBbZm9ybSAocmVhZC1kZWxpbWl0ZWQtbGlzdCBcIilcIiByZWFkZXIgdHJ1ZSldXG4gICAgKHdpdGgtbWV0YSAoYXBwbHkgbGlzdCBmb3JtKSAobWV0YSBmb3JtKSkpKVxuXG4oZGVmbiByZWFkLWNvbW1lbnRcbiAgW3JlYWRlciBfXVxuICAobG9vcCBbYnVmZmVyIFwiXCJcbiAgICAgICAgIGNoIChyZWFkLWNoYXIgcmVhZGVyKV1cblxuICAgIChjb25kXG4gICAgIChvciAobmlsPyBjaClcbiAgICAgICAgIChpZGVudGljYWw/IFwiXFxuXCIgY2gpKSAob3IgcmVhZGVyIDs7IGlnbm9yZSBjb21tZW50cyBmb3Igbm93XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChsaXN0ICdjb21tZW50IGJ1ZmZlcikpXG4gICAgIChvciAoaWRlbnRpY2FsPyBcXFxcIGNoKSkgKHJlY3VyIChzdHIgYnVmZmVyIChlc2NhcGUtY2hhciBidWZmZXIgcmVhZGVyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChyZWFkLWNoYXIgcmVhZGVyKSlcbiAgICAgOmVsc2UgKHJlY3VyIChzdHIgYnVmZmVyIGNoKSAocmVhZC1jaGFyIHJlYWRlcikpKSkpXG5cbihkZWZuIHJlYWQtdmVjdG9yXG4gIFtyZWFkZXJdXG4gIChyZWFkLWRlbGltaXRlZC1saXN0IFwiXVwiIHJlYWRlciB0cnVlKSlcblxuKGRlZm4gcmVhZC1tYXBcbiAgW3JlYWRlcl1cbiAgKGxldCBbZm9ybSAocmVhZC1kZWxpbWl0ZWQtbGlzdCBcIn1cIiByZWFkZXIgdHJ1ZSldXG4gICAgKGlmIChvZGQ/IChjb3VudCBmb3JtKSlcbiAgICAgIChyZWFkZXItZXJyb3IgcmVhZGVyIFwiTWFwIGxpdGVyYWwgbXVzdCBjb250YWluIGFuIGV2ZW4gbnVtYmVyIG9mIGZvcm1zXCIpXG4gICAgICAod2l0aC1tZXRhIChhcHBseSBkaWN0aW9uYXJ5IGZvcm0pIChtZXRhIGZvcm0pKSkpKVxuXG4oZGVmbiByZWFkLXNldFxuICBbcmVhZGVyIF9dXG4gIChsZXQgW2Zvcm0gKHJlYWQtZGVsaW1pdGVkLWxpc3QgXCJ9XCIgcmVhZGVyIHRydWUpXVxuICAgICh3aXRoLW1ldGEgKGNvbmNhdCBbJ3NldF0gZm9ybSkgKG1ldGEgZm9ybSkpKSlcblxuKGRlZm4gcmVhZC1udW1iZXJcbiAgW3JlYWRlciBpbml0Y2hdXG4gIChsb29wIFtidWZmZXIgaW5pdGNoXG4gICAgICAgICBjaCAocGVlay1jaGFyIHJlYWRlcildXG5cbiAgICAoaWYgKG9yIChuaWw/IGNoKVxuICAgICAgICAgICAgKHdoaXRlc3BhY2U/IGNoKVxuICAgICAgICAgICAgKG1hY3JvcyBjaCkpXG4gICAgICAoZG9cbiAgICAgICAgKGRlZiBtYXRjaCAobWF0Y2gtbnVtYmVyIGJ1ZmZlcikpXG4gICAgICAgIChpZiAobmlsPyBtYXRjaClcbiAgICAgICAgICAgIChyZWFkZXItZXJyb3IgcmVhZGVyIFwiSW52YWxpZCBudW1iZXIgZm9ybWF0IFtcIiBidWZmZXIgXCJdXCIpXG4gICAgICAgICAgICAoTnVtYmVyLiBtYXRjaCkpKVxuICAgICAgKHJlY3VyIChzdHIgYnVmZmVyIChyZWFkLWNoYXIgcmVhZGVyKSlcbiAgICAgICAgICAgICAocGVlay1jaGFyIHJlYWRlcikpKSkpXG5cbihkZWZuIHJlYWQtc3RyaW5nXG4gIFtyZWFkZXJdXG4gIChsb29wIFtidWZmZXIgXCJcIlxuICAgICAgICAgY2ggKHJlYWQtY2hhciByZWFkZXIpXVxuXG4gICAgKGNvbmRcbiAgICAgKG5pbD8gY2gpIChyZWFkZXItZXJyb3IgcmVhZGVyIFwiRU9GIHdoaWxlIHJlYWRpbmcgc3RyaW5nXCIpXG4gICAgIChpZGVudGljYWw/IFxcXFwgY2gpIChyZWN1ciAoc3RyIGJ1ZmZlciAoZXNjYXBlLWNoYXIgYnVmZmVyIHJlYWRlcikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHJlYWQtY2hhciByZWFkZXIpKVxuICAgICAoaWRlbnRpY2FsPyBcIlxcXCJcIiBjaCkgKFN0cmluZy4gYnVmZmVyKVxuICAgICA6ZGVmYXVsdCAocmVjdXIgKHN0ciBidWZmZXIgY2gpIChyZWFkLWNoYXIgcmVhZGVyKSkpKSlcblxuKGRlZm4gcmVhZC1jaGFyYWN0ZXJcbiAgW3JlYWRlcl1cbiAgKFN0cmluZy4gKHJlYWQtY2hhciByZWFkZXIpKSlcblxuKGRlZm4gcmVhZC11bnF1b3RlXG4gIFwiUmVhZHMgdW5xdW90ZSBmb3JtIH5mb3JtIG9yIH4oZm9vIGJhcilcIlxuICBbcmVhZGVyXVxuICAobGV0IFtjaCAocGVlay1jaGFyIHJlYWRlcildXG4gICAgKGlmIChub3QgY2gpXG4gICAgICAocmVhZGVyLWVycm9yIHJlYWRlciBcIkVPRiB3aGlsZSByZWFkaW5nIGNoYXJhY3RlclwiKVxuICAgICAgKGlmIChpZGVudGljYWw/IGNoIFxcQClcbiAgICAgICAgKGRvIChyZWFkLWNoYXIgcmVhZGVyKVxuICAgICAgICAgICAgKGxpc3QgJ3VucXVvdGUtc3BsaWNpbmcgKHJlYWQgcmVhZGVyIHRydWUgbmlsIHRydWUpKSlcbiAgICAgICAgKGxpc3QgJ3VucXVvdGUgKHJlYWQgcmVhZGVyIHRydWUgbmlsIHRydWUpKSkpKSlcblxuXG4oZGVmbiBzcGVjaWFsLXN5bWJvbHMgW3RleHQgbm90LWZvdW5kXVxuICAoY29uZFxuICAgKGlkZW50aWNhbD8gdGV4dCBcIm5pbFwiKSBuaWxcbiAgIChpZGVudGljYWw/IHRleHQgXCJ0cnVlXCIpIHRydWVcbiAgIChpZGVudGljYWw/IHRleHQgXCJmYWxzZVwiKSBmYWxzZVxuICAgOmVsc2Ugbm90LWZvdW5kKSlcblxuXG4oZGVmbiByZWFkLXN5bWJvbFxuICBbcmVhZGVyIGluaXRjaF1cbiAgKGxldCBbdG9rZW4gKHJlYWQtdG9rZW4gcmVhZGVyIGluaXRjaClcbiAgICAgICAgcGFydHMgKHNwbGl0IHRva2VuIFwiL1wiKVxuICAgICAgICBoYXMtbnMgKGFuZCAoPiAoY291bnQgcGFydHMpIDEpXG4gICAgICAgICAgICAgICAgICAgIDs7IE1ha2Ugc3VyZSBpdCdzIG5vdCBqdXN0IGAvYFxuICAgICAgICAgICAgICAgICAgICAoPiAoY291bnQgdG9rZW4pIDEpKVxuICAgICAgICBucyAoZmlyc3QgcGFydHMpXG4gICAgICAgIG5hbWUgKGpvaW4gXCIvXCIgKHJlc3QgcGFydHMpKV1cbiAgICAoaWYgaGFzLW5zXG4gICAgICAoc3ltYm9sIG5zIG5hbWUpXG4gICAgICAoc3BlY2lhbC1zeW1ib2xzIHRva2VuIChzeW1ib2wgdG9rZW4pKSkpKVxuXG4oZGVmbiByZWFkLWtleXdvcmRcbiAgW3JlYWRlciBpbml0Y2hdXG4gIChsZXQgW3Rva2VuIChyZWFkLXRva2VuIHJlYWRlciAocmVhZC1jaGFyIHJlYWRlcikpXG4gICAgICAgIHBhcnRzIChzcGxpdCB0b2tlbiBcIi9cIilcbiAgICAgICAgbmFtZSAobGFzdCBwYXJ0cylcbiAgICAgICAgbnMgKGlmICg+IChjb3VudCBwYXJ0cykgMSkgKGpvaW4gXCIvXCIgKGJ1dGxhc3QgcGFydHMpKSlcbiAgICAgICAgaXNzdWUgKGNvbmRcbiAgICAgICAgICAgICAgIChpZGVudGljYWw/IChsYXN0IG5zKSBcXDopIFwibmFtZXNwYWNlIGNhbid0IGVuZHMgd2l0aCBcXFwiOlxcXCJcIlxuICAgICAgICAgICAgICAgKGlkZW50aWNhbD8gKGxhc3QgbmFtZSkgXFw6KSBcIm5hbWUgY2FuJ3QgZW5kIHdpdGggXFxcIjpcXFwiXCJcbiAgICAgICAgICAgICAgIChpZGVudGljYWw/IChsYXN0IG5hbWUpIFxcLykgXCJuYW1lIGNhbid0IGVuZCB3aXRoIFxcXCIvXFxcIlwiXG4gICAgICAgICAgICAgICAoPiAoY291bnQgKHNwbGl0IHRva2VuIFwiOjpcIikpIDEpIFwibmFtZSBjYW4ndCBjb250YWluIFxcXCI6OlxcXCJcIildXG4gICAgKGlmIGlzc3VlXG4gICAgICAocmVhZGVyLWVycm9yIHJlYWRlciBcIkludmFsaWQgdG9rZW4gKFwiIGlzc3VlIFwiKTogXCIgdG9rZW4pXG4gICAgICAoaWYgKGFuZCAobm90IG5zKSAoaWRlbnRpY2FsPyAoZmlyc3QgbmFtZSkgXFw6KSlcbiAgICAgICAgKGtleXdvcmQgOypucy1zeW0qXG4gICAgICAgICAgKHJlc3QgbmFtZSkpIDs7IG5hbWVzcGFjZWQga2V5d29yZCB1c2luZyBkZWZhdWx0XG4gICAgICAgIChrZXl3b3JkIG5zIG5hbWUpKSkpKVxuXG4oZGVmbiBkZXN1Z2FyLW1ldGFcbiAgW2Zvcm1dXG4gIDs7IGtleXdvcmQgc2hvdWxkIGdvIGJlZm9yZSBzdHJpbmcgc2luY2UgaXQgaXMgYSBzdHJpbmcuXG4gIChjb25kIChrZXl3b3JkPyBmb3JtKSAoZGljdGlvbmFyeSAobmFtZSBmb3JtKSB0cnVlKVxuICAgICAgICAoc3ltYm9sPyBmb3JtKSB7OnRhZyBmb3JtfVxuICAgICAgICAoc3RyaW5nPyBmb3JtKSB7OnRhZyBmb3JtfVxuICAgICAgICAoZGljdGlvbmFyeT8gZm9ybSkgKHJlZHVjZSAoZm4gW3Jlc3VsdCBwYWlyXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzZXQhIChnZXQgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobmFtZSAoZmlyc3QgcGFpcikpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChzZWNvbmQgcGFpcikpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtKVxuICAgICAgICA6ZWxzZSBmb3JtKSlcblxuKGRlZm4gd3JhcHBpbmctcmVhZGVyXG4gIFtwcmVmaXhdXG4gIChmbiBbcmVhZGVyXVxuICAgIChsaXN0IHByZWZpeCAocmVhZCByZWFkZXIgdHJ1ZSBuaWwgdHJ1ZSkpKSlcblxuKGRlZm4gdGhyb3dpbmctcmVhZGVyXG4gIFttc2ddXG4gIChmbiBbcmVhZGVyXVxuICAgIChyZWFkZXItZXJyb3IgcmVhZGVyIG1zZykpKVxuXG4oZGVmbiByZWFkLW1ldGFcbiAgW3JlYWRlciBfXVxuICAobGV0IFttZXRhZGF0YSAoZGVzdWdhci1tZXRhIChyZWFkIHJlYWRlciB0cnVlIG5pbCB0cnVlKSldXG4gICAgKGlmIChub3QgKGRpY3Rpb25hcnk/IG1ldGFkYXRhKSlcbiAgICAgIChyZWFkZXItZXJyb3IgcmVhZGVyIFwiTWV0YWRhdGEgbXVzdCBiZSBTeW1ib2wsIEtleXdvcmQsIFN0cmluZyBvciBNYXBcIikpXG4gICAgKGxldCBbZm9ybSAocmVhZCByZWFkZXIgdHJ1ZSBuaWwgdHJ1ZSldXG4gICAgICAoaWYgKG9iamVjdD8gZm9ybSlcbiAgICAgICAgKHdpdGgtbWV0YSBmb3JtIChjb25qIG1ldGFkYXRhIChtZXRhIGZvcm0pKSlcbiAgICAgICAgOyhyZWFkZXItZXJyb3JcbiAgICAgICAgOyByZWFkZXIgXCJNZXRhZGF0YSBjYW4gb25seSBiZSBhcHBsaWVkIHRvIElXaXRoTWV0YXNcIilcblxuICAgICAgICBmb3JtIDsgRm9yIG5vdyB3ZSBkb24ndCB0aHJvdyBlcnJvcnMgYXMgd2UgY2FuJ3QgYXBwbHkgbWV0YWRhdGEgdG9cbiAgICAgICAgICAgICA7IHN5bWJvbHMsIHNvIHdlIGp1c3QgaWdub3JlIGl0LlxuICAgICAgICApKSkpXG5cbihkZWZuIHJlYWQtcmVnZXhcbiAgW3JlYWRlcl1cbiAgKGxvb3AgW2J1ZmZlciBcIlwiXG4gICAgICAgICBjaCAocmVhZC1jaGFyIHJlYWRlcildXG5cbiAgICAoY29uZFxuICAgICAobmlsPyBjaCkgKHJlYWRlci1lcnJvciByZWFkZXIgXCJFT0Ygd2hpbGUgcmVhZGluZyBzdHJpbmdcIilcbiAgICAgKGlkZW50aWNhbD8gXFxcXCBjaCkgKHJlY3VyIChzdHIgYnVmZmVyIGNoIChyZWFkLWNoYXIgcmVhZGVyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocmVhZC1jaGFyIHJlYWRlcikpXG4gICAgIChpZGVudGljYWw/IFwiXFxcIlwiIGNoKSAocmUtcGF0dGVybiBidWZmZXIpXG4gICAgIDpkZWZhdWx0IChyZWN1ciAoc3RyIGJ1ZmZlciBjaCkgKHJlYWQtY2hhciByZWFkZXIpKSkpKVxuXG4oZGVmbiByZWFkLXBhcmFtXG4gIFtyZWFkZXIgaW5pdGNoXVxuICAobGV0IFtmb3JtIChyZWFkLXN5bWJvbCByZWFkZXIgaW5pdGNoKV1cbiAgICAoaWYgKD0gZm9ybSAoc3ltYm9sIFwiJVwiKSkgKHN5bWJvbCBcIiUxXCIpIGZvcm0pKSlcblxuKGRlZm4gcGFyYW0/IFtmb3JtXVxuICAoYW5kIChzeW1ib2w/IGZvcm0pIChpZGVudGljYWw/IFxcJSAoZmlyc3QgKG5hbWUgZm9ybSkpKSkpXG5cbihkZWZuIGxhbWJkYS1wYXJhbXMtaGFzaCBbZm9ybV1cbiAgKGNvbmQgKHBhcmFtPyBmb3JtKSAoZGljdGlvbmFyeSBmb3JtIGZvcm0pXG4gICAgICAgIChvciAoZGljdGlvbmFyeT8gZm9ybSlcbiAgICAgICAgICAgICh2ZWN0b3I/IGZvcm0pXG4gICAgICAgICAgICAobGlzdD8gZm9ybSkpIChhcHBseSBjb25qXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAobWFwIGxhbWJkYS1wYXJhbXMtaGFzaCAodmVjIGZvcm0pKSlcbiAgICAgICAgOmVsc2Uge30pKVxuXG4oZGVmbiBsYW1iZGEtcGFyYW1zIFtib2R5XVxuICAobGV0IFtuYW1lcyAoc29ydCAodmFscyAobGFtYmRhLXBhcmFtcy1oYXNoIGJvZHkpKSlcbiAgICAgICAgdmFyaWFkaWMgKD0gKGZpcnN0IG5hbWVzKSAoc3ltYm9sIFwiJSZcIikpXG4gICAgICAgIG4gKGNvbmQgKGFuZCB2YXJpYWRpYyAoaWRlbnRpY2FsPyAoY291bnQgbmFtZXMpIDEpKSAwXG4gICAgICAgICAgICAgICAgKGlkZW50aWNhbD8gKGNvdW50IG5hbWVzKSAwKSAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgOmVsc2UgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAocGFyc2VJbnQgKHJlc3QgKG5hbWUgKGxhc3QgbmFtZXMpKSkpKVxuICAgICAgICBwYXJhbXMgKGxvb3AgW25hbWVzIFtdXG4gICAgICAgICAgICAgICAgICAgICAgaSAxXVxuICAgICAgICAgICAgICAgIChpZiAoPD0gaSBuKVxuICAgICAgICAgICAgICAgICAgKHJlY3VyIChjb25qIG5hbWVzIChzeW1ib2wgKHN0ciBcIiVcIiBpKSkpIChpbmMgaSkpXG4gICAgICAgICAgICAgICAgICBuYW1lcykpXVxuICAgIChpZiB2YXJpYWRpYyAoY29uaiBwYXJhbXMgJyYgJyUmKSBuYW1lcykpKVxuXG4oZGVmbiByZWFkLWxhbWJkYVxuICBbcmVhZGVyXVxuICAgKGxldCBbYm9keSAocmVhZC1saXN0IHJlYWRlcildXG4gICAgKGxpc3QgJ2ZuIChsYW1iZGEtcGFyYW1zIGJvZHkpIGJvZHkpKSlcblxuKGRlZm4gcmVhZC1kaXNjYXJkXG4gIFwiRGlzY2FyZHMgbmV4dCBmb3JtXCJcbiAgW3JlYWRlciBfXVxuICAocmVhZCByZWFkZXIgdHJ1ZSBuaWwgdHJ1ZSlcbiAgcmVhZGVyKVxuXG4oZGVmbiBtYWNyb3MgW2NdXG4gIChjb25kXG4gICAoaWRlbnRpY2FsPyBjIFwiXFxcIlwiKSByZWFkLXN0cmluZ1xuICAgKGlkZW50aWNhbD8gYyBcXFxcKSByZWFkLWNoYXJhY3RlclxuICAgKGlkZW50aWNhbD8gYyBcXDopIHJlYWQta2V5d29yZFxuICAgKGlkZW50aWNhbD8gYyBcIjtcIikgcmVhZC1jb21tZW50XG4gICAoaWRlbnRpY2FsPyBjIFxcJykgKHdyYXBwaW5nLXJlYWRlciAncXVvdGUpXG4gICAoaWRlbnRpY2FsPyBjIFxcQCkgKHdyYXBwaW5nLXJlYWRlciAnZGVyZWYpXG4gICAoaWRlbnRpY2FsPyBjIFxcXikgcmVhZC1tZXRhXG4gICAoaWRlbnRpY2FsPyBjIFxcYCkgKHdyYXBwaW5nLXJlYWRlciAnc3ludGF4LXF1b3RlKVxuICAgKGlkZW50aWNhbD8gYyBcXH4pIHJlYWQtdW5xdW90ZVxuICAgKGlkZW50aWNhbD8gYyBcXCgpIHJlYWQtbGlzdFxuICAgKGlkZW50aWNhbD8gYyBcXCkpIHJlYWQtdW5tYXRjaGVkLWRlbGltaXRlclxuICAgKGlkZW50aWNhbD8gYyBcXFspIHJlYWQtdmVjdG9yXG4gICAoaWRlbnRpY2FsPyBjIFxcXSkgcmVhZC11bm1hdGNoZWQtZGVsaW1pdGVyXG4gICAoaWRlbnRpY2FsPyBjIFxceykgcmVhZC1tYXBcbiAgIChpZGVudGljYWw/IGMgXFx9KSByZWFkLXVubWF0Y2hlZC1kZWxpbWl0ZXJcbiAgIChpZGVudGljYWw/IGMgXFwlKSByZWFkLXBhcmFtXG4gICAoaWRlbnRpY2FsPyBjIFxcIykgcmVhZC1kaXNwYXRjaFxuICAgOmVsc2UgbmlsKSlcblxuXG4oZGVmbiBkaXNwYXRjaC1tYWNyb3MgW3NdXG4gIChjb25kXG4gICAoaWRlbnRpY2FsPyBzIFxceykgcmVhZC1zZXRcbiAgIChpZGVudGljYWw/IHMgXFwoKSByZWFkLWxhbWJkYVxuICAgKGlkZW50aWNhbD8gcyBcXDwpICh0aHJvd2luZy1yZWFkZXIgXCJVbnJlYWRhYmxlIGZvcm1cIilcbiAgIChpZGVudGljYWw/IHMgXCJcXFwiXCIpIHJlYWQtcmVnZXhcbiAgIChpZGVudGljYWw/IHMgXFwhKSByZWFkLWNvbW1lbnRcbiAgIChpZGVudGljYWw/IHMgXFxfKSByZWFkLWRpc2NhcmRcbiAgIDplbHNlIG5pbCkpXG5cbihkZWZuIHJlYWQtZm9ybVxuICBbcmVhZGVyIGNoXVxuICAobGV0IFtzdGFydCB7OmxpbmUgKDpsaW5lIHJlYWRlcilcbiAgICAgICAgICAgICAgIDpjb2x1bW4gKDpjb2x1bW4gcmVhZGVyKX1cbiAgICAgICAgcmVhZC1tYWNybyAobWFjcm9zIGNoKVxuICAgICAgICBmb3JtIChjb25kIHJlYWQtbWFjcm8gKHJlYWQtbWFjcm8gcmVhZGVyIGNoKVxuICAgICAgICAgICAgICAgICAgIChudW1iZXItbGl0ZXJhbD8gcmVhZGVyIGNoKSAocmVhZC1udW1iZXIgcmVhZGVyIGNoKVxuICAgICAgICAgICAgICAgICAgIDplbHNlIChyZWFkLXN5bWJvbCByZWFkZXIgY2gpKVxuICAgICAgICBlbmQgezpsaW5lICg6bGluZSByZWFkZXIpXG4gICAgICAgICAgICAgOmNvbHVtbiAoaW5jICg6Y29sdW1uIHJlYWRlcikpfVxuICAgICAgICBsb2NhdGlvbiB7OnVyaSAoOnVyaSByZWFkZXIpXG4gICAgICAgICAgICAgICAgICA6c3RhcnQgc3RhcnRcbiAgICAgICAgICAgICAgICAgIDplbmQgZW5kfV1cbiAgICAoY29uZCAoaWRlbnRpY2FsPyBmb3JtIHJlYWRlcikgZm9ybVxuICAgICAgICAgIDs7IFRPRE8gY29uc2lkZXIgYm94aW5nIHByaW1pdGl2ZXMgaW50byBhc3NvY2l0YWRlXG4gICAgICAgICAgOzsgdHlwZXMgdG8gaW5jbHVkZSBtZXRhZGF0YSBvbiB0aG9zZS5cbiAgICAgICAgICAobm90IChvciAoYm9vbGVhbj8gZm9ybSlcbiAgICAgICAgICAgICAgICAgICAobmlsPyBmb3JtKVxuICAgICAgICAgICAgICAgICAgIChrZXl3b3JkPyBmb3JtKSkpICh3aXRoLW1ldGEgZm9ybVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNvbmogbG9jYXRpb24gKG1ldGEgZm9ybSkpKVxuICAgICAgICAgIDplbHNlIGZvcm0pKSlcblxuKGRlZm4gcmVhZFxuICBcIlJlYWRzIHRoZSBmaXJzdCBvYmplY3QgZnJvbSBhIFB1c2hiYWNrUmVhZGVyLlxuICBSZXR1cm5zIHRoZSBvYmplY3QgcmVhZC4gSWYgRU9GLCB0aHJvd3MgaWYgZW9mLWlzLWVycm9yIGlzIHRydWUuXG4gIE90aGVyd2lzZSByZXR1cm5zIHNlbnRpbmVsLlwiXG4gIFtyZWFkZXIgZW9mLWlzLWVycm9yIHNlbnRpbmVsIGlzLXJlY3Vyc2l2ZV1cbiAgKGxvb3AgW11cbiAgICAobGV0IFtjaCAocmVhZC1jaGFyIHJlYWRlcilcbiAgICAgICAgICBmb3JtIChjb25kXG4gICAgICAgICAgICAgICAgKG5pbD8gY2gpIChpZiBlb2YtaXMtZXJyb3IgKHJlYWRlci1lcnJvciByZWFkZXIgOkVPRikgc2VudGluZWwpXG4gICAgICAgICAgICAgICAgKHdoaXRlc3BhY2U/IGNoKSByZWFkZXJcbiAgICAgICAgICAgICAgICAoY29tbWVudC1wcmVmaXg/IGNoKSAocmVhZCAocmVhZC1jb21tZW50IHJlYWRlciBjaClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlb2YtaXMtZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW50aW5lbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzLXJlY3Vyc2l2ZSlcbiAgICAgICAgICAgICAgICA6ZWxzZSAocmVhZC1mb3JtIHJlYWRlciBjaCkpXVxuICAgICAgKGlmIChpZGVudGljYWw/IGZvcm0gcmVhZGVyKVxuICAgICAgICAocmVjdXIpXG4gICAgICAgIGZvcm0pKSkpXG5cbihkZWZuIHJlYWQqXG4gIFtzb3VyY2UgdXJpXVxuICAobGV0IFtyZWFkZXIgKHB1c2gtYmFjay1yZWFkZXIgc291cmNlIHVyaSlcbiAgICAgICAgZW9mIChnZW5zeW0pXVxuICAgIChsb29wIFtmb3JtcyBbXVxuICAgICAgICAgICBmb3JtIChyZWFkIHJlYWRlciBmYWxzZSBlb2YgZmFsc2UpXVxuICAgICAgKGlmIChpZGVudGljYWw/IGZvcm0gZW9mKVxuICAgICAgICBmb3Jtc1xuICAgICAgICAocmVjdXIgKGNvbmogZm9ybXMgZm9ybSlcbiAgICAgICAgICAgICAgIChyZWFkIHJlYWRlciBmYWxzZSBlb2YgZmFsc2UpKSkpKSlcblxuXG5cbihkZWZuIHJlYWQtZnJvbS1zdHJpbmdcbiAgXCJSZWFkcyBvbmUgb2JqZWN0IGZyb20gdGhlIHN0cmluZyBzXCJcbiAgW3NvdXJjZSB1cmldXG4gIChsZXQgW3JlYWRlciAocHVzaC1iYWNrLXJlYWRlciBzb3VyY2UgdXJpKV1cbiAgICAocmVhZCByZWFkZXIgdHJ1ZSBuaWwgZmFsc2UpKSlcblxuKGRlZm4gXjpwcml2YXRlIHJlYWQtdXVpZFxuICBbdXVpZF1cbiAgKGlmIChzdHJpbmc/IHV1aWQpXG4gICAgYChVVUlELiB+dXVpZClcbiAgICAocmVhZGVyLWVycm9yXG4gICAgIG5pbCBcIlVVSUQgbGl0ZXJhbCBleHBlY3RzIGEgc3RyaW5nIGFzIGl0cyByZXByZXNlbnRhdGlvbi5cIikpKVxuXG4oZGVmbiBeOnByaXZhdGUgcmVhZC1xdWV1ZVxuICBbaXRlbXNdXG4gIChpZiAodmVjdG9yPyBpdGVtcylcbiAgICBgKFBlcnNpc3RlbnRRdWV1ZS4gfml0ZW1zKVxuICAgIChyZWFkZXItZXJyb3JcbiAgICAgbmlsIFwiUXVldWUgbGl0ZXJhbCBleHBlY3RzIGEgdmVjdG9yIGZvciBpdHMgZWxlbWVudHMuXCIpKSlcblxuXG4oZGVmICoqdGFnLXRhYmxlKipcbiAgKGRpY3Rpb25hcnkgOnV1aWQgcmVhZC11dWlkXG4gICAgICAgICAgICAgIDpxdWV1ZSByZWFkLXF1ZXVlKSlcblxuKGRlZm4gbWF5YmUtcmVhZC10YWdnZWQtdHlwZVxuICBbcmVhZGVyIGluaXRjaF1cbiAgKGxldCBbdGFnIChyZWFkLXN5bWJvbCByZWFkZXIgaW5pdGNoKVxuICAgICAgICBwZm4gKGdldCAqKnRhZy10YWJsZSoqIChuYW1lIHRhZykpXVxuICAgIChpZiBwZm5cbiAgICAgIChwZm4gKHJlYWQgcmVhZGVyIHRydWUgbmlsIGZhbHNlKSlcbiAgICAgIChyZWFkZXItZXJyb3IgcmVhZGVyXG4gICAgICAgICAgICAgICAgICAgIChzdHIgXCJDb3VsZCBub3QgZmluZCB0YWcgcGFyc2VyIGZvciBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgIChuYW1lIHRhZylcbiAgICAgICAgICAgICAgICAgICAgICAgICBcIiBpbiBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgIChzdHIgKGtleXMgKip0YWctdGFibGUqKikpKSkpKSlcbiJdfQ==

},{"./ast":"ReP8Ll","./runtime":"wcC2X1","./sequence":"Mdzbzt","./string":"31fh9Q"}],"wisp/reader":[function(require,module,exports){
module.exports=require('vmsNNR');
},{}],"qcnT8U":[function(require,module,exports){
{
    var _ns_ = {
            id: 'wisp.repl',
            doc: void 0
        };
    var repl = require('repl');
    var repl = repl;
    var vm = require('vm');
    var vm = vm;
    var wisp_runtime = require('./runtime');
    var subs = wisp_runtime.subs;
    var isEqual = wisp_runtime.isEqual;
    var keys = wisp_runtime.keys;
    var wisp_sequence = require('./sequence');
    var count = wisp_sequence.count;
    var list = wisp_sequence.list;
    var conj = wisp_sequence.conj;
    var cons = wisp_sequence.cons;
    var vec = wisp_sequence.vec;
    var last = wisp_sequence.last;
    var wisp_compiler = require('./compiler');
    var compile = wisp_compiler.compile;
    var readForms = wisp_compiler.readForms;
    var analyzeForms = wisp_compiler.analyzeForms;
    var generate = wisp_compiler.generate;
    var wisp_ast = require('./ast');
    var prStr = wisp_ast.prStr;
    var base64Encode = require('base64-encode');
    var btoa = base64Encode;
}
var evaluateCode = exports.evaluateCode = function evaluateCode(source, uri, context) {
        return function () {
            var sourceUriø1 = '' + 'data:application/wisp;charset=utf-8;base64,' + btoa(source);
            var formsø1 = readForms(source, sourceUriø1);
            var nodesø1 = (formsø1 || 0)['forms'] ? analyzeForms((formsø1 || 0)['forms']) : void 0;
            var inputø1 = (nodesø1 || 0)['ast'] ? (function () {
                    try {
                        return generate.apply(void 0, vec(cons({ 'source-uri': sourceUriø1 }, (nodesø1 || 0)['ast'])));
                    } catch (error) {
                        return { 'error': error };
                    }
                })() : void 0;
            var outputø1 = (inputø1 || 0)['code'] ? (function () {
                    try {
                        return { 'value': vm.runInContext((inputø1 || 0)['code'], context, uri) };
                    } catch (error) {
                        return { 'error': error };
                    }
                })() : void 0;
            var resultø1 = conj(formsø1, nodesø1, inputø1, outputø1, { 'error': (outputø1 || 0)['error'] || (inputø1 || 0)['error'] || (nodesø1 || 0)['error'] || (formsø1 || 0)['error'] });
            context._3 = context._2;
            context._2 = context._1;
            return context._1 = resultø1;
        }.call(this);
    };
var evaluate = exports.evaluate = function () {
        var inputø1 = void 0;
        var outputø1 = void 0;
        return function evaluate(code, context, file, callback) {
            return !(inputø1 === code) ? (function () {
                inputø1 = !(last(code) === '\n') ? subs(code, 0, count(code) - 1) : code;
                outputø1 = evaluateCode(inputø1, file, context);
                return callback((outputø1 || 0)['error'], (outputø1 || 0)['value']);
            })() : callback((outputø1 || 0)['error']);
        };
    }.call(this);
var start = exports.start = function start() {
        return function () {
            var sessionø1 = repl.start({
                    'writer': prStr,
                    'prompt': '=> ',
                    'ignoreUndefined': true,
                    'useGlobal': false,
                    'eval': evaluate
                });
            var contextø1 = sessionø1.context;
            [
                'runtime',
                'sequence',
                'string'
            ].map(function (n) {
                return function () {
                    var fø1 = require('' + './src/' + n + '.wisp');
                    return keys(fø1).map(function (k) {
                        return (contextø1 || 0)[k] = (fø1 || 0)[k];
                    });
                }.call(this);
            });
            contextø1.exports = {};
            return sessionø1;
        }.call(this);
    };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFub255bW91cy53aXNwIl0sIm5hbWVzIjpbIl9uc18iLCJpZCIsImRvYyIsInN1YnMiLCJpc0VxdWFsIiwia2V5cyIsImNvdW50IiwibGlzdCIsImNvbmoiLCJjb25zIiwidmVjIiwibGFzdCIsImNvbXBpbGUiLCJyZWFkRm9ybXMiLCJhbmFseXplRm9ybXMiLCJnZW5lcmF0ZSIsInByU3RyIiwiZXZhbHVhdGVDb2RlIiwiZXhwb3J0cyIsInNvdXJjZSIsInVyaSIsImNvbnRleHQiLCJzb3VyY2VVcmnDuDEiLCJidG9hIiwiZm9ybXPDuDEiLCJub2Rlc8O4MSIsImlucHV0w7gxIiwiZXJyb3IiLCJvdXRwdXTDuDEiLCJ2bSIsInJ1bkluQ29udGV4dCIsInJlc3VsdMO4MSIsIl8zIiwiXzIiLCJfMSIsImV2YWx1YXRlIiwiY29kZSIsImZpbGUiLCJjYWxsYmFjayIsInN0YXJ0Iiwic2Vzc2lvbsO4MSIsInJlcGwiLCJjb250ZXh0w7gxIiwibWFwIiwibiIsImbDuDEiLCJyZXF1aXJlIiwiayJdLCJtYXBwaW5ncyI6IjtJQUFBLElBQUNBLEksR0FBRDtBQUFBLFlBQUFDLEUsRUFBSSxXQUFKO0FBQUEsWUFBQUMsRyxFQUFBLEssQ0FBQTtBQUFBLFU7Ozs7OztRQUdrQ0MsSUFBQSxHLGFBQUFBLEk7UUFBS0MsT0FBQSxHLGFBQUFBLE87UUFBRUMsSUFBQSxHLGFBQUFBLEk7O1FBQ05DLEtBQUEsRyxjQUFBQSxLO1FBQU1DLElBQUEsRyxjQUFBQSxJO1FBQUtDLElBQUEsRyxjQUFBQSxJO1FBQUtDLElBQUEsRyxjQUFBQSxJO1FBQUtDLEdBQUEsRyxjQUFBQSxHO1FBQUlDLElBQUEsRyxjQUFBQSxJOztRQUN6QkMsT0FBQSxHLGNBQUFBLE87UUFBUUMsU0FBQSxHLGNBQUFBLFM7UUFBV0MsWUFBQSxHLGNBQUFBLFk7UUFBY0MsUUFBQSxHLGNBQUFBLFE7O1FBQ3RDQyxLQUFBLEcsU0FBQUEsSzs7OztBQUc5QixJQUFNQyxZQUFBLEdBQUFDLE9BQUEsQ0FBQUQs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QUFBLEdBQUFyQixPQUFBLENBQUFxQixLQUFBLEdBQU4sU0FBTUEsS0FBTixHQUdFO0FBQUEsZSxZQUFNO0FBQUEsZ0JBQUFDLFMsR0FBZ0JDLElBQVAsQ0FBQ0YsS0FBRixDQUNRO0FBQUEsb0IsVUFBU3ZCLEtBQVQ7QUFBQSxvQixVQUNTLEtBRFQ7QUFBQSxvQix1QkFBQTtBQUFBLG9CLGtCQUFBO0FBQUEsb0IsUUFJT21CLFFBSlA7QUFBQSxpQkFEUixDQUFSO0FBQUEsWUFNQSxJQUFBTyxTLEdBQW1CRixTQUFYLENBQUduQixPQUFYLENBTkE7QUFBQSxZQVFFO0FBQUEsZ0JBQUMsU0FBRDtBQUFBLGdCQUFXLFVBQVg7QUFBQSxnQkFBc0IsUUFBdEI7QUFBQSxhQUFMLENBQUNzQixHQUFGLENBQ00sVUFBS0MsQ0FBTCxFQUNFO0FBQUEsdUIsWUFBTTtBQUFBLHdCQUFBQyxHLEdBQUdDLE9BQUQsQyxLQUFjLFEsR0FBU0YsQ0FBZCxHQUFnQixPQUF6QixDQUFGO0FBQUEsb0JBQ0osT0FBT3ZDLElBQUQsQ0FBTXdDLEdBQU4sQ0FBTCxDQUFDRixHQUFGLENBQ00sVUFBS0ksQ0FBTCxFQUFRO0FBQUEsK0IsQ0FBV0wsUyxNQUFMLENBQWFLLENBQWIsQ0FBTixHLENBQTJCRixHLE1BQUwsQ0FBT0UsQ0FBUCxDQUF0QjtBQUFBLHFCQURkLEVBREk7QUFBQSxpQixLQUFOLEMsSUFBQTtBQUFBLGFBRlIsRUFSSTtBQUFBLFlBYUVMLFNBQUEsQ0FBUXhCLE9BQWQsR0FBc0IsRUFBdEIsQ0FiSTtBQUFBLFlBY0osT0FBQXNCLFNBQUEsQ0FkSTtBQUFBLFMsS0FBTixDLElBQUE7QUFBQSxLQUhGIiwic291cmNlc0NvbnRlbnQiOlsiKG5zIHdpc3AucmVwbFxuICAoOnJlcXVpcmUgW3JlcGwgOmFzIHJlcGxdXG4gICAgICAgICAgICBbdm0gOmFzIHZtXVxuICAgICAgICAgICAgW3dpc3AucnVudGltZSA6cmVmZXIgW3N1YnMgPSBrZXlzXV1cbiAgICAgICAgICAgIFt3aXNwLnNlcXVlbmNlIDpyZWZlciBbY291bnQgbGlzdCBjb25qIGNvbnMgdmVjIGxhc3RdXVxuICAgICAgICAgICAgW3dpc3AuY29tcGlsZXIgOnJlZmVyIFtjb21waWxlIHJlYWQtZm9ybXMgYW5hbHl6ZS1mb3JtcyBnZW5lcmF0ZV1dXG4gICAgICAgICAgICBbd2lzcC5hc3QgOnJlZmVyIFtwci1zdHJdXVxuICAgICAgICAgICAgW2Jhc2U2NC1lbmNvZGUgOmFzIGJ0b2FdKSlcblxuKGRlZm4gZXZhbHVhdGUtY29kZVxuICBcIkV2YWx1YXRlcyBzb21lIHRleHQgZnJvbSBSRVBMIGlucHV0LiBJZiBtdWx0aXBsZSBmb3JtcyBhcmVcbiAgcHJlc2VudCwgZXZhbHVhdGVzIGluIHNlcXVlbmNlIHVudGlsIG9uZSB0aHJvd3MgYW4gZXJyb3JcbiAgb3IgdGhlIGxhc3QgZm9ybSBpcyByZWFjaGVkLiBUaGUgcmVzdWx0IGZyb20gdGhlIGxhc3RcbiAgZXZhbHVhdGVkIGZvcm0gaXMgcmV0dXJuZWQuICoxLCAqMiwgKjMsIGFuZCAqZSBhcmUgdXBkYXRlZFxuICBhcHByb3ByaWF0ZWx5LlwiXG4gIFtzb3VyY2UgdXJpIGNvbnRleHRdXG4gIChsZXQgW3NvdXJjZS11cmkgKHN0ciBcImRhdGE6YXBwbGljYXRpb24vd2lzcDtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgKGJ0b2Egc291cmNlKSlcbiAgICAgICAgZm9ybXMgKHJlYWQtZm9ybXMgc291cmNlIHNvdXJjZS11cmkpXG4gICAgICAgIG5vZGVzIChpZiAoOmZvcm1zIGZvcm1zKSAoYW5hbHl6ZS1mb3JtcyAoOmZvcm1zIGZvcm1zKSkpXG4gICAgICAgIGlucHV0IChpZiAoOmFzdCBub2RlcylcbiAgICAgICAgICAgICAgICAodHJ5ICAgICAgICAgICAgICA7OyBUT0RPOiBSZW1vdmUgdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDs7IE9sZCBjb21waWxlciBoYXMgaW5jb3JyZWN0IGFwcGx5LlxuICAgICAgICAgICAgICAgICAgKGFwcGx5IGdlbmVyYXRlICh2ZWMgKGNvbnMgezpzb3VyY2UtdXJpIHNvdXJjZS11cml9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoOmFzdCBub2RlcykpKSlcbiAgICAgICAgICAgICAgICAgIChjYXRjaCBlcnJvciB7OmVycm9yIGVycm9yfSkpKVxuICAgICAgICBvdXRwdXQgKGlmICg6Y29kZSBpbnB1dClcbiAgICAgICAgICAgICAgICAgKHRyeVxuICAgICAgICAgICAgICAgICAgIHs6dmFsdWUgKC5ydW4taW4tY29udGV4dCB2bSAoOmNvZGUgaW5wdXQpIGNvbnRleHQgdXJpKX1cbiAgICAgICAgICAgICAgICAgICAoY2F0Y2ggZXJyb3IgezplcnJvciBlcnJvcn0pKSlcbiAgICAgICAgcmVzdWx0IChjb25qIGZvcm1zIG5vZGVzIGlucHV0IG91dHB1dCB7OmVycm9yIChvciAoOmVycm9yIG91dHB1dClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoOmVycm9yIGlucHV0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICg6ZXJyb3Igbm9kZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKDplcnJvciBmb3JtcykpfSldXG4gICAgKHNldCEgY29udGV4dC4qMyBjb250ZXh0LioyKVxuICAgIChzZXQhIGNvbnRleHQuKjIgY29udGV4dC4qMSlcbiAgICAoc2V0ISBjb250ZXh0LioxIHJlc3VsdCkpKVxuXG4oZGVmIGV2YWx1YXRlXG4gIChsZXQgW2lucHV0IG5pbFxuICAgICAgICBvdXRwdXQgbmlsXVxuICAgIChmbiBldmFsdWF0ZSBbY29kZSBjb250ZXh0IGZpbGUgY2FsbGJhY2tdXG4gICAgICAoaWYgKG5vdCAoaWRlbnRpY2FsPyBpbnB1dCBjb2RlKSlcbiAgICAgICAgKGRvXG4gICAgICAgICAgKHNldCEgaW5wdXRcbiAgICAgICAgICAgIChpZiAobm90IChpZGVudGljYWw/IChsYXN0IGNvZGUpIFwiXFxuXCIpKVxuICAgICAgICAgICAgICAoc3VicyBjb2RlIDAgKC0gKGNvdW50IGNvZGUpIDEpKVxuICAgICAgICAgICAgICBjb2RlKSlcbiAgICAgICAgICAoc2V0ISBvdXRwdXQgKGV2YWx1YXRlLWNvZGUgaW5wdXQgZmlsZSBjb250ZXh0KSlcbiAgICAgICAgICAoY2FsbGJhY2sgKDplcnJvciBvdXRwdXQpICg6dmFsdWUgb3V0cHV0KSkpXG4gICAgICAgIChjYWxsYmFjayAoOmVycm9yIG91dHB1dCkpKSkpKVxuXG4oZGVmbiBzdGFydFxuICBcIlN0YXJ0cyByZXBsXCJcbiAgW11cbiAgKGxldCBbc2Vzc2lvbiAoLnN0YXJ0IHJlcGxcbiAgICAgICAgICAgICAgICAgICAgICAgIHs6d3JpdGVyIHByLXN0clxuICAgICAgICAgICAgICAgICAgICAgICAgIDpwcm9tcHQgXCI9PiBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgIDppZ25vcmVVbmRlZmluZWQgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgIDp1c2VHbG9iYWwgZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICA6ZXZhbCBldmFsdWF0ZX0pXG4gICAgICAgIGNvbnRleHQgKC4tY29udGV4dCBzZXNzaW9uKV1cbiAgICA7IGhvaXN0IHdpc3AgYnVpbHRpbnMgaW50byB0aGUgcmVwbFxuICAgICgubWFwIFtcInJ1bnRpbWVcIiBcInNlcXVlbmNlXCIgXCJzdHJpbmdcIl1cbiAgICAgICAgICAoZm4gW25dXG4gICAgICAgICAgICAobGV0IFtmIChyZXF1aXJlIChzdHIgXCIuL3NyYy9cIiBuIFwiLndpc3BcIikpXVxuICAgICAgICAgICAgICAoLm1hcCAoa2V5cyBmKVxuICAgICAgICAgICAgICAgICAgICAoZm4gW2tdIChzZXQhIChnZXQgY29udGV4dCBrKSAoZ2V0IGYgaykpKSkpKSlcbiAgICAoc2V0ISBjb250ZXh0LmV4cG9ydHMge30pXG4gICAgc2Vzc2lvbikpXG4iXX0=

},{"./ast":"ReP8Ll","./compiler":"hi5qrU","./runtime":"wcC2X1","./sequence":"Mdzbzt","base64-encode":16,"repl":20,"vm":41}],"wisp/repl":[function(require,module,exports){
module.exports=require('qcnT8U');
},{}],"wisp/runtime":[function(require,module,exports){
module.exports=require('wcC2X1');
},{}],"wcC2X1":[function(require,module,exports){
{
    var _ns_ = {
            id: 'wisp.runtime',
            doc: 'Core primitives required for runtime'
        };
}
var identity = exports.identity = function identity(x) {
        return x;
    };
var complement = exports.complement = function complement(f) {
        return function () {
            switch (arguments.length) {
            case 0:
                return !f();
            case 1:
                var x = arguments[0];
                return !f(x);
            case 2:
                var x = arguments[0];
                var y = arguments[1];
                return !f(x, y);
            default:
                var x = arguments[0];
                var y = arguments[1];
                var zs = Array.prototype.slice.call(arguments, 2);
                return !f.apply(void 0, [
                    x,
                    y
                ].concat(zs));
            }
        };
    };
var isOdd = exports.isOdd = function isOdd(n) {
        return n % 2 === 1;
    };
var isEven = exports.isEven = function isEven(n) {
        return n % 2 === 0;
    };
var isDictionary = exports.isDictionary = function isDictionary(form) {
        return isObject(form) && isObject(Object.getPrototypeOf(form)) && isNil(Object.getPrototypeOf(Object.getPrototypeOf(form)));
    };
var dictionary = exports.dictionary = function dictionary() {
        var pairs = Array.prototype.slice.call(arguments, 0);
        return function loop() {
            var recur = loop;
            var keyValuesø1 = pairs;
            var resultø1 = {};
            do {
                recur = keyValuesø1.length ? (function () {
                    resultø1[keyValuesø1[0]] = keyValuesø1[1];
                    return loop[0] = keyValuesø1.slice(2), loop[1] = resultø1, loop;
                })() : resultø1;
            } while (keyValuesø1 = loop[0], resultø1 = loop[1], recur === loop);
            return recur;
        }.call(this);
    };
var keys = exports.keys = function keys(dictionary) {
        return Object.keys(dictionary);
    };
var vals = exports.vals = function vals(dictionary) {
        return keys(dictionary).map(function (key) {
            return (dictionary || 0)[key];
        });
    };
var keyValues = exports.keyValues = function keyValues(dictionary) {
        return keys(dictionary).map(function (key) {
            return [
                key,
                (dictionary || 0)[key]
            ];
        });
    };
var merge = exports.merge = function merge() {
        return Object.create(Object.prototype, Array.prototype.slice.call(arguments).reduce(function (descriptor, dictionary) {
            isObject(dictionary) ? Object.keys(dictionary).forEach(function (key) {
                return (descriptor || 0)[key] = Object.getOwnPropertyDescriptor(dictionary, key);
            }) : void 0;
            return descriptor;
        }, Object.create(Object.prototype)));
    };
var isSatisfies = exports.isSatisfies = function isSatisfies(protocol, x) {
        return protocol.wisp_core$IProtocol$_ || (x === void 0 ? protocol.wisp_core$IProtocol$nil || false : x === null ? protocol.wisp_core$IProtocol$nil || false : 'else' ? x[protocol.wisp_core$IProtocol$id] || protocol['' + 'wisp_core$IProtocol$' + Object.prototype.toString.call(x).replace('[object ', '').replace(/\]$/, '')] || false : void 0);
    };
var isContainsVector = exports.isContainsVector = function isContainsVector(vector, element) {
        return vector.indexOf(element) >= 0;
    };
var mapDictionary = exports.mapDictionary = function mapDictionary(source, f) {
        return Object.keys(source).reduce(function (target, key) {
            (target || 0)[key] = f((source || 0)[key]);
            return target;
        }, {});
    };
var toString = exports.toString = Object.prototype.toString;
var isFn = exports.isFn = typeof(/./) === 'function' ? function (x) {
        return toString.call(x) === '[object Function]';
    } : function (x) {
        return typeof(x) === 'function';
    };
var isError = exports.isError = function isError(x) {
        return x instanceof Error || toString.call(x) === '[object Error]';
    };
var isString = exports.isString = function isString(x) {
        return typeof(x) === 'string' || toString.call(x) === '[object String]';
    };
var isNumber = exports.isNumber = function isNumber(x) {
        return typeof(x) === 'number' || toString.call(x) === '[object Number]';
    };
var isVector = exports.isVector = isFn(Array.isArray) ? Array.isArray : function (x) {
        return toString.call(x) === '[object Array]';
    };
var isDate = exports.isDate = function isDate(x) {
        return toString.call(x) === '[object Date]';
    };
var isBoolean = exports.isBoolean = function isBoolean(x) {
        return x === true || x === false || toString.call(x) === '[object Boolean]';
    };
var isRePattern = exports.isRePattern = function isRePattern(x) {
        return toString.call(x) === '[object RegExp]';
    };
var isObject = exports.isObject = function isObject(x) {
        return x && typeof(x) === 'object';
    };
var isNil = exports.isNil = function isNil(x) {
        return x === void 0 || x === null;
    };
var isTrue = exports.isTrue = function isTrue(x) {
        return x === true;
    };
var isFalse = exports.isFalse = function isFalse(x) {
        return x === false;
    };
var reFind = exports.reFind = function reFind(re, s) {
        return function () {
            var matchesø1 = re.exec(s);
            return !isNil(matchesø1) ? matchesø1.length === 1 ? (matchesø1 || 0)[0] : matchesø1 : void 0;
        }.call(this);
    };
var reMatches = exports.reMatches = function reMatches(pattern, source) {
        return function () {
            var matchesø1 = pattern.exec(source);
            return !isNil(matchesø1) && (matchesø1 || 0)[0] === source ? matchesø1.length === 1 ? (matchesø1 || 0)[0] : matchesø1 : void 0;
        }.call(this);
    };
var rePattern = exports.rePattern = function rePattern(s) {
        return function () {
            var matchø1 = reFind(/^(?:\(\?([idmsux]*)\))?(.*)/, s);
            return new RegExp((matchø1 || 0)[2], (matchø1 || 0)[1]);
        }.call(this);
    };
var inc = exports.inc = function inc(x) {
        return x + 1;
    };
var dec = exports.dec = function dec(x) {
        return x - 1;
    };
var str = exports.str = function str() {
        return String.prototype.concat.apply('', arguments);
    };
var char = exports.char = function char(code) {
        return String.fromCharCode(code);
    };
var int = exports.int = function int(x) {
        return isNumber(x) ? x >= 0 ? Math.floor(x) : Math.floor(x) : x.charCodeAt(0);
    };
var subs = exports.subs = function subs(string, start, end) {
        return string.substring(start, end);
    };
var isPatternEqual = function isPatternEqual(x, y) {
    return isRePattern(x) && isRePattern(y) && x.source === y.source && x.global === y.global && x.multiline === y.multiline && x.ignoreCase === y.ignoreCase;
};
var isDateEqual = function isDateEqual(x, y) {
    return isDate(x) && isDate(y) && Number(x) === Number(y);
};
var isDictionaryEqual = function isDictionaryEqual(x, y) {
    return isObject(x) && isObject(y) && function () {
        var xKeysø1 = keys(x);
        var yKeysø1 = keys(y);
        var xCountø1 = xKeysø1.length;
        var yCountø1 = yKeysø1.length;
        return xCountø1 === yCountø1 && function loop() {
            var recur = loop;
            var indexø1 = 0;
            var countø1 = xCountø1;
            var keysø1 = xKeysø1;
            do {
                recur = indexø1 < countø1 ? isEquivalent((x || 0)[(keysø1 || 0)[indexø1]], (y || 0)[(keysø1 || 0)[indexø1]]) ? (loop[0] = inc(indexø1), loop[1] = countø1, loop[2] = keysø1, loop) : false : true;
            } while (indexø1 = loop[0], countø1 = loop[1], keysø1 = loop[2], recur === loop);
            return recur;
        }.call(this);
    }.call(this);
};
var isVectorEqual = function isVectorEqual(x, y) {
    return isVector(x) && isVector(y) && x.length === y.length && function loop() {
        var recur = loop;
        var xsø1 = x;
        var ysø1 = y;
        var indexø1 = 0;
        var countø1 = x.length;
        do {
            recur = indexø1 < countø1 ? isEquivalent((xsø1 || 0)[indexø1], (ysø1 || 0)[indexø1]) ? (loop[0] = xsø1, loop[1] = ysø1, loop[2] = inc(indexø1), loop[3] = countø1, loop) : false : true;
        } while (xsø1 = loop[0], ysø1 = loop[1], indexø1 = loop[2], countø1 = loop[3], recur === loop);
        return recur;
    }.call(this);
};
var isEquivalent = function isEquivalent() {
    switch (arguments.length) {
    case 1:
        var x = arguments[0];
        return true;
    case 2:
        var x = arguments[0];
        var y = arguments[1];
        return x === y || (isNil(x) ? isNil(y) : isNil(y) ? isNil(x) : isString(x) ? isString(y) && x.toString() === y.toString() : isNumber(x) ? isNumber(y) && x.valueOf() === y.valueOf() : isFn(x) ? false : isBoolean(x) ? false : isDate(x) ? isDateEqual(x, y) : isVector(x) ? isVectorEqual(x, y, [], []) : isRePattern(x) ? isPatternEqual(x, y) : 'else' ? isDictionaryEqual(x, y) : void 0);
    default:
        var x = arguments[0];
        var y = arguments[1];
        var more = Array.prototype.slice.call(arguments, 2);
        return function loop() {
            var recur = loop;
            var previousø1 = x;
            var currentø1 = y;
            var indexø1 = 0;
            var countø1 = more.length;
            do {
                recur = isEquivalent(previousø1, currentø1) && (indexø1 < countø1 ? (loop[0] = currentø1, loop[1] = (more || 0)[indexø1], loop[2] = inc(indexø1), loop[3] = countø1, loop) : true);
            } while (previousø1 = loop[0], currentø1 = loop[1], indexø1 = loop[2], countø1 = loop[3], recur === loop);
            return recur;
        }.call(this);
    }
};
var isEqual = exports.isEqual = isEquivalent;
var isStrictEqual = exports.isStrictEqual = function isStrictEqual() {
        switch (arguments.length) {
        case 1:
            var x = arguments[0];
            return true;
        case 2:
            var x = arguments[0];
            var y = arguments[1];
            return x === y;
        default:
            var x = arguments[0];
            var y = arguments[1];
            var more = Array.prototype.slice.call(arguments, 2);
            return function loop() {
                var recur = loop;
                var previousø1 = x;
                var currentø1 = y;
                var indexø1 = 0;
                var countø1 = more.length;
                do {
                    recur = previousø1 == currentø1 && (indexø1 < countø1 ? (loop[0] = currentø1, loop[1] = (more || 0)[indexø1], loop[2] = inc(indexø1), loop[3] = countø1, loop) : true);
                } while (previousø1 = loop[0], currentø1 = loop[1], indexø1 = loop[2], countø1 = loop[3], recur === loop);
                return recur;
            }.call(this);
        }
    };
var greaterThan = exports.greaterThan = function greaterThan() {
        switch (arguments.length) {
        case 1:
            var x = arguments[0];
            return true;
        case 2:
            var x = arguments[0];
            var y = arguments[1];
            return x > y;
        default:
            var x = arguments[0];
            var y = arguments[1];
            var more = Array.prototype.slice.call(arguments, 2);
            return function loop() {
                var recur = loop;
                var previousø1 = x;
                var currentø1 = y;
                var indexø1 = 0;
                var countø1 = more.length;
                do {
                    recur = previousø1 > currentø1 && (indexø1 < countø1 ? (loop[0] = currentø1, loop[1] = (more || 0)[indexø1], loop[2] = inc(indexø1), loop[3] = countø1, loop) : true);
                } while (previousø1 = loop[0], currentø1 = loop[1], indexø1 = loop[2], countø1 = loop[3], recur === loop);
                return recur;
            }.call(this);
        }
    };
var notLessThan = exports.notLessThan = function notLessThan() {
        switch (arguments.length) {
        case 1:
            var x = arguments[0];
            return true;
        case 2:
            var x = arguments[0];
            var y = arguments[1];
            return x >= y;
        default:
            var x = arguments[0];
            var y = arguments[1];
            var more = Array.prototype.slice.call(arguments, 2);
            return function loop() {
                var recur = loop;
                var previousø1 = x;
                var currentø1 = y;
                var indexø1 = 0;
                var countø1 = more.length;
                do {
                    recur = previousø1 >= currentø1 && (indexø1 < countø1 ? (loop[0] = currentø1, loop[1] = (more || 0)[indexø1], loop[2] = inc(indexø1), loop[3] = countø1, loop) : true);
                } while (previousø1 = loop[0], currentø1 = loop[1], indexø1 = loop[2], countø1 = loop[3], recur === loop);
                return recur;
            }.call(this);
        }
    };
var lessThan = exports.lessThan = function lessThan() {
        switch (arguments.length) {
        case 1:
            var x = arguments[0];
            return true;
        case 2:
            var x = arguments[0];
            var y = arguments[1];
            return x < y;
        default:
            var x = arguments[0];
            var y = arguments[1];
            var more = Array.prototype.slice.call(arguments, 2);
            return function loop() {
                var recur = loop;
                var previousø1 = x;
                var currentø1 = y;
                var indexø1 = 0;
                var countø1 = more.length;
                do {
                    recur = previousø1 < currentø1 && (indexø1 < countø1 ? (loop[0] = currentø1, loop[1] = (more || 0)[indexø1], loop[2] = inc(indexø1), loop[3] = countø1, loop) : true);
                } while (previousø1 = loop[0], currentø1 = loop[1], indexø1 = loop[2], countø1 = loop[3], recur === loop);
                return recur;
            }.call(this);
        }
    };
var notGreaterThan = exports.notGreaterThan = function notGreaterThan() {
        switch (arguments.length) {
        case 1:
            var x = arguments[0];
            return true;
        case 2:
            var x = arguments[0];
            var y = arguments[1];
            return x <= y;
        default:
            var x = arguments[0];
            var y = arguments[1];
            var more = Array.prototype.slice.call(arguments, 2);
            return function loop() {
                var recur = loop;
                var previousø1 = x;
                var currentø1 = y;
                var indexø1 = 0;
                var countø1 = more.length;
                do {
                    recur = previousø1 <= currentø1 && (indexø1 < countø1 ? (loop[0] = currentø1, loop[1] = (more || 0)[indexø1], loop[2] = inc(indexø1), loop[3] = countø1, loop) : true);
                } while (previousø1 = loop[0], currentø1 = loop[1], indexø1 = loop[2], countø1 = loop[3], recur === loop);
                return recur;
            }.call(this);
        }
    };
var sum = exports.sum = function sum() {
        switch (arguments.length) {
        case 0:
            return 0;
        case 1:
            var a = arguments[0];
            return a;
        case 2:
            var a = arguments[0];
            var b = arguments[1];
            return a + b;
        case 3:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            return a + b + c;
        case 4:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            return a + b + c + d;
        case 5:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            var e = arguments[4];
            return a + b + c + d + e;
        case 6:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            var e = arguments[4];
            var f = arguments[5];
            return a + b + c + d + e + f;
        default:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            var e = arguments[4];
            var f = arguments[5];
            var more = Array.prototype.slice.call(arguments, 6);
            return function loop() {
                var recur = loop;
                var valueø1 = a + b + c + d + e + f;
                var indexø1 = 0;
                var countø1 = more.length;
                do {
                    recur = indexø1 < countø1 ? (loop[0] = valueø1 + (more || 0)[indexø1], loop[1] = inc(indexø1), loop[2] = countø1, loop) : valueø1;
                } while (valueø1 = loop[0], indexø1 = loop[1], countø1 = loop[2], recur === loop);
                return recur;
            }.call(this);
        }
    };
var subtract = exports.subtract = function subtract() {
        switch (arguments.length) {
        case 0:
            return (function () {
                throw TypeError('Wrong number of args passed to: -');
            })();
        case 1:
            var a = arguments[0];
            return 0 - a;
        case 2:
            var a = arguments[0];
            var b = arguments[1];
            return a - b;
        case 3:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            return a - b - c;
        case 4:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            return a - b - c - d;
        case 5:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            var e = arguments[4];
            return a - b - c - d - e;
        case 6:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            var e = arguments[4];
            var f = arguments[5];
            return a - b - c - d - e - f;
        default:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            var e = arguments[4];
            var f = arguments[5];
            var more = Array.prototype.slice.call(arguments, 6);
            return function loop() {
                var recur = loop;
                var valueø1 = a - b - c - d - e - f;
                var indexø1 = 0;
                var countø1 = more.length;
                do {
                    recur = indexø1 < countø1 ? (loop[0] = valueø1 - (more || 0)[indexø1], loop[1] = inc(indexø1), loop[2] = countø1, loop) : valueø1;
                } while (valueø1 = loop[0], indexø1 = loop[1], countø1 = loop[2], recur === loop);
                return recur;
            }.call(this);
        }
    };
var divide = exports.divide = function divide() {
        switch (arguments.length) {
        case 0:
            return (function () {
                throw TypeError('Wrong number of args passed to: /');
            })();
        case 1:
            var a = arguments[0];
            return 1 / a;
        case 2:
            var a = arguments[0];
            var b = arguments[1];
            return a / b;
        case 3:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            return a / b / c;
        case 4:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            return a / b / c / d;
        case 5:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            var e = arguments[4];
            return a / b / c / d / e;
        case 6:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            var e = arguments[4];
            var f = arguments[5];
            return a / b / c / d / e / f;
        default:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            var e = arguments[4];
            var f = arguments[5];
            var more = Array.prototype.slice.call(arguments, 6);
            return function loop() {
                var recur = loop;
                var valueø1 = a / b / c / d / e / f;
                var indexø1 = 0;
                var countø1 = more.length;
                do {
                    recur = indexø1 < countø1 ? (loop[0] = valueø1 / (more || 0)[indexø1], loop[1] = inc(indexø1), loop[2] = countø1, loop) : valueø1;
                } while (valueø1 = loop[0], indexø1 = loop[1], countø1 = loop[2], recur === loop);
                return recur;
            }.call(this);
        }
    };
var multiply = exports.multiply = function multiply() {
        switch (arguments.length) {
        case 0:
            return 1;
        case 1:
            var a = arguments[0];
            return a;
        case 2:
            var a = arguments[0];
            var b = arguments[1];
            return a * b;
        case 3:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            return a * b * c;
        case 4:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            return a * b * c * d;
        case 5:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            var e = arguments[4];
            return a * b * c * d * e;
        case 6:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            var e = arguments[4];
            var f = arguments[5];
            return a * b * c * d * e * f;
        default:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            var e = arguments[4];
            var f = arguments[5];
            var more = Array.prototype.slice.call(arguments, 6);
            return function loop() {
                var recur = loop;
                var valueø1 = a * b * c * d * e * f;
                var indexø1 = 0;
                var countø1 = more.length;
                do {
                    recur = indexø1 < countø1 ? (loop[0] = valueø1 * (more || 0)[indexø1], loop[1] = inc(indexø1), loop[2] = countø1, loop) : valueø1;
                } while (valueø1 = loop[0], indexø1 = loop[1], countø1 = loop[2], recur === loop);
                return recur;
            }.call(this);
        }
    };
var and = exports.and = function and() {
        switch (arguments.length) {
        case 0:
            return true;
        case 1:
            var a = arguments[0];
            return a;
        case 2:
            var a = arguments[0];
            var b = arguments[1];
            return a && b;
        case 3:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            return a && b && c;
        case 4:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            return a && b && c && d;
        case 5:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            var e = arguments[4];
            return a && b && c && d && e;
        case 6:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            var e = arguments[4];
            var f = arguments[5];
            return a && b && c && d && e && f;
        default:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            var e = arguments[4];
            var f = arguments[5];
            var more = Array.prototype.slice.call(arguments, 6);
            return function loop() {
                var recur = loop;
                var valueø1 = a && b && c && d && e && f;
                var indexø1 = 0;
                var countø1 = more.length;
                do {
                    recur = indexø1 < countø1 ? (loop[0] = valueø1 && (more || 0)[indexø1], loop[1] = inc(indexø1), loop[2] = countø1, loop) : valueø1;
                } while (valueø1 = loop[0], indexø1 = loop[1], countø1 = loop[2], recur === loop);
                return recur;
            }.call(this);
        }
    };
var or = exports.or = function or() {
        switch (arguments.length) {
        case 0:
            return void 0;
        case 1:
            var a = arguments[0];
            return a;
        case 2:
            var a = arguments[0];
            var b = arguments[1];
            return a || b;
        case 3:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            return a || b || c;
        case 4:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            return a || b || c || d;
        case 5:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            var e = arguments[4];
            return a || b || c || d || e;
        case 6:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            var e = arguments[4];
            var f = arguments[5];
            return a || b || c || d || e || f;
        default:
            var a = arguments[0];
            var b = arguments[1];
            var c = arguments[2];
            var d = arguments[3];
            var e = arguments[4];
            var f = arguments[5];
            var more = Array.prototype.slice.call(arguments, 6);
            return function loop() {
                var recur = loop;
                var valueø1 = a || b || c || d || e || f;
                var indexø1 = 0;
                var countø1 = more.length;
                do {
                    recur = indexø1 < countø1 ? (loop[0] = valueø1 || (more || 0)[indexø1], loop[1] = inc(indexø1), loop[2] = countø1, loop) : valueø1;
                } while (valueø1 = loop[0], indexø1 = loop[1], countø1 = loop[2], recur === loop);
                return recur;
            }.call(this);
        }
    };
var print = exports.print = function print() {
        var more = Array.prototype.slice.call(arguments, 0);
        return console.log.apply(void 0, more);
    };
var max = exports.max = Math.max;
var min = exports.min = Math.min;
var isNan = exports.isNan = isNaN;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFub255bW91cy53aXNwIl0sIm5hbWVzIjpbIl9uc18iLCJpZCIsImRvYyIsImlkZW50aXR5IiwiZXhwb3J0cyIsIngiLCJjb21wbGVtZW50IiwiZiIsInkiLCJ6cyIsImlzT2RkIiwibiIsImlzRXZlbiIsImlzRGljdGlvbmFyeSIsImZvcm0iLCJpc09iamVjdCIsIk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwiaXNOaWwiLCJkaWN0aW9uYXJ5IiwicGFpcnMiLCJrZXlWYWx1ZXPDuDEiLCJyZXN1bHTDuDEiLCJsZW5ndGgiLCJzbGljZSIsImtleXMiLCJ2YWxzIiwibWFwIiwia2V5Iiwia2V5VmFsdWVzIiwibWVyZ2UiLCJjcmVhdGUiLCJwcm90b3R5cGUiLCJBcnJheSIsInByb3RvdHlwZS5zbGljZSIsImNhbGwiLCJhcmd1bWVudHMiLCJyZWR1Y2UiLCJkZXNjcmlwdG9yIiwiZm9yRWFjaCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImlzU2F0aXNmaWVzIiwicHJvdG9jb2wiLCJ3aXNwX2NvcmUkSVByb3RvY29sJF8iLCJ3aXNwX2NvcmUkSVByb3RvY29sJG5pbCIsIm51bGwiLCJ3aXNwX2NvcmUkSVByb3RvY29sJGlkIiwicHJvdG90eXBlLnRvU3RyaW5nIiwicmVwbGFjZSIsImlzQ29udGFpbnNWZWN0b3IiLCJ2ZWN0b3IiLCJlbGVtZW50IiwiaW5kZXhPZiIsIm1hcERpY3Rpb25hcnkiLCJzb3VyY2UiLCJ0YXJnZXQiLCJ0b1N0cmluZyIsImlzRm4iLCJ0eXBlb2YiLCJpc0Vycm9yIiwiRXJyb3IiLCJpc1N0cmluZyIsImlzTnVtYmVyIiwiaXNWZWN0b3IiLCJpc0FycmF5IiwiaXNEYXRlIiwiaXNCb29sZWFuIiwiaXNSZVBhdHRlcm4iLCJpc1RydWUiLCJpc0ZhbHNlIiwicmVGaW5kIiwicmUiLCJzIiwibWF0Y2hlc8O4MSIsImV4ZWMiLCJyZU1hdGNoZXMiLCJwYXR0ZXJuIiwicmVQYXR0ZXJuIiwibWF0Y2jDuDEiLCJSZWdFeHAiLCJpbmMiLCJkZWMiLCJzdHIiLCJTdHJpbmciLCJwcm90b3R5cGUuY29uY2F0IiwiYXBwbHkiLCJjaGFyIiwiY29kZSIsImZyb21DaGFyQ29kZSIsImludCIsIk1hdGgiLCJmbG9vciIsImNoYXJDb2RlQXQiLCJzdWJzIiwic3RyaW5nIiwic3RhcnQiLCJlbmQiLCJzdWJzdHJpbmciLCJpc1BhdHRlcm5FcXVhbCIsImdsb2JhbCIsIm11bHRpbGluZSIsImlnbm9yZUNhc2UiLCJpc0RhdGVFcXVhbCIsIk51bWJlciIsImlzRGljdGlvbmFyeUVxdWFsIiwieEtleXPDuDEiLCJ5S2V5c8O4MSIsInhDb3VudMO4MSIsInlDb3VudMO4MSIsImluZGV4w7gxIiwiY291bnTDuDEiLCJrZXlzw7gxIiwiaXNFcXVpdmFsZW50IiwiaXNWZWN0b3JFcXVhbCIsInhzw7gxIiwieXPDuDEiLCJ2YWx1ZU9mIiwibW9yZSIsInByZXZpb3Vzw7gxIiwiY3VycmVudMO4MSIsImlzRXF1YWwiLCJpc1N0cmljdEVxdWFsIiwiZ3JlYXRlclRoYW4iLCJub3RMZXNzVGhhbiIsImxlc3NUaGFuIiwibm90R3JlYXRlclRoYW4iLCJzdW0iLCJhIiwiYiIsImMiLCJkIiwiZSIsInZhbHVlw7gxIiwic3VidHJhY3QiLCJUeXBlRXJyb3IiLCJkaXZpZGUiLCJtdWx0aXBseSIsImFuZCIsIm9yIiwicHJpbnQiLCJjb25zb2xlIiwibG9nIiwibWF4IiwibWluIiwiaXNOYW4iLCJpc05hTiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQSxRQUFDQSxJLEdBQUQ7QUFBQSxZQUFBQyxFLEVBQUksY0FBSjtBQUFBLFlBQUFDLEcsRUFDRSxzQ0FERjtBQUFBO0FBQUE7QUFHQSxJQUFNQyxRQUFBLEdBQUFDLE9BQUEsQ0FBQUQsUUFBQSxHQUFOLFNBQU1BLFFBQU4sQ0FFR0UsQ0FGSCxFQUVNO0FBQUEsZUFBQUEsQ0FBQTtBQUFBLEtBRk4sQ0FIQTtBQU9BLElBQU1DLFVBQUEsR0FBQUYsT0FBQSxDQUFBRSxVQUFBLEdBQU4sU0FBTUEsVUFBTixDQUdHQyxD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QUEsR0FBQTVJLE9BQUEsQ0FBQTRJLEtBQUEsR0FBS0MsS0FBViIsInNvdXJjZXNDb250ZW50IjpbIihucyB3aXNwLnJ1bnRpbWVcbiAgXCJDb3JlIHByaW1pdGl2ZXMgcmVxdWlyZWQgZm9yIHJ1bnRpbWVcIilcblxuKGRlZm4gaWRlbnRpdHlcbiAgXCJSZXR1cm5zIGl0cyBhcmd1bWVudC5cIlxuICBbeF0geClcblxuKGRlZm4gY29tcGxlbWVudFxuICBcIlRha2VzIGEgZm4gZiBhbmQgcmV0dXJucyBhIGZuIHRoYXQgdGFrZXMgdGhlIHNhbWUgYXJndW1lbnRzIGFzIGYsXG4gIGhhcyB0aGUgc2FtZSBlZmZlY3RzLCBpZiBhbnksIGFuZCByZXR1cm5zIHRoZSBvcHBvc2l0ZSB0cnV0aCB2YWx1ZS5cIlxuICBbZl0gKGZuIFxuICAgICAgICAoW10gKG5vdCAoZikpKVxuICAgICAgICAoW3hdIChub3QgKGYgeCkpKVxuICAgICAgICAoW3ggeV0gKG5vdCAoZiB4IHkpKSlcbiAgICAgICAgKFt4IHkgJiB6c10gKG5vdCAoYXBwbHkgZiB4IHkgenMpKSkpKVxuXG4oZGVmbiBeYm9vbGVhbiBvZGQ/IFtuXVxuICAoaWRlbnRpY2FsPyAobW9kIG4gMikgMSkpXG5cbihkZWZuIF5ib29sZWFuIGV2ZW4/IFtuXVxuICAoaWRlbnRpY2FsPyAobW9kIG4gMikgMCkpXG5cbihkZWZuIF5ib29sZWFuIGRpY3Rpb25hcnk/XG4gIFwiUmV0dXJucyB0cnVlIGlmIGRpY3Rpb25hcnlcIlxuICBbZm9ybV1cbiAgKGFuZCAob2JqZWN0PyBmb3JtKVxuICAgICAgIDs7IEluaGVyaXRzIHJpZ2h0IGZvcm0gT2JqZWN0LnByb3RvdHlwZVxuICAgICAgIChvYmplY3Q/ICguZ2V0LXByb3RvdHlwZS1vZiBPYmplY3QgZm9ybSkpXG4gICAgICAgKG5pbD8gKC5nZXQtcHJvdG90eXBlLW9mIE9iamVjdCAoLmdldC1wcm90b3R5cGUtb2YgT2JqZWN0IGZvcm0pKSkpKVxuXG4oZGVmbiBkaWN0aW9uYXJ5XG4gIFwiQ3JlYXRlcyBkaWN0aW9uYXJ5IG9mIGdpdmVuIGFyZ3VtZW50cy4gT2RkIGluZGV4ZWQgYXJndW1lbnRzXG4gIGFyZSB1c2VkIGZvciBrZXlzIGFuZCBldmVucyBmb3IgdmFsdWVzXCJcbiAgWyYgcGFpcnNdXG4gIDsgVE9ETzogV2Ugc2hvdWxkIGNvbnZlcnQga2V5d29yZHMgdG8gbmFtZXMgdG8gbWFrZSBzdXJlIHRoYXQga2V5cyBhcmUgbm90XG4gIDsgdXNlZCBpbiB0aGVpciBrZXl3b3JkIGZvcm0uXG4gIChsb29wIFtrZXktdmFsdWVzIHBhaXJzXG4gICAgICAgICByZXN1bHQge31dXG4gICAgKGlmICguLWxlbmd0aCBrZXktdmFsdWVzKVxuICAgICAgKGRvXG4gICAgICAgIChzZXQhIChhZ2V0IHJlc3VsdCAoYWdldCBrZXktdmFsdWVzIDApKVxuICAgICAgICAgICAgICAoYWdldCBrZXktdmFsdWVzIDEpKVxuICAgICAgICAocmVjdXIgKC5zbGljZSBrZXktdmFsdWVzIDIpIHJlc3VsdCkpXG4gICAgICByZXN1bHQpKSlcblxuKGRlZm4ga2V5c1xuICBcIlJldHVybnMgYSBzZXF1ZW5jZSBvZiB0aGUgbWFwJ3Mga2V5c1wiXG4gIFtkaWN0aW9uYXJ5XVxuICAoLmtleXMgT2JqZWN0IGRpY3Rpb25hcnkpKVxuXG4oZGVmbiB2YWxzXG4gIFwiUmV0dXJucyBhIHNlcXVlbmNlIG9mIHRoZSBtYXAncyB2YWx1ZXMuXCJcbiAgW2RpY3Rpb25hcnldXG4gICgubWFwIChrZXlzIGRpY3Rpb25hcnkpXG4gICAgICAgIChmbiBba2V5XSAoZ2V0IGRpY3Rpb25hcnkga2V5KSkpKVxuXG4oZGVmbiBrZXktdmFsdWVzXG4gIFtkaWN0aW9uYXJ5XVxuICAoLm1hcCAoa2V5cyBkaWN0aW9uYXJ5KVxuICAgICAgICAoZm4gW2tleV0gW2tleSAoZ2V0IGRpY3Rpb25hcnkga2V5KV0pKSlcblxuKGRlZm4gbWVyZ2VcbiAgXCJSZXR1cm5zIGEgZGljdGlvbmFyeSB0aGF0IGNvbnNpc3RzIG9mIHRoZSByZXN0IG9mIHRoZSBtYXBzIGNvbmotZWQgb250b1xuICB0aGUgZmlyc3QuIElmIGEga2V5IG9jY3VycyBpbiBtb3JlIHRoYW4gb25lIG1hcCwgdGhlIG1hcHBpbmcgZnJvbVxuICB0aGUgbGF0dGVyIChsZWZ0LXRvLXJpZ2h0KSB3aWxsIGJlIHRoZSBtYXBwaW5nIGluIHRoZSByZXN1bHQuXCJcbiAgW11cbiAgKE9iamVjdC5jcmVhdGVcbiAgIE9iamVjdC5wcm90b3R5cGVcbiAgICgucmVkdWNlXG4gICAgKC5jYWxsIEFycmF5LnByb3RvdHlwZS5zbGljZSBhcmd1bWVudHMpXG4gICAgKGZuIFtkZXNjcmlwdG9yIGRpY3Rpb25hcnldXG4gICAgICAoaWYgKG9iamVjdD8gZGljdGlvbmFyeSlcbiAgICAgICAgKC5mb3ItZWFjaFxuICAgICAgICAgKE9iamVjdC5rZXlzIGRpY3Rpb25hcnkpXG4gICAgICAgICAoZm4gW2tleV1cbiAgICAgICAgICAgKHNldCFcbiAgICAgICAgICAgIChnZXQgZGVzY3JpcHRvciBrZXkpXG4gICAgICAgICAgICAoT2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvciBkaWN0aW9uYXJ5IGtleSkpKSkpXG4gICAgICBkZXNjcmlwdG9yKVxuICAgIChPYmplY3QuY3JlYXRlIE9iamVjdC5wcm90b3R5cGUpKSkpXG5cblxuKGRlZm4gXmJvb2xlYW4gc2F0aXNmaWVzP1xuICBcIlJldHVybnMgdHJ1ZSBpZiB4IHNhdGlzZmllcyB0aGUgcHJvdG9jb2xcIlxuICBbcHJvdG9jb2wgeF1cbiAgKG9yICguLXdpc3BfY29yZSRJUHJvdG9jb2wkXyBwcm90b2NvbClcbiAgICAgIChjb25kIChpZGVudGljYWw/IHggbmlsKVxuICAgICAgICAgICAgKG9yICguLXdpc3BfY29yZSRJUHJvdG9jb2wkbmlsIHByb3RvY29sKSBmYWxzZSlcblxuICAgICAgICAgICAgKGlkZW50aWNhbD8geCBudWxsKVxuICAgICAgICAgICAgKG9yICguLXdpc3BfY29yZSRJUHJvdG9jb2wkbmlsIHByb3RvY29sKSBmYWxzZSlcblxuICAgICAgICAgICAgOmVsc2UgKG9yIChhZ2V0IHggKGFnZXQgcHJvdG9jb2wgJ3dpc3BfY29yZSRJUHJvdG9jb2wkaWQpKVxuICAgICAgICAgICAgICAgICAgICAgIChhZ2V0IHByb3RvY29sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHN0ciBcIndpc3BfY29yZSRJUHJvdG9jb2wkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgucmVwbGFjZSAoLnJlcGxhY2UgKC5jYWxsIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgeClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJbb2JqZWN0IFwiIFwiXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgI1wiXFxdJFwiIFwiXCIpKSlcbiAgICAgICAgICAgICAgICAgICAgICBmYWxzZSkpKSlcblxuKGRlZm4gXmJvb2xlYW4gY29udGFpbnMtdmVjdG9yP1xuICBcIlJldHVybnMgdHJ1ZSBpZiB2ZWN0b3IgY29udGFpbnMgZ2l2ZW4gZWxlbWVudFwiXG4gIFt2ZWN0b3IgZWxlbWVudF1cbiAgKD49ICguaW5kZXgtb2YgdmVjdG9yIGVsZW1lbnQpIDApKVxuXG5cbihkZWZuIG1hcC1kaWN0aW9uYXJ5XG4gIFwiTWFwcyBkaWN0aW9uYXJ5IHZhbHVlcyBieSBhcHBseWluZyBgZmAgdG8gZWFjaCBvbmVcIlxuICBbc291cmNlIGZdXG4gICgucmVkdWNlICgua2V5cyBPYmplY3Qgc291cmNlKVxuICAgICAgICAgICAoZm4gW3RhcmdldCBrZXldXG4gICAgICAgICAgICAgIChzZXQhIChnZXQgdGFyZ2V0IGtleSkgKGYgKGdldCBzb3VyY2Uga2V5KSkpXG4gICAgICAgICAgICAgIHRhcmdldCkge30pKVxuXG4oZGVmIHRvLXN0cmluZyBPYmplY3QucHJvdG90eXBlLnRvLXN0cmluZylcblxuKGRlZlxuICBeezp0YWcgYm9vbGVhblxuICAgIDpkb2MgXCJSZXR1cm5zIHRydWUgaWYgeCBpcyBhIGZ1bmN0aW9uXCJ9XG4gIGZuP1xuICAoaWYgKGlkZW50aWNhbD8gKHR5cGVvZiAjXCIuXCIpIFwiZnVuY3Rpb25cIilcbiAgICAoZm5cbiAgICAgIFt4XVxuICAgICAgKGlkZW50aWNhbD8gKC5jYWxsIHRvLXN0cmluZyB4KSBcIltvYmplY3QgRnVuY3Rpb25dXCIpKVxuICAgIChmblxuICAgICAgW3hdXG4gICAgICAoaWRlbnRpY2FsPyAodHlwZW9mIHgpIFwiZnVuY3Rpb25cIikpKSlcblxuKGRlZm4gXmJvb2xlYW4gZXJyb3I/XG4gIFwiUmV0dXJucyB0cnVlIGlmIHggaXMgb2YgZXJyb3IgdHlwZVwiXG4gIFt4XVxuICAob3IgKGluc3RhbmNlPyBFcnJvciB4KVxuICAgICAgKGlkZW50aWNhbD8gKC5jYWxsIHRvLXN0cmluZyB4KSBcIltvYmplY3QgRXJyb3JdXCIpKSlcblxuKGRlZm4gXmJvb2xlYW4gc3RyaW5nP1xuICBcIlJldHVybiB0cnVlIGlmIHggaXMgYSBzdHJpbmdcIlxuICBbeF1cbiAgKG9yIChpZGVudGljYWw/ICh0eXBlb2YgeCkgXCJzdHJpbmdcIilcbiAgICAgIChpZGVudGljYWw/ICguY2FsbCB0by1zdHJpbmcgeCkgXCJbb2JqZWN0IFN0cmluZ11cIikpKVxuXG4oZGVmbiBeYm9vbGVhbiBudW1iZXI/XG4gIFwiUmV0dXJuIHRydWUgaWYgeCBpcyBhIG51bWJlclwiXG4gIFt4XVxuICAob3IgKGlkZW50aWNhbD8gKHR5cGVvZiB4KSBcIm51bWJlclwiKVxuICAgICAgKGlkZW50aWNhbD8gKC5jYWxsIHRvLXN0cmluZyB4KSBcIltvYmplY3QgTnVtYmVyXVwiKSkpXG5cbihkZWZcbiAgXns6dGFnIGJvb2xlYW5cbiAgICA6ZG9jIFwiUmV0dXJucyB0cnVlIGlmIHggaXMgYSB2ZWN0b3JcIn1cbiAgdmVjdG9yP1xuICAoaWYgKGZuPyBBcnJheS5pc0FycmF5KVxuICAgIEFycmF5LmlzQXJyYXlcbiAgICAoZm4gW3hdIChpZGVudGljYWw/ICguY2FsbCB0by1zdHJpbmcgeCkgXCJbb2JqZWN0IEFycmF5XVwiKSkpKVxuXG4oZGVmbiBeYm9vbGVhbiBkYXRlP1xuICBcIlJldHVybnMgdHJ1ZSBpZiB4IGlzIGEgZGF0ZVwiXG4gIFt4XVxuICAoaWRlbnRpY2FsPyAoLmNhbGwgdG8tc3RyaW5nIHgpIFwiW29iamVjdCBEYXRlXVwiKSlcblxuKGRlZm4gXmJvb2xlYW4gYm9vbGVhbj9cbiAgXCJSZXR1cm5zIHRydWUgaWYgeCBpcyBhIGJvb2xlYW5cIlxuICBbeF1cbiAgKG9yIChpZGVudGljYWw/IHggdHJ1ZSlcbiAgICAgIChpZGVudGljYWw/IHggZmFsc2UpXG4gICAgICAoaWRlbnRpY2FsPyAoLmNhbGwgdG8tc3RyaW5nIHgpIFwiW29iamVjdCBCb29sZWFuXVwiKSkpXG5cbihkZWZuIF5ib29sZWFuIHJlLXBhdHRlcm4/XG4gIFwiUmV0dXJucyB0cnVlIGlmIHggaXMgYSByZWd1bGFyIGV4cHJlc3Npb25cIlxuICBbeF1cbiAgKGlkZW50aWNhbD8gKC5jYWxsIHRvLXN0cmluZyB4KSBcIltvYmplY3QgUmVnRXhwXVwiKSlcblxuXG4oZGVmbiBeYm9vbGVhbiBvYmplY3Q/XG4gIFwiUmV0dXJucyB0cnVlIGlmIHggaXMgYW4gb2JqZWN0XCJcbiAgW3hdXG4gIChhbmQgeCAoaWRlbnRpY2FsPyAodHlwZW9mIHgpIFwib2JqZWN0XCIpKSlcblxuKGRlZm4gXmJvb2xlYW4gbmlsP1xuICBcIlJldHVybnMgdHJ1ZSBpZiB4IGlzIHVuZGVmaW5lZCBvciBudWxsXCJcbiAgW3hdXG4gIChvciAoaWRlbnRpY2FsPyB4IG5pbClcbiAgICAgIChpZGVudGljYWw/IHggbnVsbCkpKVxuXG4oZGVmbiBeYm9vbGVhbiB0cnVlP1xuICBcIlJldHVybnMgdHJ1ZSBpZiB4IGlzIHRydWVcIlxuICBbeF1cbiAgKGlkZW50aWNhbD8geCB0cnVlKSlcblxuKGRlZm4gXmJvb2xlYW4gZmFsc2U/XG4gIFwiUmV0dXJucyB0cnVlIGlmIHggaXMgZmFsc2VcIlxuICBbeF1cbiAgKGlkZW50aWNhbD8geCBmYWxzZSkpXG5cbihkZWZuIHJlLWZpbmRcbiAgXCJSZXR1cm5zIHRoZSBmaXJzdCByZWdleCBtYXRjaCwgaWYgYW55LCBvZiBzIHRvIHJlLCB1c2luZ1xuICByZS5leGVjKHMpLiBSZXR1cm5zIGEgdmVjdG9yLCBjb250YWluaW5nIGZpcnN0IHRoZSBtYXRjaGluZ1xuICBzdWJzdHJpbmcsIHRoZW4gYW55IGNhcHR1cmluZyBncm91cHMgaWYgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBjb250YWluc1xuICBjYXB0dXJpbmcgZ3JvdXBzLlwiXG4gIFtyZSBzXVxuICAobGV0IFttYXRjaGVzICguZXhlYyByZSBzKV1cbiAgICAoaWYgKG5vdCAobmlsPyBtYXRjaGVzKSlcbiAgICAgIChpZiAoaWRlbnRpY2FsPyAoLi1sZW5ndGggbWF0Y2hlcykgMSlcbiAgICAgICAgKGdldCBtYXRjaGVzIDApXG4gICAgICAgIG1hdGNoZXMpKSkpXG5cbihkZWZuIHJlLW1hdGNoZXNcbiAgW3BhdHRlcm4gc291cmNlXVxuICAobGV0IFttYXRjaGVzICguZXhlYyBwYXR0ZXJuIHNvdXJjZSldXG4gICAgKGlmIChhbmQgKG5vdCAobmlsPyBtYXRjaGVzKSlcbiAgICAgICAgICAgICAoaWRlbnRpY2FsPyAoZ2V0IG1hdGNoZXMgMCkgc291cmNlKSlcbiAgICAgIChpZiAoaWRlbnRpY2FsPyAoLi1sZW5ndGggbWF0Y2hlcykgMSlcbiAgICAgICAgKGdldCBtYXRjaGVzIDApXG4gICAgICAgIG1hdGNoZXMpKSkpXG5cbihkZWZuIHJlLXBhdHRlcm5cbiAgXCJSZXR1cm5zIGFuIGluc3RhbmNlIG9mIFJlZ0V4cCB3aGljaCBoYXMgY29tcGlsZWQgdGhlIHByb3ZpZGVkIHN0cmluZy5cIlxuICBbc11cbiAgKGxldCBbbWF0Y2ggKHJlLWZpbmQgI1wiXig/OlxcKFxcPyhbaWRtc3V4XSopXFwpKT8oLiopXCIgcyldXG4gICAgKG5ldyBSZWdFeHAgKGdldCBtYXRjaCAyKSAoZ2V0IG1hdGNoIDEpKSkpXG5cbihkZWZuIGluY1xuICBbeF1cbiAgKCsgeCAxKSlcblxuKGRlZm4gZGVjXG4gIFt4XVxuICAoLSB4IDEpKVxuXG4oZGVmbiBzdHJcbiAgXCJXaXRoIG5vIGFyZ3MsIHJldHVybnMgdGhlIGVtcHR5IHN0cmluZy4gV2l0aCBvbmUgYXJnIHgsIHJldHVybnNcbiAgeC50b1N0cmluZygpLiAgKHN0ciBuaWwpIHJldHVybnMgdGhlIGVtcHR5IHN0cmluZy4gV2l0aCBtb3JlIHRoYW5cbiAgb25lIGFyZywgcmV0dXJucyB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0aGUgc3RyIHZhbHVlcyBvZiB0aGUgYXJncy5cIlxuICBbXVxuICAoLmFwcGx5IFN0cmluZy5wcm90b3R5cGUuY29uY2F0IFwiXCIgYXJndW1lbnRzKSlcblxuKGRlZm4gY2hhclxuICBcIkNvZXJjZSB0byBjaGFyXCJcbiAgW2NvZGVdXG4gICguZnJvbUNoYXJDb2RlIFN0cmluZyBjb2RlKSlcblxuXG4oZGVmbiBpbnRcbiAgXCJDb2VyY2UgdG8gaW50IGJ5IHN0cmlwcGluZyBkZWNpbWFsIHBsYWNlcy5cIlxuICBbeF1cbiAgKGlmIChudW1iZXI/IHgpXG4gICAgKGlmICg+PSB4IDApXG4gICAgICAoLmZsb29yIE1hdGggeClcbiAgICAgICguZmxvb3IgTWF0aCB4KSlcbiAgICAoLmNoYXJDb2RlQXQgeCAwKSkpXG5cbihkZWZuIHN1YnNcbiAgXCJSZXR1cm5zIHRoZSBzdWJzdHJpbmcgb2YgcyBiZWdpbm5pbmcgYXQgc3RhcnQgaW5jbHVzaXZlLCBhbmQgZW5kaW5nXG4gIGF0IGVuZCAoZGVmYXVsdHMgdG8gbGVuZ3RoIG9mIHN0cmluZyksIGV4Y2x1c2l2ZS5cIlxuICB7OmFkZGVkIFwiMS4wXCJcbiAgIDpzdGF0aWMgdHJ1ZX1cbiAgIFtzdHJpbmcgc3RhcnQgZW5kXVxuICAgKC5zdWJzdHJpbmcgc3RyaW5nIHN0YXJ0IGVuZCkpXG5cbihkZWZuLSBeYm9vbGVhbiBwYXR0ZXJuLWVxdWFsP1xuICBbeCB5XVxuICAoYW5kIChyZS1wYXR0ZXJuPyB4KVxuICAgICAgIChyZS1wYXR0ZXJuPyB5KVxuICAgICAgIChpZGVudGljYWw/ICguLXNvdXJjZSB4KSAoLi1zb3VyY2UgeSkpXG4gICAgICAgKGlkZW50aWNhbD8gKC4tZ2xvYmFsIHgpICguLWdsb2JhbCB5KSlcbiAgICAgICAoaWRlbnRpY2FsPyAoLi1tdWx0aWxpbmUgeCkgKC4tbXVsdGlsaW5lIHkpKVxuICAgICAgIChpZGVudGljYWw/ICguLWlnbm9yZUNhc2UgeCkgKC4taWdub3JlQ2FzZSB5KSkpKVxuXG4oZGVmbi0gXmJvb2xlYW4gZGF0ZS1lcXVhbD9cbiAgW3ggeV1cbiAgKGFuZCAoZGF0ZT8geClcbiAgICAgICAoZGF0ZT8geSlcbiAgICAgICAoaWRlbnRpY2FsPyAoTnVtYmVyIHgpIChOdW1iZXIgeSkpKSlcblxuXG4oZGVmbi0gXmJvb2xlYW4gZGljdGlvbmFyeS1lcXVhbD9cbiAgW3ggeV1cbiAgKGFuZCAob2JqZWN0PyB4KVxuICAgICAgIChvYmplY3Q/IHkpXG4gICAgICAgKGxldCBbeC1rZXlzIChrZXlzIHgpXG4gICAgICAgICAgICAgeS1rZXlzIChrZXlzIHkpXG4gICAgICAgICAgICAgeC1jb3VudCAoLi1sZW5ndGggeC1rZXlzKVxuICAgICAgICAgICAgIHktY291bnQgKC4tbGVuZ3RoIHkta2V5cyldXG4gICAgICAgICAoYW5kIChpZGVudGljYWw/IHgtY291bnQgeS1jb3VudClcbiAgICAgICAgICAgICAgKGxvb3AgW2luZGV4IDBcbiAgICAgICAgICAgICAgICAgICAgIGNvdW50IHgtY291bnRcbiAgICAgICAgICAgICAgICAgICAgIGtleXMgeC1rZXlzXVxuICAgICAgICAgICAgICAgIChpZiAoPCBpbmRleCBjb3VudClcbiAgICAgICAgICAgICAgICAgIChpZiAoZXF1aXZhbGVudD8gKGdldCB4IChnZXQga2V5cyBpbmRleCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChnZXQgeSAoZ2V0IGtleXMgaW5kZXgpKSlcbiAgICAgICAgICAgICAgICAgICAgKHJlY3VyIChpbmMgaW5kZXgpIGNvdW50IGtleXMpXG4gICAgICAgICAgICAgICAgICAgIGZhbHNlKVxuICAgICAgICAgICAgICAgICAgdHJ1ZSkpKSkpKVxuXG4oZGVmbi0gXmJvb2xlYW4gdmVjdG9yLWVxdWFsP1xuICBbeCB5XVxuICAoYW5kICh2ZWN0b3I/IHgpXG4gICAgICAgKHZlY3Rvcj8geSlcbiAgICAgICAoaWRlbnRpY2FsPyAoLi1sZW5ndGggeCkgKC4tbGVuZ3RoIHkpKVxuICAgICAgIChsb29wIFt4cyB4XG4gICAgICAgICAgICAgIHlzIHlcbiAgICAgICAgICAgICAgaW5kZXggMFxuICAgICAgICAgICAgICBjb3VudCAoLi1sZW5ndGggeCldXG4gICAgICAgIChpZiAoPCBpbmRleCBjb3VudClcbiAgICAgICAgICAoaWYgKGVxdWl2YWxlbnQ/IChnZXQgeHMgaW5kZXgpIChnZXQgeXMgaW5kZXgpKVxuICAgICAgICAgICAgICAocmVjdXIgeHMgeXMgKGluYyBpbmRleCkgY291bnQpXG4gICAgICAgICAgICAgIGZhbHNlKVxuICAgICAgICAgIHRydWUpKSkpXG5cbihkZWZuLSBeYm9vbGVhbiBlcXVpdmFsZW50P1xuICBcIkVxdWFsaXR5LiBSZXR1cm5zIHRydWUgaWYgeCBlcXVhbHMgeSwgZmFsc2UgaWYgbm90LiBDb21wYXJlc1xuICBudW1iZXJzIGFuZCBjb2xsZWN0aW9ucyBpbiBhIHR5cGUtaW5kZXBlbmRlbnQgbWFubmVyLiBDbG9qdXJlJ3NcbiAgaW1tdXRhYmxlIGRhdGEgc3RydWN0dXJlcyBkZWZpbmUgLWVxdWl2IChhbmQgdGh1cyA9KSBhcyBhIHZhbHVlLFxuICBub3QgYW4gaWRlbnRpdHksIGNvbXBhcmlzb24uXCJcbiAgKFt4XSB0cnVlKVxuICAoW3ggeV0gKG9yIChpZGVudGljYWw/IHggeSlcbiAgICAgICAgICAgICAoY29uZCAobmlsPyB4KSAobmlsPyB5KVxuICAgICAgICAgICAgICAgICAgIChuaWw/IHkpIChuaWw/IHgpXG4gICAgICAgICAgICAgICAgICAgKHN0cmluZz8geCkgKGFuZCAoc3RyaW5nPyB5KSAoaWRlbnRpY2FsPyAoLnRvU3RyaW5nIHgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoLnRvU3RyaW5nIHkpKSlcbiAgICAgICAgICAgICAgICAgICAobnVtYmVyPyB4KSAoYW5kIChudW1iZXI/IHkpIChpZGVudGljYWw/ICgudmFsdWVPZiB4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKC52YWx1ZU9mIHkpKSlcbiAgICAgICAgICAgICAgICAgICAoZm4/IHgpIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgKGJvb2xlYW4/IHgpIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgKGRhdGU/IHgpIChkYXRlLWVxdWFsPyB4IHkpXG4gICAgICAgICAgICAgICAgICAgKHZlY3Rvcj8geCkgKHZlY3Rvci1lcXVhbD8geCB5IFtdIFtdKVxuICAgICAgICAgICAgICAgICAgIChyZS1wYXR0ZXJuPyB4KSAocGF0dGVybi1lcXVhbD8geCB5KVxuICAgICAgICAgICAgICAgICAgIDplbHNlIChkaWN0aW9uYXJ5LWVxdWFsPyB4IHkpKSkpXG4gIChbeCB5ICYgbW9yZV1cbiAgIChsb29wIFtwcmV2aW91cyB4XG4gICAgICAgICAgY3VycmVudCB5XG4gICAgICAgICAgaW5kZXggMFxuICAgICAgICAgIGNvdW50ICguLWxlbmd0aCBtb3JlKV1cbiAgICAoYW5kIChlcXVpdmFsZW50PyBwcmV2aW91cyBjdXJyZW50KVxuICAgICAgICAgKGlmICg8IGluZGV4IGNvdW50KVxuICAgICAgICAgIChyZWN1ciBjdXJyZW50XG4gICAgICAgICAgICAgICAgIChnZXQgbW9yZSBpbmRleClcbiAgICAgICAgICAgICAgICAgKGluYyBpbmRleClcbiAgICAgICAgICAgICAgICAgY291bnQpXG4gICAgICAgICAgdHJ1ZSkpKSkpXG5cbihkZWYgPSBlcXVpdmFsZW50PylcblxuKGRlZm4gXmJvb2xlYW4gPT1cbiAgXCJFcXVhbGl0eS4gUmV0dXJucyB0cnVlIGlmIHggZXF1YWxzIHksIGZhbHNlIGlmIG5vdC4gQ29tcGFyZXNcbiAgbnVtYmVycyBhbmQgY29sbGVjdGlvbnMgaW4gYSB0eXBlLWluZGVwZW5kZW50IG1hbm5lci4gQ2xvanVyZSdzXG4gIGltbXV0YWJsZSBkYXRhIHN0cnVjdHVyZXMgZGVmaW5lIC1lcXVpdiAoYW5kIHRodXMgPSkgYXMgYSB2YWx1ZSxcbiAgbm90IGFuIGlkZW50aXR5LCBjb21wYXJpc29uLlwiXG4gIChbeF0gdHJ1ZSlcbiAgKFt4IHldIChpZGVudGljYWw/IHggeSkpXG4gIChbeCB5ICYgbW9yZV1cbiAgIChsb29wIFtwcmV2aW91cyB4XG4gICAgICAgICAgY3VycmVudCB5XG4gICAgICAgICAgaW5kZXggMFxuICAgICAgICAgIGNvdW50ICguLWxlbmd0aCBtb3JlKV1cbiAgICAoYW5kICg9PSBwcmV2aW91cyBjdXJyZW50KVxuICAgICAgICAgKGlmICg8IGluZGV4IGNvdW50KVxuICAgICAgICAgIChyZWN1ciBjdXJyZW50XG4gICAgICAgICAgICAgICAgIChnZXQgbW9yZSBpbmRleClcbiAgICAgICAgICAgICAgICAgKGluYyBpbmRleClcbiAgICAgICAgICAgICAgICAgY291bnQpXG4gICAgICAgICAgdHJ1ZSkpKSkpXG5cblxuKGRlZm4gXmJvb2xlYW4gPlxuICBcIlJldHVybnMgbm9uLW5pbCBpZiBudW1zIGFyZSBpbiBtb25vdG9uaWNhbGx5IGRlY3JlYXNpbmcgb3JkZXIsXG4gIG90aGVyd2lzZSBmYWxzZS5cIlxuICAoW3hdIHRydWUpXG4gIChbeCB5XSAoPiB4IHkpKVxuICAoW3ggeSAmIG1vcmVdXG4gICAobG9vcCBbcHJldmlvdXMgeFxuICAgICAgICAgIGN1cnJlbnQgeVxuICAgICAgICAgIGluZGV4IDBcbiAgICAgICAgICBjb3VudCAoLi1sZW5ndGggbW9yZSldXG4gICAgKGFuZCAoPiBwcmV2aW91cyBjdXJyZW50KVxuICAgICAgICAgKGlmICg8IGluZGV4IGNvdW50KVxuICAgICAgICAgIChyZWN1ciBjdXJyZW50XG4gICAgICAgICAgICAgICAgIChnZXQgbW9yZSBpbmRleClcbiAgICAgICAgICAgICAgICAgKGluYyBpbmRleClcbiAgICAgICAgICAgICAgICAgY291bnQpXG4gICAgICAgICAgdHJ1ZSkpKSkpXG5cbihkZWZuIF5ib29sZWFuID49XG4gIFwiUmV0dXJucyBub24tbmlsIGlmIG51bXMgYXJlIGluIG1vbm90b25pY2FsbHkgZGVjcmVhc2luZyBvcmRlcixcbiAgb3RoZXJ3aXNlIGZhbHNlLlwiXG4gIChbeF0gdHJ1ZSlcbiAgKFt4IHldICg+PSB4IHkpKVxuICAoW3ggeSAmIG1vcmVdXG4gICAobG9vcCBbcHJldmlvdXMgeFxuICAgICAgICAgIGN1cnJlbnQgeVxuICAgICAgICAgIGluZGV4IDBcbiAgICAgICAgICBjb3VudCAoLi1sZW5ndGggbW9yZSldXG4gICAgKGFuZCAoPj0gcHJldmlvdXMgY3VycmVudClcbiAgICAgICAgIChpZiAoPCBpbmRleCBjb3VudClcbiAgICAgICAgICAocmVjdXIgY3VycmVudFxuICAgICAgICAgICAgICAgICAoZ2V0IG1vcmUgaW5kZXgpXG4gICAgICAgICAgICAgICAgIChpbmMgaW5kZXgpXG4gICAgICAgICAgICAgICAgIGNvdW50KVxuICAgICAgICAgIHRydWUpKSkpKVxuXG5cbihkZWZuIF5ib29sZWFuIDxcbiAgXCJSZXR1cm5zIG5vbi1uaWwgaWYgbnVtcyBhcmUgaW4gbW9ub3RvbmljYWxseSBkZWNyZWFzaW5nIG9yZGVyLFxuICBvdGhlcndpc2UgZmFsc2UuXCJcbiAgKFt4XSB0cnVlKVxuICAoW3ggeV0gKDwgeCB5KSlcbiAgKFt4IHkgJiBtb3JlXVxuICAgKGxvb3AgW3ByZXZpb3VzIHhcbiAgICAgICAgICBjdXJyZW50IHlcbiAgICAgICAgICBpbmRleCAwXG4gICAgICAgICAgY291bnQgKC4tbGVuZ3RoIG1vcmUpXVxuICAgIChhbmQgKDwgcHJldmlvdXMgY3VycmVudClcbiAgICAgICAgIChpZiAoPCBpbmRleCBjb3VudClcbiAgICAgICAgICAocmVjdXIgY3VycmVudFxuICAgICAgICAgICAgICAgICAoZ2V0IG1vcmUgaW5kZXgpXG4gICAgICAgICAgICAgICAgIChpbmMgaW5kZXgpXG4gICAgICAgICAgICAgICAgIGNvdW50KVxuICAgICAgICAgIHRydWUpKSkpKVxuXG5cbihkZWZuIF5ib29sZWFuIDw9XG4gIFwiUmV0dXJucyBub24tbmlsIGlmIG51bXMgYXJlIGluIG1vbm90b25pY2FsbHkgZGVjcmVhc2luZyBvcmRlcixcbiAgb3RoZXJ3aXNlIGZhbHNlLlwiXG4gIChbeF0gdHJ1ZSlcbiAgKFt4IHldICg8PSB4IHkpKVxuICAoW3ggeSAmIG1vcmVdXG4gICAobG9vcCBbcHJldmlvdXMgeFxuICAgICAgICAgIGN1cnJlbnQgeVxuICAgICAgICAgIGluZGV4IDBcbiAgICAgICAgICBjb3VudCAoLi1sZW5ndGggbW9yZSldXG4gICAgKGFuZCAoPD0gcHJldmlvdXMgY3VycmVudClcbiAgICAgICAgIChpZiAoPCBpbmRleCBjb3VudClcbiAgICAgICAgICAocmVjdXIgY3VycmVudFxuICAgICAgICAgICAgICAgICAoZ2V0IG1vcmUgaW5kZXgpXG4gICAgICAgICAgICAgICAgIChpbmMgaW5kZXgpXG4gICAgICAgICAgICAgICAgIGNvdW50KVxuICAgICAgICAgIHRydWUpKSkpKVxuXG4oZGVmbiBeYm9vbGVhbiArXG4gIChbXSAwKVxuICAoW2FdIGEpXG4gIChbYSBiXSAoKyBhIGIpKVxuICAoW2EgYiBjXSAoKyBhIGIgYykpXG4gIChbYSBiIGMgZF0gKCsgYSBiIGMgZCkpXG4gIChbYSBiIGMgZCBlXSAoKyBhIGIgYyBkIGUpKVxuICAoW2EgYiBjIGQgZSBmXSAoKyBhIGIgYyBkIGUgZikpXG4gIChbYSBiIGMgZCBlIGYgJiBtb3JlXVxuICAgKGxvb3AgW3ZhbHVlICgrIGEgYiBjIGQgZSBmKVxuICAgICAgICAgIGluZGV4IDBcbiAgICAgICAgICBjb3VudCAoLi1sZW5ndGggbW9yZSldXG4gICAgIChpZiAoPCBpbmRleCBjb3VudClcbiAgICAgICAocmVjdXIgKCsgdmFsdWUgKGdldCBtb3JlIGluZGV4KSlcbiAgICAgICAgICAgICAgKGluYyBpbmRleClcbiAgICAgICAgICAgICAgY291bnQpXG4gICAgICAgdmFsdWUpKSkpXG5cbihkZWZuIF5ib29sZWFuIC1cbiAgKFtdICh0aHJvdyAoVHlwZUVycm9yIFwiV3JvbmcgbnVtYmVyIG9mIGFyZ3MgcGFzc2VkIHRvOiAtXCIpKSlcbiAgKFthXSAoLSAwIGEpKVxuICAoW2EgYl0gKC0gYSBiKSlcbiAgKFthIGIgY10gKC0gYSBiIGMpKVxuICAoW2EgYiBjIGRdICgtIGEgYiBjIGQpKVxuICAoW2EgYiBjIGQgZV0gKC0gYSBiIGMgZCBlKSlcbiAgKFthIGIgYyBkIGUgZl0gKC0gYSBiIGMgZCBlIGYpKVxuICAoW2EgYiBjIGQgZSBmICYgbW9yZV1cbiAgIChsb29wIFt2YWx1ZSAoLSBhIGIgYyBkIGUgZilcbiAgICAgICAgICBpbmRleCAwXG4gICAgICAgICAgY291bnQgKC4tbGVuZ3RoIG1vcmUpXVxuICAgICAoaWYgKDwgaW5kZXggY291bnQpXG4gICAgICAgKHJlY3VyICgtIHZhbHVlIChnZXQgbW9yZSBpbmRleCkpXG4gICAgICAgICAgICAgIChpbmMgaW5kZXgpXG4gICAgICAgICAgICAgIGNvdW50KVxuICAgICAgIHZhbHVlKSkpKVxuXG4oZGVmbiBeYm9vbGVhbiAvXG4gIChbXSAodGhyb3cgKFR5cGVFcnJvciBcIldyb25nIG51bWJlciBvZiBhcmdzIHBhc3NlZCB0bzogL1wiKSkpXG4gIChbYV0gKC8gMSBhKSlcbiAgKFthIGJdICgvIGEgYikpXG4gIChbYSBiIGNdICgvIGEgYiBjKSlcbiAgKFthIGIgYyBkXSAoLyBhIGIgYyBkKSlcbiAgKFthIGIgYyBkIGVdICgvIGEgYiBjIGQgZSkpXG4gIChbYSBiIGMgZCBlIGZdICgvIGEgYiBjIGQgZSBmKSlcbiAgKFthIGIgYyBkIGUgZiAmIG1vcmVdXG4gICAobG9vcCBbdmFsdWUgKC8gYSBiIGMgZCBlIGYpXG4gICAgICAgICAgaW5kZXggMFxuICAgICAgICAgIGNvdW50ICguLWxlbmd0aCBtb3JlKV1cbiAgICAgKGlmICg8IGluZGV4IGNvdW50KVxuICAgICAgIChyZWN1ciAoLyB2YWx1ZSAoZ2V0IG1vcmUgaW5kZXgpKVxuICAgICAgICAgICAgICAoaW5jIGluZGV4KVxuICAgICAgICAgICAgICBjb3VudClcbiAgICAgICB2YWx1ZSkpKSlcblxuKGRlZm4gXmJvb2xlYW4gKlxuICAoW10gMSlcbiAgKFthXSBhKVxuICAoW2EgYl0gKCogYSBiKSlcbiAgKFthIGIgY10gKCogYSBiIGMpKVxuICAoW2EgYiBjIGRdICgqIGEgYiBjIGQpKVxuICAoW2EgYiBjIGQgZV0gKCogYSBiIGMgZCBlKSlcbiAgKFthIGIgYyBkIGUgZl0gKCogYSBiIGMgZCBlIGYpKVxuICAoW2EgYiBjIGQgZSBmICYgbW9yZV1cbiAgIChsb29wIFt2YWx1ZSAoKiBhIGIgYyBkIGUgZilcbiAgICAgICAgICBpbmRleCAwXG4gICAgICAgICAgY291bnQgKC4tbGVuZ3RoIG1vcmUpXVxuICAgICAoaWYgKDwgaW5kZXggY291bnQpXG4gICAgICAgKHJlY3VyICgqIHZhbHVlIChnZXQgbW9yZSBpbmRleCkpXG4gICAgICAgICAgICAgIChpbmMgaW5kZXgpXG4gICAgICAgICAgICAgIGNvdW50KVxuICAgICAgIHZhbHVlKSkpKVxuXG4oZGVmbiBeYm9vbGVhbiBhbmRcbiAgKFtdIHRydWUpXG4gIChbYV0gYSlcbiAgKFthIGJdIChhbmQgYSBiKSlcbiAgKFthIGIgY10gKGFuZCBhIGIgYykpXG4gIChbYSBiIGMgZF0gKGFuZCBhIGIgYyBkKSlcbiAgKFthIGIgYyBkIGVdIChhbmQgYSBiIGMgZCBlKSlcbiAgKFthIGIgYyBkIGUgZl0gKGFuZCBhIGIgYyBkIGUgZikpXG4gIChbYSBiIGMgZCBlIGYgJiBtb3JlXVxuICAgKGxvb3AgW3ZhbHVlIChhbmQgYSBiIGMgZCBlIGYpXG4gICAgICAgICAgaW5kZXggMFxuICAgICAgICAgIGNvdW50ICguLWxlbmd0aCBtb3JlKV1cbiAgICAgKGlmICg8IGluZGV4IGNvdW50KVxuICAgICAgIChyZWN1ciAoYW5kIHZhbHVlIChnZXQgbW9yZSBpbmRleCkpXG4gICAgICAgICAgICAgIChpbmMgaW5kZXgpXG4gICAgICAgICAgICAgIGNvdW50KVxuICAgICAgIHZhbHVlKSkpKVxuXG4oZGVmbiBeYm9vbGVhbiBvclxuICAoW10gbmlsKVxuICAoW2FdIGEpXG4gIChbYSBiXSAob3IgYSBiKSlcbiAgKFthIGIgY10gKG9yIGEgYiBjKSlcbiAgKFthIGIgYyBkXSAob3IgYSBiIGMgZCkpXG4gIChbYSBiIGMgZCBlXSAob3IgYSBiIGMgZCBlKSlcbiAgKFthIGIgYyBkIGUgZl0gKG9yIGEgYiBjIGQgZSBmKSlcbiAgKFthIGIgYyBkIGUgZiAmIG1vcmVdXG4gICAobG9vcCBbdmFsdWUgKG9yIGEgYiBjIGQgZSBmKVxuICAgICAgICAgIGluZGV4IDBcbiAgICAgICAgICBjb3VudCAoLi1sZW5ndGggbW9yZSldXG4gICAgIChpZiAoPCBpbmRleCBjb3VudClcbiAgICAgICAocmVjdXIgKG9yIHZhbHVlIChnZXQgbW9yZSBpbmRleCkpXG4gICAgICAgICAgICAgIChpbmMgaW5kZXgpXG4gICAgICAgICAgICAgIGNvdW50KVxuICAgICAgIHZhbHVlKSkpKVxuXG4oZGVmbiBwcmludFxuICBbJiBtb3JlXVxuICAoYXBwbHkgY29uc29sZS5sb2cgbW9yZSkpXG5cbihkZWYgbWF4IE1hdGgubWF4KVxuKGRlZiBtaW4gTWF0aC5taW4pXG4oZGVmIG5hbj8gaXNOYU4pXG4iXX0=

},{}],"Mdzbzt":[function(require,module,exports){
{
    var _ns_ = {
            id: 'wisp.sequence',
            doc: void 0
        };
    var wisp_runtime = require('./runtime');
    var isNil = wisp_runtime.isNil;
    var isVector = wisp_runtime.isVector;
    var isFn = wisp_runtime.isFn;
    var isNumber = wisp_runtime.isNumber;
    var isString = wisp_runtime.isString;
    var isDictionary = wisp_runtime.isDictionary;
    var keyValues = wisp_runtime.keyValues;
    var str = wisp_runtime.str;
    var dec = wisp_runtime.dec;
    var inc = wisp_runtime.inc;
    var merge = wisp_runtime.merge;
    var dictionary = wisp_runtime.dictionary;
}
var List = function List(head, tail) {
    this.head = head;
    this.tail = tail || list();
    this.length = inc(count(this.tail));
    return this;
};
List.prototype.length = 0;
List.type = 'wisp.list';
List.prototype.type = List.type;
List.prototype.tail = Object.create(List.prototype);
List.prototype.toString = function () {
    return function loop() {
        var recur = loop;
        var resultø1 = '';
        var listø1 = this;
        do {
            recur = isEmpty(listø1) ? '' + '(' + resultø1.substr(1) + ')' : (loop[0] = '' + resultø1 + ' ' + (isVector(first(listø1)) ? '' + '[' + first(listø1).join(' ') + ']' : isNil(first(listø1)) ? 'nil' : isString(first(listø1)) ? JSON.stringify(first(listø1)) : isNumber(first(listø1)) ? JSON.stringify(first(listø1)) : first(listø1)), loop[1] = rest(listø1), loop);
        } while (resultø1 = loop[0], listø1 = loop[1], recur === loop);
        return recur;
    }.call(this);
};
var lazySeqValue = function lazySeqValue(lazySeq) {
    return !lazySeq.realized ? (lazySeq.realized = true) && (lazySeq.x = lazySeq.x()) : lazySeq.x;
};
var LazySeq = function LazySeq(realized, x) {
    this.realized = realized || false;
    this.x = x;
    return this;
};
LazySeq.type = 'wisp.lazy.seq';
LazySeq.prototype.type = LazySeq.type;
var lazySeq = exports.lazySeq = function lazySeq(realized, body) {
        return new LazySeq(realized, body);
    };
var isLazySeq = exports.isLazySeq = function isLazySeq(value) {
        return value && LazySeq.type === value.type;
    };
var isList = exports.isList = function isList(value) {
        return value && List.type === value.type;
    };
var list = exports.list = function list() {
        return arguments.length === 0 ? Object.create(List.prototype) : Array.prototype.slice.call(arguments).reduceRight(function (tail, head) {
            return cons(head, tail);
        }, list());
    };
var cons = exports.cons = function cons(head, tail) {
        return new List(head, tail);
    };
var reverseList = function reverseList(sequence) {
    return function loop() {
        var recur = loop;
        var itemsø1 = [];
        var sourceø1 = sequence;
        do {
            recur = isEmpty(sourceø1) ? list.apply(void 0, itemsø1) : (loop[0] = [first(sourceø1)].concat(itemsø1), loop[1] = rest(sourceø1), loop);
        } while (itemsø1 = loop[0], sourceø1 = loop[1], recur === loop);
        return recur;
    }.call(this);
};
var isSequential = exports.isSequential = function isSequential(x) {
        return isList(x) || isVector(x) || isLazySeq(x) || isDictionary(x) || isString(x);
    };
var reverse = exports.reverse = function reverse(sequence) {
        return isList(sequence) ? reverseList(sequence) : isVector(sequence) ? sequence.reverse() : isNil(sequence) ? list() : 'else' ? reverse(seq(sequence)) : void 0;
    };
var map = exports.map = function map(f, sequence) {
        return isVector(sequence) ? sequence.map(function ($1) {
            return f($1);
        }) : isList(sequence) ? mapList(f, sequence) : isNil(sequence) ? list() : 'else' ? map(f, seq(sequence)) : void 0;
    };
var mapList = function mapList(f, sequence) {
    return function loop() {
        var recur = loop;
        var resultø1 = list();
        var itemsø1 = sequence;
        do {
            recur = isEmpty(itemsø1) ? reverse(resultø1) : (loop[0] = cons(f(first(itemsø1)), resultø1), loop[1] = rest(itemsø1), loop);
        } while (resultø1 = loop[0], itemsø1 = loop[1], recur === loop);
        return recur;
    }.call(this);
};
var filter = exports.filter = function filter(isF, sequence) {
        return isVector(sequence) ? sequence.filter(isF) : isList(sequence) ? filterList(isF, sequence) : isNil(sequence) ? list() : 'else' ? filter(isF, seq(sequence)) : void 0;
    };
var filterList = function filterList(isF, sequence) {
    return function loop() {
        var recur = loop;
        var resultø1 = list();
        var itemsø1 = sequence;
        do {
            recur = isEmpty(itemsø1) ? reverse(resultø1) : (loop[0] = isF(first(itemsø1)) ? cons(first(itemsø1), resultø1) : resultø1, loop[1] = rest(itemsø1), loop);
        } while (resultø1 = loop[0], itemsø1 = loop[1], recur === loop);
        return recur;
    }.call(this);
};
var reduce = exports.reduce = function reduce(f) {
        var params = Array.prototype.slice.call(arguments, 1);
        return function () {
            var hasInitialø1 = count(params) >= 2;
            var initialø1 = hasInitialø1 ? first(params) : void 0;
            var sequenceø1 = hasInitialø1 ? second(params) : first(params);
            return isNil(sequenceø1) ? initialø1 : isVector(sequenceø1) ? hasInitialø1 ? sequenceø1.reduce(f, initialø1) : sequenceø1.reduce(f) : isList(sequenceø1) ? hasInitialø1 ? reduceList(f, initialø1, sequenceø1) : reduceList(f, first(sequenceø1), rest(sequenceø1)) : 'else' ? reduce(f, initialø1, seq(sequenceø1)) : void 0;
        }.call(this);
    };
var reduceList = function reduceList(f, initial, sequence) {
    return function loop() {
        var recur = loop;
        var resultø1 = initial;
        var itemsø1 = sequence;
        do {
            recur = isEmpty(itemsø1) ? resultø1 : (loop[0] = f(resultø1, first(itemsø1)), loop[1] = rest(itemsø1), loop);
        } while (resultø1 = loop[0], itemsø1 = loop[1], recur === loop);
        return recur;
    }.call(this);
};
var count = exports.count = function count(sequence) {
        return isNil(sequence) ? 0 : seq(sequence).length;
    };
var isEmpty = exports.isEmpty = function isEmpty(sequence) {
        return count(sequence) === 0;
    };
var first = exports.first = function first(sequence) {
        return isNil(sequence) ? void 0 : isList(sequence) ? sequence.head : isVector(sequence) || isString(sequence) ? (sequence || 0)[0] : isLazySeq(sequence) ? first(lazySeqValue(sequence)) : 'else' ? first(seq(sequence)) : void 0;
    };
var second = exports.second = function second(sequence) {
        return isNil(sequence) ? void 0 : isList(sequence) ? first(rest(sequence)) : isVector(sequence) || isString(sequence) ? (sequence || 0)[1] : isLazySeq(sequence) ? second(lazySeqValue(sequence)) : 'else' ? first(rest(seq(sequence))) : void 0;
    };
var third = exports.third = function third(sequence) {
        return isNil(sequence) ? void 0 : isList(sequence) ? first(rest(rest(sequence))) : isVector(sequence) || isString(sequence) ? (sequence || 0)[2] : isLazySeq(sequence) ? third(lazySeqValue(sequence)) : 'else' ? second(rest(seq(sequence))) : void 0;
    };
var rest = exports.rest = function rest(sequence) {
        return isNil(sequence) ? list() : isList(sequence) ? sequence.tail : isVector(sequence) || isString(sequence) ? sequence.slice(1) : isLazySeq(sequence) ? rest(lazySeqValue(sequence)) : 'else' ? rest(seq(sequence)) : void 0;
    };
var lastOfList = function lastOfList(list) {
    return function loop() {
        var recur = loop;
        var itemø1 = first(list);
        var itemsø1 = rest(list);
        do {
            recur = isEmpty(itemsø1) ? itemø1 : (loop[0] = first(itemsø1), loop[1] = rest(itemsø1), loop);
        } while (itemø1 = loop[0], itemsø1 = loop[1], recur === loop);
        return recur;
    }.call(this);
};
var last = exports.last = function last(sequence) {
        return isVector(sequence) || isString(sequence) ? (sequence || 0)[dec(count(sequence))] : isList(sequence) ? lastOfList(sequence) : isNil(sequence) ? void 0 : isLazySeq(sequence) ? last(lazySeqValue(sequence)) : 'else' ? last(seq(sequence)) : void 0;
    };
var butlast = exports.butlast = function butlast(sequence) {
        return function () {
            var itemsø1 = isNil(sequence) ? void 0 : isString(sequence) ? subs(sequence, 0, dec(count(sequence))) : isVector(sequence) ? sequence.slice(0, dec(count(sequence))) : isList(sequence) ? list.apply(void 0, butlast(vec(sequence))) : isLazySeq(sequence) ? butlast(lazySeqValue(sequence)) : 'else' ? butlast(seq(sequence)) : void 0;
            return !(isNil(itemsø1) || isEmpty(itemsø1)) ? itemsø1 : void 0;
        }.call(this);
    };
var take = exports.take = function take(n, sequence) {
        return isNil(sequence) ? list() : isVector(sequence) ? takeFromVector(n, sequence) : isList(sequence) ? takeFromList(n, sequence) : isLazySeq(sequence) ? take(n, lazySeqValue(sequence)) : 'else' ? take(n, seq(sequence)) : void 0;
    };
var takeVectorWhile = function takeVectorWhile(predicate, vector) {
    return function loop() {
        var recur = loop;
        var resultø1 = [];
        var tailø1 = vector;
        var headø1 = first(vector);
        do {
            recur = !isEmpty(tailø1) && predicate(headø1) ? (loop[0] = conj(resultø1, headø1), loop[1] = rest(tailø1), loop[2] = first(tailø1), loop) : resultø1;
        } while (resultø1 = loop[0], tailø1 = loop[1], headø1 = loop[2], recur === loop);
        return recur;
    }.call(this);
};
var takeListWhile = function takeListWhile(predicate, items) {
    return function loop() {
        var recur = loop;
        var resultø1 = [];
        var tailø1 = items;
        var headø1 = first(items);
        do {
            recur = !isEmpty(tailø1) && isPredicate(headø1) ? (loop[0] = conj(resultø1, headø1), loop[1] = rest(tailø1), loop[2] = first(tailø1), loop) : list.apply(void 0, resultø1);
        } while (resultø1 = loop[0], tailø1 = loop[1], headø1 = loop[2], recur === loop);
        return recur;
    }.call(this);
};
var takeWhile = exports.takeWhile = function takeWhile(predicate, sequence) {
        return isNil(sequence) ? list() : isVector(sequence) ? takeVectorWhile(predicate, sequence) : isList(sequence) ? takeVectorWhile(predicate, sequence) : 'else' ? takeWhile(predicate, lazySeqValue(sequence)) : void 0;
    };
var takeFromVector = function takeFromVector(n, vector) {
    return vector.slice(0, n);
};
var takeFromList = function takeFromList(n, sequence) {
    return function loop() {
        var recur = loop;
        var takenø1 = list();
        var itemsø1 = sequence;
        var nø2 = n;
        do {
            recur = nø2 === 0 || isEmpty(itemsø1) ? reverse(takenø1) : (loop[0] = cons(first(itemsø1), takenø1), loop[1] = rest(itemsø1), loop[2] = dec(nø2), loop);
        } while (takenø1 = loop[0], itemsø1 = loop[1], nø2 = loop[2], recur === loop);
        return recur;
    }.call(this);
};
var dropFromList = function dropFromList(n, sequence) {
    return function loop() {
        var recur = loop;
        var leftø1 = n;
        var itemsø1 = sequence;
        do {
            recur = leftø1 < 1 || isEmpty(itemsø1) ? itemsø1 : (loop[0] = dec(leftø1), loop[1] = rest(itemsø1), loop);
        } while (leftø1 = loop[0], itemsø1 = loop[1], recur === loop);
        return recur;
    }.call(this);
};
var drop = exports.drop = function drop(n, sequence) {
        return n <= 0 ? sequence : isString(sequence) ? sequence.substr(n) : isVector(sequence) ? sequence.slice(n) : isList(sequence) ? dropFromList(n, sequence) : isNil(sequence) ? list() : isLazySeq(sequence) ? drop(n, lazySeqValue(sequence)) : 'else' ? drop(n, seq(sequence)) : void 0;
    };
var conjList = function conjList(sequence, items) {
    return reduce(function (result, item) {
        return cons(item, result);
    }, sequence, items);
};
var conj = exports.conj = function conj(sequence) {
        var items = Array.prototype.slice.call(arguments, 1);
        return isVector(sequence) ? sequence.concat(items) : isString(sequence) ? '' + sequence + str.apply(void 0, items) : isNil(sequence) ? list.apply(void 0, reverse(items)) : isList(sequence) || isLazySeq() ? conjList(sequence, items) : isDictionary(sequence) ? merge(sequence, merge.apply(void 0, items)) : 'else' ? (function () {
            throw TypeError('' + 'Type can\'t be conjoined ' + sequence);
        })() : void 0;
    };
var assoc = exports.assoc = function assoc(source) {
        var keyValues = Array.prototype.slice.call(arguments, 1);
        return conj(source, dictionary.apply(void 0, keyValues));
    };
var concat = exports.concat = function concat() {
        var sequences = Array.prototype.slice.call(arguments, 0);
        return reverse(reduce(function (result, sequence) {
            return reduce(function (result, item) {
                return cons(item, result);
            }, result, seq(sequence));
        }, list(), sequences));
    };
var seq = exports.seq = function seq(sequence) {
        return isNil(sequence) ? void 0 : isVector(sequence) || isList(sequence) || isLazySeq(sequence) ? sequence : isString(sequence) ? Array.prototype.slice.call(sequence) : isDictionary(sequence) ? keyValues(sequence) : 'default' ? (function () {
            throw TypeError('' + 'Can not seq ' + sequence);
        })() : void 0;
    };
var isSeq = exports.isSeq = function isSeq(sequence) {
        return isList(sequence) || isLazySeq(sequence);
    };
var listToVector = function listToVector(source) {
    return function loop() {
        var recur = loop;
        var resultø1 = [];
        var listø1 = source;
        do {
            recur = isEmpty(listø1) ? resultø1 : (loop[0] = (function () {
                resultø1.push(first(listø1));
                return resultø1;
            })(), loop[1] = rest(listø1), loop);
        } while (resultø1 = loop[0], listø1 = loop[1], recur === loop);
        return recur;
    }.call(this);
};
var vec = exports.vec = function vec(sequence) {
        return isNil(sequence) ? [] : isVector(sequence) ? sequence : isList(sequence) || isLazySeq(sequence) ? listToVector(sequence) : 'else' ? vec(seq(sequence)) : void 0;
    };
var sort = exports.sort = function sort(f, items) {
        return function () {
            var hasComparatorø1 = isFn(f);
            var itemsø2 = !hasComparatorø1 && isNil(items) ? f : items;
            var compareø1 = hasComparatorø1 ? function (a, b) {
                    return f(a, b) ? 0 : 1;
                } : void 0;
            return isNil(itemsø2) ? list() : isVector(itemsø2) ? itemsø2.sort(compareø1) : isList(itemsø2) ? list.apply(void 0, vec(itemsø2).sort(compareø1)) : isDictionary(itemsø2) ? seq(itemsø2).sort(compareø1) : 'else' ? sort(f, seq(itemsø2)) : void 0;
        }.call(this);
    };
var repeat = exports.repeat = function repeat(n, x) {
        return function loop() {
            var recur = loop;
            var nø2 = n;
            var resultø1 = [];
            do {
                recur = nø2 <= 0 ? resultø1 : (loop[0] = dec(nø2), loop[1] = conj(resultø1, x), loop);
            } while (nø2 = loop[0], resultø1 = loop[1], recur === loop);
            return recur;
        }.call(this);
    };
var isEvery = exports.isEvery = function isEvery(predicate, sequence) {
        return vec(sequence).every(function ($1) {
            return predicate($1);
        });
    };
var some = exports.some = function some(predicate, sequence) {
        return function loop() {
            var recur = loop;
            var itemsø1 = sequence;
            do {
                recur = isEmpty(itemsø1) ? false : predicate(first(itemsø1)) ? true : 'else' ? (loop[0] = rest(itemsø1), loop) : void 0;
            } while (itemsø1 = loop[0], recur === loop);
            return recur;
        }.call(this);
    };
var partition = exports.partition = function partition() {
        switch (arguments.length) {
        case 2:
            var n = arguments[0];
            var coll = arguments[1];
            return partition(n, n, coll);
        case 3:
            var n = arguments[0];
            var step = arguments[1];
            var coll = arguments[2];
            return partition(n, step, [], coll);
        case 4:
            var n = arguments[0];
            var step = arguments[1];
            var pad = arguments[2];
            var coll = arguments[3];
            return function loop() {
                var recur = loop;
                var resultø1 = [];
                var itemsø1 = seq(coll);
                do {
                    recur = function () {
                        var chunkø1 = take(n, itemsø1);
                        var sizeø1 = count(chunkø1);
                        return sizeø1 === n ? (loop[0] = conj(resultø1, chunkø1), loop[1] = drop(step, itemsø1), loop) : 0 === sizeø1 ? resultø1 : n > sizeø1 + count(pad) ? resultø1 : 'else' ? conj(resultø1, take(n, vec(concat(chunkø1, pad)))) : void 0;
                    }.call(this);
                } while (resultø1 = loop[0], itemsø1 = loop[1], recur === loop);
                return recur;
            }.call(this);
        default:
            throw RangeError('Wrong number of arguments passed');
        }
    };
var interleave = exports.interleave = function interleave() {
        switch (arguments.length) {
        case 2:
            var ax = arguments[0];
            var bx = arguments[1];
            return function loop() {
                var recur = loop;
                var cxø1 = [];
                var axø2 = ax;
                var bxø2 = bx;
                do {
                    recur = isEmpty(axø2) || isEmpty(bxø2) ? seq(cxø1) : (loop[0] = conj(cxø1, first(axø2), first(bxø2)), loop[1] = rest(axø2), loop[2] = rest(bxø2), loop);
                } while (cxø1 = loop[0], axø2 = loop[1], bxø2 = loop[2], recur === loop);
                return recur;
            }.call(this);
        default:
            var sequences = Array.prototype.slice.call(arguments, 0);
            return function loop() {
                var recur = loop;
                var resultø1 = [];
                var sequencesø2 = sequences;
                do {
                    recur = some(isEmpty, sequencesø2) ? resultø1 : (loop[0] = concat(resultø1, map(first, sequencesø2)), loop[1] = map(rest, sequencesø2), loop);
                } while (resultø1 = loop[0], sequencesø2 = loop[1], recur === loop);
                return recur;
            }.call(this);
        }
    };
var nth = exports.nth = function nth(sequence, index, notFound) {
        return isNil(sequence) ? notFound : isList(sequence) ? index < count(sequence) ? first(drop(index, sequence)) : notFound : isVector(sequence) || isString(sequence) ? index < count(sequence) ? sequence[index] : notFound : isLazySeq(sequence) ? nth(lazySeqValue(sequence), index, notFound) : 'else' ? (function () {
            throw TypeError('Unsupported type');
        })() : void 0;
    };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFub255bW91cy53aXNwIl0sIm5hbWVzIjpbIl9uc18iLCJpZCIsImRvYyIsImlzTmlsIiwiaXNWZWN0b3IiLCJpc0ZuIiwiaXNOdW1iZXIiLCJpc1N0cmluZyIsImlzRGljdGlvbmFyeSIsImtleVZhbHVlcyIsInN0ciIsImRlYyIsImluYyIsIm1lcmdlIiwiZGljdGlvbmFyeSIsIkxpc3QiLCJoZWFkIiwidGFpbCIsInRoaXMiLCJsaXN0IiwibGVuZ3RoIiwiY291bnQiLCJwcm90b3R5cGUubGVuZ3RoIiwidHlwZSIsInByb3RvdHlwZS50eXBlIiwicHJvdG90eXBlLnRhaWwiLCJPYmplY3QiLCJjcmVhdGUiLCJwcm90b3R5cGUiLCJwcm90b3R5cGUudG9TdHJpbmciLCJyZXN1bHTDuDEiLCJsaXN0w7gxIiwiaXNFbXB0eSIsInN1YnN0ciIsImZpcnN0Iiwiam9pbiIsIkpTT04iLCJzdHJpbmdpZnkiLCJyZXN0IiwibGF6eVNlcVZhbHVlIiwibGF6eVNlcSIsInJlYWxpemVkIiwieCIsIkxhenlTZXEiLCJleHBvcnRzIiwiYm9keSIsImlzTGF6eVNlcSIsInZhbHVlIiwiaXNMaXN0IiwiYXJndW1lbnRzIiwiQXJyYXkiLCJwcm90b3R5cGUuc2xpY2UiLCJjYWxsIiwicmVkdWNlUmlnaHQiLCJjb25zIiwicmV2ZXJzZUxpc3QiLCJzZXF1ZW5jZSIsIml0ZW1zw7gxIiwic291cmNlw7gxIiwiY29uY2F0IiwiaXNTZXF1ZW50aWFsIiwicmV2ZXJzZSIsInNlcSIsIm1hcCIsImYiLCIkMSIsIm1hcExpc3QiLCJmaWx0ZXIiLCJpc0YiLCJmaWx0ZXJMaXN0IiwicmVkdWNlIiwicGFyYW1zIiwiaGFzSW5pdGlhbMO4MSIsImluaXRpYWzDuDEiLCJzZXF1ZW5jZcO4MSIsInNlY29uZCIsInJlZHVjZUxpc3QiLCJpbml0aWFsIiwidGhpcmQiLCJzbGljZSIsImxhc3RPZkxpc3QiLCJpdGVtw7gxIiwibGFzdCIsImJ1dGxhc3QiLCJzdWJzIiwidmVjIiwidGFrZSIsIm4iLCJ0YWtlRnJvbVZlY3RvciIsInRha2VGcm9tTGlzdCIsInRha2VWZWN0b3JXaGlsZSIsInByZWRpY2F0ZSIsInZlY3RvciIsInRhaWzDuDEiLCJoZWFkw7gxIiwiY29uaiIsInRha2VMaXN0V2hpbGUiLCJpdGVtcyIsImlzUHJlZGljYXRlIiwidGFrZVdoaWxlIiwidGFrZW7DuDEiLCJuw7gyIiwiZHJvcEZyb21MaXN0IiwibGVmdMO4MSIsImRyb3AiLCJjb25qTGlzdCIsInJlc3VsdCIsIml0ZW0iLCJUeXBlRXJyb3IiLCJhc3NvYyIsInNvdXJjZSIsInNlcXVlbmNlcyIsImlzU2VxIiwibGlzdFRvVmVjdG9yIiwicHVzaCIsInNvcnQiLCJoYXNDb21wYXJhdG9yw7gxIiwiaXRlbXPDuDIiLCJjb21wYXJlw7gxIiwiYSIsImIiLCJyZXBlYXQiLCJpc0V2ZXJ5IiwiZXZlcnkiLCJzb21lIiwicGFydGl0aW9uIiwiY29sbCIsInN0ZXAiLCJwYWQiLCJjaHVua8O4MSIsInNpemXDuDEiLCJpbnRlcmxlYXZlIiwiYXgiLCJieCIsImN4w7gxIiwiYXjDuDIiLCJieMO4MiIsInNlcXVlbmNlc8O4MiIsIm50aCIsImluZGV4Iiwibm90Rm91bmQiXSwibWFwcGluZ3MiOiI7SUFBQSxJQUFDQSxJLEdBQUQ7QUFBQSxZQUFBQyxFLEVBQUksZUFBSjtBQUFBLFlBQUFDLEcsRUFBQSxLLENBQUE7QUFBQSxVOztRQUNrQ0MsS0FBQSxHLGFBQUFBLEs7UUFBS0MsUUFBQSxHLGFBQUFBLFE7UUFBUUMsSUFBQSxHLGFBQUFBLEk7UUFBSUMsUUFBQSxHLGFBQUFBLFE7UUFBUUMsUUFBQSxHLGFBQUFBLFE7UUFBUUMsWUFBQSxHLGFBQUFBLFk7UUFDakNDLFNBQUEsRyxhQUFBQSxTO1FBQVdDLEdBQUEsRyxhQUFBQSxHO1FBQUlDLEdBQUEsRyxhQUFBQSxHO1FBQUlDLEdBQUEsRyxhQUFBQSxHO1FBQUlDLEtBQUEsRyxhQUFBQSxLO1FBQU1DLFVBQUEsRyxhQUFBQSxVOztBQUkvRCxJQUFPQyxJQUFBLEdBQVAsU0FB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QUFBOEYsR0FBQSxHQUFOLFNBQU1BLEdBQU4sQ0FFR2xGLFFBRkgsRUFFWW1GLEtBRlosRUFFa0JDLFFBRmxCLEVBR0U7QUFBQSxlQUFPekksS0FBRCxDQUFNcUQsUUFBTixDQUFOLEdBQXNCb0YsUUFBdEIsR0FDTzVGLE1BQUQsQ0FBT1EsUUFBUCxDLEdBQXdCbUYsS0FBSCxHQUFVdEgsS0FBRCxDQUFPbUMsUUFBUCxDQUFiLEdBQ0d0QixLQUFELENBQVFzRSxJQUFELENBQU1tQyxLQUFOLEVBQVluRixRQUFaLENBQVAsQ0FERixHQUVFb0YsUSxHQUNkeEksUUFBRCxDQUFTb0QsUUFBVCxDQUFKLElBQ0tqRCxRQUFELENBQVNpRCxRQUFULEMsR0FBMkJtRixLQUFILEdBQVV0SCxLQUFELENBQU9tQyxRQUFQLENBQWIsR0FDUUEsUUFBTixDQUFlbUYsS0FBZixDQURGLEdBRUVDLFEsR0FDekI5RixTQUFELENBQVdVLFFBQVgsQyxHQUFzQmtGLEdBQUQsQ0FBTW5HLFlBQUQsQ0FBZ0JpQixRQUFoQixDQUFMLEVBQStCbUYsS0FBL0IsRUFBcUNDLFFBQXJDLEMseUJBQ2Y7QUFBQSxrQkFBUWhDLFNBQUQsQ0FBVyxrQkFBWCxDQUFQO0FBQUEsUyxDQUFBLEUsU0FUWjtBQUFBLEtBSEYiLCJzb3VyY2VzQ29udGVudCI6WyIobnMgd2lzcC5zZXF1ZW5jZVxuICAoOnJlcXVpcmUgW3dpc3AucnVudGltZSA6cmVmZXIgW25pbD8gdmVjdG9yPyBmbj8gbnVtYmVyPyBzdHJpbmc/IGRpY3Rpb25hcnk/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5LXZhbHVlcyBzdHIgZGVjIGluYyBtZXJnZSBkaWN0aW9uYXJ5XV0pKVxuXG47OyBJbXBsZW1lbnRhdGlvbiBvZiBsaXN0XG5cbihkZWZuLSBMaXN0XG4gIFwiTGlzdCB0eXBlXCJcbiAgW2hlYWQgdGFpbF1cbiAgKHNldCEgdGhpcy5oZWFkIGhlYWQpXG4gIChzZXQhIHRoaXMudGFpbCAob3IgdGFpbCAobGlzdCkpKVxuICAoc2V0ISB0aGlzLmxlbmd0aCAoaW5jIChjb3VudCB0aGlzLnRhaWwpKSlcbiAgdGhpcylcblxuKHNldCEgTGlzdC5wcm90b3R5cGUubGVuZ3RoIDApXG4oc2V0ISBMaXN0LnR5cGUgXCJ3aXNwLmxpc3RcIilcbihzZXQhIExpc3QucHJvdG90eXBlLnR5cGUgTGlzdC50eXBlKVxuKHNldCEgTGlzdC5wcm90b3R5cGUudGFpbCAoT2JqZWN0LmNyZWF0ZSBMaXN0LnByb3RvdHlwZSkpXG4oc2V0ISBMaXN0LnByb3RvdHlwZS50by1zdHJpbmdcbiAgICAgIChmbiBbXVxuICAgICAgICAobG9vcCBbcmVzdWx0IFwiXCJcbiAgICAgICAgICAgICAgIGxpc3QgdGhpc11cbiAgICAgICAgICAoaWYgKGVtcHR5PyBsaXN0KVxuICAgICAgICAgICAgKHN0ciBcIihcIiAoLnN1YnN0ciByZXN1bHQgMSkgXCIpXCIpXG4gICAgICAgICAgICAocmVjdXJcbiAgICAgICAgICAgICAoc3RyIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgXCIgXCJcbiAgICAgICAgICAgICAgICAgIChpZiAodmVjdG9yPyAoZmlyc3QgbGlzdCkpXG4gICAgICAgICAgICAgICAgICAgIChzdHIgXCJbXCIgKC5qb2luIChmaXJzdCBsaXN0KSBcIiBcIikgXCJdXCIpXG4gICAgICAgICAgICAgICAgICAgIChpZiAobmlsPyAoZmlyc3QgbGlzdCkpXG4gICAgICAgICAgICAgICAgICAgICAgXCJuaWxcIlxuICAgICAgICAgICAgICAgICAgICAgIChpZiAoc3RyaW5nPyAoZmlyc3QgbGlzdCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAoLnN0cmluZ2lmeSBKU09OIChmaXJzdCBsaXN0KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIChpZiAobnVtYmVyPyAoZmlyc3QgbGlzdCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICguc3RyaW5naWZ5IEpTT04gKGZpcnN0IGxpc3QpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAoZmlyc3QgbGlzdCkpKSkpKVxuICAgICAgICAgICAgIChyZXN0IGxpc3QpKSkpKSlcblxuKGRlZm4tIGxhenktc2VxLXZhbHVlIFtsYXp5LXNlcV1cbiAgKGlmIChub3QgKC4tcmVhbGl6ZWQgbGF6eS1zZXEpKVxuICAgIChhbmQgKHNldCEgKC4tcmVhbGl6ZWQgbGF6eS1zZXEpIHRydWUpXG4gICAgICAgICAoc2V0ISAoLi14IGxhenktc2VxKSAoLnggbGF6eS1zZXEpKSlcbiAgICAoLi14IGxhenktc2VxKSkpXG5cbihkZWZuLSBMYXp5U2VxIFtyZWFsaXplZCB4XVxuICAoc2V0ISAoLi1yZWFsaXplZCB0aGlzKSAob3IgcmVhbGl6ZWQgZmFsc2UpKVxuICAoc2V0ISAoLi14IHRoaXMpIHgpXG4gIHRoaXMpXG4oc2V0ISBMYXp5U2VxLnR5cGUgXCJ3aXNwLmxhenkuc2VxXCIpXG4oc2V0ISBMYXp5U2VxLnByb3RvdHlwZS50eXBlIExhenlTZXEudHlwZSlcblxuKGRlZm4gbGF6eS1zZXFcbiAgW3JlYWxpemVkIGJvZHldXG4gIChMYXp5U2VxLiByZWFsaXplZCBib2R5KSlcblxuKGRlZm4gbGF6eS1zZXE/XG4gIFt2YWx1ZV1cbiAgKGFuZCB2YWx1ZSAoaWRlbnRpY2FsPyBMYXp5U2VxLnR5cGUgdmFsdWUudHlwZSkpKVxuXG4oZGVmbiBsaXN0P1xuICBcIlJldHVybnMgdHJ1ZSBpZiBsaXN0XCJcbiAgW3ZhbHVlXVxuICAoYW5kIHZhbHVlIChpZGVudGljYWw/IExpc3QudHlwZSB2YWx1ZS50eXBlKSkpXG5cbihkZWZuIGxpc3RcbiAgXCJDcmVhdGVzIGxpc3Qgb2YgdGhlIGdpdmVuIGl0ZW1zXCJcbiAgW11cbiAgKGlmIChpZGVudGljYWw/ICguLWxlbmd0aCBhcmd1bWVudHMpIDApXG4gICAgKE9iamVjdC5jcmVhdGUgTGlzdC5wcm90b3R5cGUpXG4gICAgKC5yZWR1Y2UtcmlnaHQgKC5jYWxsIEFycmF5LnByb3RvdHlwZS5zbGljZSBhcmd1bWVudHMpXG4gICAgICAgICAgICAgICAgICAgKGZuIFt0YWlsIGhlYWRdIChjb25zIGhlYWQgdGFpbCkpXG4gICAgICAgICAgICAgICAgICAgKGxpc3QpKSkpXG5cbihkZWZuIGNvbnNcbiAgXCJDcmVhdGVzIGxpc3Qgd2l0aCBgaGVhZGAgYXMgZmlyc3QgaXRlbSBhbmQgYHRhaWxgIGFzIHJlc3RcIlxuICBbaGVhZCB0YWlsXVxuICAobmV3IExpc3QgaGVhZCB0YWlsKSlcblxuKGRlZm4tIHJldmVyc2UtbGlzdFxuICBbc2VxdWVuY2VdXG4gIChsb29wIFtpdGVtcyBbXVxuICAgICAgICAgICBzb3VyY2Ugc2VxdWVuY2VdXG4gICAgICAoaWYgKGVtcHR5PyBzb3VyY2UpXG4gICAgICAgIChhcHBseSBsaXN0IGl0ZW1zKVxuICAgICAgICAocmVjdXIgKC5jb25jYXQgWyhmaXJzdCBzb3VyY2UpXSBpdGVtcylcbiAgICAgICAgICAgICAgIChyZXN0IHNvdXJjZSkpKSkpXG5cbihkZWZuIF5ib29sZWFuIHNlcXVlbnRpYWw/XG4gIFwiUmV0dXJucyB0cnVlIGlmIGNvbGwgc2F0aXNmaWVzIElTZXF1ZW50aWFsXCJcbiAgW3hdIChvciAobGlzdD8geClcbiAgICAgICAgICAodmVjdG9yPyB4KVxuICAgICAgICAgIChsYXp5LXNlcT8geClcbiAgICAgICAgICAoZGljdGlvbmFyeT8geClcbiAgICAgICAgICAoc3RyaW5nPyB4KSkpXG5cblxuKGRlZm4gcmV2ZXJzZVxuICBcIlJldmVyc2Ugb3JkZXIgb2YgaXRlbXMgaW4gdGhlIHNlcXVlbmNlXCJcbiAgW3NlcXVlbmNlXVxuICAoY29uZCAobGlzdD8gc2VxdWVuY2UpIChyZXZlcnNlLWxpc3Qgc2VxdWVuY2UpXG4gICAgICAgICh2ZWN0b3I/IHNlcXVlbmNlKSAoLnJldmVyc2Ugc2VxdWVuY2UpXG4gICAgICAgIChuaWw/IHNlcXVlbmNlKSAnKClcbiAgICAgICAgOmVsc2UgKHJldmVyc2UgKHNlcSBzZXF1ZW5jZSkpKSlcblxuKGRlZm4gbWFwXG4gIFwiUmV0dXJucyBhIHNlcXVlbmNlIGNvbnNpc3Rpbmcgb2YgdGhlIHJlc3VsdCBvZiBhcHBseWluZyBgZmAgdG8gdGhlXG4gIGZpcnN0IGl0ZW0sIGZvbGxvd2VkIGJ5IGFwcGx5aW5nIGYgdG8gdGhlIHNlY29uZCBpdGVtcywgdW50aWwgc2VxdWVuY2UgaXNcbiAgZXhoYXVzdGVkLlwiXG4gIFtmIHNlcXVlbmNlXVxuICAoY29uZCAodmVjdG9yPyBzZXF1ZW5jZSkgKC5tYXAgc2VxdWVuY2UgIyhmICUpKVxuICAgICAgICAobGlzdD8gc2VxdWVuY2UpIChtYXAtbGlzdCBmIHNlcXVlbmNlKVxuICAgICAgICAobmlsPyBzZXF1ZW5jZSkgJygpXG4gICAgICAgIDplbHNlIChtYXAgZiAoc2VxIHNlcXVlbmNlKSkpKVxuXG4oZGVmbi0gbWFwLWxpc3RcbiAgXCJMaWtlIG1hcCBidXQgb3B0aW1pemVkIGZvciBsaXN0c1wiXG4gIFtmIHNlcXVlbmNlXVxuICAobG9vcCBbcmVzdWx0ICcoKVxuICAgICAgICAgaXRlbXMgc2VxdWVuY2VdXG4gICAgKGlmIChlbXB0eT8gaXRlbXMpXG4gICAgICAocmV2ZXJzZSByZXN1bHQpXG4gICAgICAocmVjdXIgKGNvbnMgKGYgKGZpcnN0IGl0ZW1zKSkgcmVzdWx0KSAocmVzdCBpdGVtcykpKSkpXG5cbihkZWZuIGZpbHRlclxuICBcIlJldHVybnMgYSBzZXF1ZW5jZSBvZiB0aGUgaXRlbXMgaW4gY29sbCBmb3Igd2hpY2ggKGY/IGl0ZW0pIHJldHVybnMgdHJ1ZS5cbiAgZj8gbXVzdCBiZSBmcmVlIG9mIHNpZGUtZWZmZWN0cy5cIlxuICBbZj8gc2VxdWVuY2VdXG4gIChjb25kICh2ZWN0b3I/IHNlcXVlbmNlKSAoLmZpbHRlciBzZXF1ZW5jZSBmPylcbiAgICAgICAgKGxpc3Q/IHNlcXVlbmNlKSAoZmlsdGVyLWxpc3QgZj8gc2VxdWVuY2UpXG4gICAgICAgIChuaWw/IHNlcXVlbmNlKSAnKClcbiAgICAgICAgOmVsc2UgKGZpbHRlciBmPyAoc2VxIHNlcXVlbmNlKSkpKVxuXG4oZGVmbi0gZmlsdGVyLWxpc3RcbiAgXCJMaWtlIGZpbHRlciBidXQgZm9yIGxpc3RzXCJcbiAgW2Y/IHNlcXVlbmNlXVxuICAobG9vcCBbcmVzdWx0ICcoKVxuICAgICAgICAgaXRlbXMgc2VxdWVuY2VdXG4gICAgKGlmIChlbXB0eT8gaXRlbXMpXG4gICAgICAocmV2ZXJzZSByZXN1bHQpXG4gICAgICAocmVjdXIgKGlmIChmPyAoZmlyc3QgaXRlbXMpKVxuICAgICAgICAgICAgICAoY29ucyAoZmlyc3QgaXRlbXMpIHJlc3VsdClcbiAgICAgICAgICAgICAgcmVzdWx0KVxuICAgICAgICAgICAgICAocmVzdCBpdGVtcykpKSkpXG5cbihkZWZuIHJlZHVjZVxuICBbZiAmIHBhcmFtc11cbiAgKGxldCBbaGFzLWluaXRpYWwgKD49IChjb3VudCBwYXJhbXMpIDIpXG4gICAgICAgIGluaXRpYWwgKGlmIGhhcy1pbml0aWFsIChmaXJzdCBwYXJhbXMpKVxuICAgICAgICBzZXF1ZW5jZSAoaWYgaGFzLWluaXRpYWwgKHNlY29uZCBwYXJhbXMpIChmaXJzdCBwYXJhbXMpKV1cbiAgICAoY29uZCAobmlsPyBzZXF1ZW5jZSkgaW5pdGlhbFxuICAgICAgICAgICh2ZWN0b3I/IHNlcXVlbmNlKSAoaWYgaGFzLWluaXRpYWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgucmVkdWNlIHNlcXVlbmNlIGYgaW5pdGlhbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgucmVkdWNlIHNlcXVlbmNlIGYpKVxuICAgICAgICAgIChsaXN0PyBzZXF1ZW5jZSkgKGlmIGhhcy1pbml0aWFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHJlZHVjZS1saXN0IGYgaW5pdGlhbCBzZXF1ZW5jZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAocmVkdWNlLWxpc3QgZiAoZmlyc3Qgc2VxdWVuY2UpIChyZXN0IHNlcXVlbmNlKSkpXG4gICAgICAgICAgOmVsc2UgKHJlZHVjZSBmIGluaXRpYWwgKHNlcSBzZXF1ZW5jZSkpKSkpXG5cbihkZWZuLSByZWR1Y2UtbGlzdFxuICBbZiBpbml0aWFsIHNlcXVlbmNlXVxuICAobG9vcCBbcmVzdWx0IGluaXRpYWxcbiAgICAgICAgIGl0ZW1zIHNlcXVlbmNlXVxuICAgIChpZiAoZW1wdHk/IGl0ZW1zKVxuICAgICAgcmVzdWx0XG4gICAgICAocmVjdXIgKGYgcmVzdWx0IChmaXJzdCBpdGVtcykpIChyZXN0IGl0ZW1zKSkpKSlcblxuKGRlZm4gY291bnRcbiAgXCJSZXR1cm5zIG51bWJlciBvZiBlbGVtZW50cyBpbiBsaXN0XCJcbiAgW3NlcXVlbmNlXVxuICAoaWYgKG5pbD8gc2VxdWVuY2UpXG4gICAgMFxuICAgICguLWxlbmd0aCAoc2VxIHNlcXVlbmNlKSkpKVxuXG4oZGVmbiBlbXB0eT9cbiAgXCJSZXR1cm5zIHRydWUgaWYgbGlzdCBpcyBlbXB0eVwiXG4gIFtzZXF1ZW5jZV1cbiAgKGlkZW50aWNhbD8gKGNvdW50IHNlcXVlbmNlKSAwKSlcblxuKGRlZm4gZmlyc3RcbiAgXCJSZXR1cm4gZmlyc3QgaXRlbSBpbiBhIGxpc3RcIlxuICBbc2VxdWVuY2VdXG4gIChjb25kIChuaWw/IHNlcXVlbmNlKSBuaWxcbiAgICAgICAgKGxpc3Q/IHNlcXVlbmNlKSAoLi1oZWFkIHNlcXVlbmNlKVxuICAgICAgICAob3IgKHZlY3Rvcj8gc2VxdWVuY2UpIChzdHJpbmc/IHNlcXVlbmNlKSkgKGdldCBzZXF1ZW5jZSAwKVxuICAgICAgICAobGF6eS1zZXE/IHNlcXVlbmNlKSAoZmlyc3QgKGxhenktc2VxLXZhbHVlIHNlcXVlbmNlKSlcbiAgICAgICAgOmVsc2UgKGZpcnN0IChzZXEgc2VxdWVuY2UpKSkpXG5cbihkZWZuIHNlY29uZFxuICBcIlJldHVybnMgc2Vjb25kIGl0ZW0gb2YgdGhlIGxpc3RcIlxuICBbc2VxdWVuY2VdXG4gIChjb25kIChuaWw/IHNlcXVlbmNlKSBuaWxcbiAgICAgICAgKGxpc3Q/IHNlcXVlbmNlKSAoZmlyc3QgKHJlc3Qgc2VxdWVuY2UpKVxuICAgICAgICAob3IgKHZlY3Rvcj8gc2VxdWVuY2UpIChzdHJpbmc/IHNlcXVlbmNlKSkgKGdldCBzZXF1ZW5jZSAxKVxuICAgICAgICAobGF6eS1zZXE/IHNlcXVlbmNlKSAoc2Vjb25kIChsYXp5LXNlcS12YWx1ZSBzZXF1ZW5jZSkpXG4gICAgICAgIDplbHNlIChmaXJzdCAocmVzdCAoc2VxIHNlcXVlbmNlKSkpKSlcblxuKGRlZm4gdGhpcmRcbiAgXCJSZXR1cm5zIHRoaXJkIGl0ZW0gb2YgdGhlIGxpc3RcIlxuICBbc2VxdWVuY2VdXG4gIChjb25kIChuaWw/IHNlcXVlbmNlKSBuaWxcbiAgICAgICAgKGxpc3Q/IHNlcXVlbmNlKSAoZmlyc3QgKHJlc3QgKHJlc3Qgc2VxdWVuY2UpKSlcbiAgICAgICAgKG9yICh2ZWN0b3I/IHNlcXVlbmNlKSAoc3RyaW5nPyBzZXF1ZW5jZSkpIChnZXQgc2VxdWVuY2UgMilcbiAgICAgICAgKGxhenktc2VxPyBzZXF1ZW5jZSkgKHRoaXJkIChsYXp5LXNlcS12YWx1ZSBzZXF1ZW5jZSkpXG4gICAgICAgIDplbHNlIChzZWNvbmQgKHJlc3QgKHNlcSBzZXF1ZW5jZSkpKSkpXG5cbihkZWZuIHJlc3RcbiAgXCJSZXR1cm5zIGxpc3Qgb2YgYWxsIGl0ZW1zIGV4Y2VwdCBmaXJzdCBvbmVcIlxuICBbc2VxdWVuY2VdXG4gIChjb25kIChuaWw/IHNlcXVlbmNlKSAnKClcbiAgICAgICAgKGxpc3Q/IHNlcXVlbmNlKSAoLi10YWlsIHNlcXVlbmNlKVxuICAgICAgICAob3IgKHZlY3Rvcj8gc2VxdWVuY2UpIChzdHJpbmc/IHNlcXVlbmNlKSkgKC5zbGljZSBzZXF1ZW5jZSAxKVxuICAgICAgICAobGF6eS1zZXE/IHNlcXVlbmNlKSAocmVzdCAobGF6eS1zZXEtdmFsdWUgc2VxdWVuY2UpKVxuICAgICAgICA6ZWxzZSAocmVzdCAoc2VxIHNlcXVlbmNlKSkpKVxuXG4oZGVmbi0gbGFzdC1vZi1saXN0XG4gIFtsaXN0XVxuICAobG9vcCBbaXRlbSAoZmlyc3QgbGlzdClcbiAgICAgICAgIGl0ZW1zIChyZXN0IGxpc3QpXVxuICAgIChpZiAoZW1wdHk/IGl0ZW1zKVxuICAgICAgaXRlbVxuICAgICAgKHJlY3VyIChmaXJzdCBpdGVtcykgKHJlc3QgaXRlbXMpKSkpKVxuXG4oZGVmbiBsYXN0XG4gIFwiUmV0dXJuIHRoZSBsYXN0IGl0ZW0gaW4gY29sbCwgaW4gbGluZWFyIHRpbWVcIlxuICBbc2VxdWVuY2VdXG4gIChjb25kIChvciAodmVjdG9yPyBzZXF1ZW5jZSlcbiAgICAgICAgICAgIChzdHJpbmc/IHNlcXVlbmNlKSkgKGdldCBzZXF1ZW5jZSAoZGVjIChjb3VudCBzZXF1ZW5jZSkpKVxuICAgICAgICAobGlzdD8gc2VxdWVuY2UpIChsYXN0LW9mLWxpc3Qgc2VxdWVuY2UpXG4gICAgICAgIChuaWw/IHNlcXVlbmNlKSBuaWxcbiAgICAgICAgKGxhenktc2VxPyBzZXF1ZW5jZSkgKGxhc3QgKGxhenktc2VxLXZhbHVlIHNlcXVlbmNlKSlcbiAgICAgICAgOmVsc2UgKGxhc3QgKHNlcSBzZXF1ZW5jZSkpKSlcblxuKGRlZm4gYnV0bGFzdFxuICBcIlJldHVybiBhIHNlcSBvZiBhbGwgYnV0IHRoZSBsYXN0IGl0ZW0gaW4gY29sbCwgaW4gbGluZWFyIHRpbWVcIlxuICBbc2VxdWVuY2VdXG4gIChsZXQgW2l0ZW1zIChjb25kIChuaWw/IHNlcXVlbmNlKSBuaWxcbiAgICAgICAgICAgICAgICAgICAgKHN0cmluZz8gc2VxdWVuY2UpIChzdWJzIHNlcXVlbmNlIDAgKGRlYyAoY291bnQgc2VxdWVuY2UpKSlcbiAgICAgICAgICAgICAgICAgICAgKHZlY3Rvcj8gc2VxdWVuY2UpICguc2xpY2Ugc2VxdWVuY2UgMCAoZGVjIChjb3VudCBzZXF1ZW5jZSkpKVxuICAgICAgICAgICAgICAgICAgICAobGlzdD8gc2VxdWVuY2UpIChhcHBseSBsaXN0IChidXRsYXN0ICh2ZWMgc2VxdWVuY2UpKSlcbiAgICAgICAgICAgICAgICAgICAgKGxhenktc2VxPyBzZXF1ZW5jZSkgKGJ1dGxhc3QgKGxhenktc2VxLXZhbHVlIHNlcXVlbmNlKSlcbiAgICAgICAgICAgICAgICAgICAgOmVsc2UgKGJ1dGxhc3QgKHNlcSBzZXF1ZW5jZSkpKV1cbiAgICAoaWYgKG5vdCAob3IgKG5pbD8gaXRlbXMpIChlbXB0eT8gaXRlbXMpKSlcbiAgICAgICAgaXRlbXMpKSlcblxuKGRlZm4gdGFrZVxuICBcIlJldHVybnMgYSBzZXF1ZW5jZSBvZiB0aGUgZmlyc3QgYG5gIGl0ZW1zLCBvciBhbGwgaXRlbXMgaWZcbiAgdGhlcmUgYXJlIGZld2VyIHRoYW4gYG5gLlwiXG4gIFtuIHNlcXVlbmNlXVxuICAoY29uZCAobmlsPyBzZXF1ZW5jZSkgJygpXG4gICAgICAgICh2ZWN0b3I/IHNlcXVlbmNlKSAodGFrZS1mcm9tLXZlY3RvciBuIHNlcXVlbmNlKVxuICAgICAgICAobGlzdD8gc2VxdWVuY2UpICh0YWtlLWZyb20tbGlzdCBuIHNlcXVlbmNlKVxuICAgICAgICAobGF6eS1zZXE/IHNlcXVlbmNlKSAodGFrZSBuIChsYXp5LXNlcS12YWx1ZSBzZXF1ZW5jZSkpXG4gICAgICAgIDplbHNlICh0YWtlIG4gKHNlcSBzZXF1ZW5jZSkpKSlcblxuKGRlZm4tIHRha2UtdmVjdG9yLXdoaWxlXG4gIFtwcmVkaWNhdGUgdmVjdG9yXVxuICAobG9vcCBbcmVzdWx0IFtdXG4gICAgICAgICB0YWlsIHZlY3RvclxuICAgICAgICAgaGVhZCAoZmlyc3QgdmVjdG9yKV1cbiAgICAoaWYgKGFuZCAobm90IChlbXB0eT8gdGFpbCkpXG4gICAgICAgICAgICAgKHByZWRpY2F0ZSBoZWFkKSlcbiAgICAgIChyZWN1ciAoY29uaiByZXN1bHQgaGVhZClcbiAgICAgICAgICAgICAocmVzdCB0YWlsKVxuICAgICAgICAgICAgIChmaXJzdCB0YWlsKSlcbiAgICAgIHJlc3VsdCkpKVxuXG4oZGVmbi0gdGFrZS1saXN0LXdoaWxlXG4gIFtwcmVkaWNhdGUgaXRlbXNdXG4gIChsb29wIFtyZXN1bHQgW11cbiAgICAgICAgIHRhaWwgaXRlbXNcbiAgICAgICAgIGhlYWQgKGZpcnN0IGl0ZW1zKV1cbiAgICAoaWYgKGFuZCAobm90IChlbXB0eT8gdGFpbCkpXG4gICAgICAgICAgICAgKHByZWRpY2F0ZT8gaGVhZCkpXG4gICAgICAocmVjdXIgKGNvbmogcmVzdWx0IGhlYWQpXG4gICAgICAgICAgICAgKHJlc3QgdGFpbClcbiAgICAgICAgICAgICAoZmlyc3QgdGFpbCkpXG4gICAgICAoYXBwbHkgbGlzdCByZXN1bHQpKSkpXG5cblxuKGRlZm4gdGFrZS13aGlsZVxuICBbcHJlZGljYXRlIHNlcXVlbmNlXVxuICAoY29uZCAobmlsPyBzZXF1ZW5jZSkgJygpXG4gICAgICAgICh2ZWN0b3I/IHNlcXVlbmNlKSAodGFrZS12ZWN0b3Itd2hpbGUgcHJlZGljYXRlIHNlcXVlbmNlKVxuICAgICAgICAobGlzdD8gc2VxdWVuY2UpICh0YWtlLXZlY3Rvci13aGlsZSBwcmVkaWNhdGUgc2VxdWVuY2UpXG4gICAgICAgIDplbHNlICh0YWtlLXdoaWxlIHByZWRpY2F0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAobGF6eS1zZXEtdmFsdWUgc2VxdWVuY2UpKSkpXG5cblxuKGRlZm4tIHRha2UtZnJvbS12ZWN0b3JcbiAgXCJMaWtlIHRha2UgYnV0IG9wdGltaXplZCBmb3IgdmVjdG9yc1wiXG4gIFtuIHZlY3Rvcl1cbiAgKC5zbGljZSB2ZWN0b3IgMCBuKSlcblxuKGRlZm4tIHRha2UtZnJvbS1saXN0XG4gIFwiTGlrZSB0YWtlIGJ1dCBmb3IgbGlzdHNcIlxuICBbbiBzZXF1ZW5jZV1cbiAgKGxvb3AgW3Rha2VuICcoKVxuICAgICAgICAgaXRlbXMgc2VxdWVuY2VcbiAgICAgICAgIG4gbl1cbiAgICAoaWYgKG9yIChpZGVudGljYWw/IG4gMCkgKGVtcHR5PyBpdGVtcykpXG4gICAgICAocmV2ZXJzZSB0YWtlbilcbiAgICAgIChyZWN1ciAoY29ucyAoZmlyc3QgaXRlbXMpIHRha2VuKVxuICAgICAgICAgICAgIChyZXN0IGl0ZW1zKVxuICAgICAgICAgICAgIChkZWMgbikpKSkpXG5cblxuXG5cbihkZWZuLSBkcm9wLWZyb20tbGlzdCBbbiBzZXF1ZW5jZV1cbiAgKGxvb3AgW2xlZnQgblxuICAgICAgICAgaXRlbXMgc2VxdWVuY2VdXG4gICAgKGlmIChvciAoPCBsZWZ0IDEpIChlbXB0eT8gaXRlbXMpKVxuICAgICAgaXRlbXNcbiAgICAgIChyZWN1ciAoZGVjIGxlZnQpIChyZXN0IGl0ZW1zKSkpKSlcblxuKGRlZm4gZHJvcFxuICBbbiBzZXF1ZW5jZV1cbiAgKGlmICg8PSBuIDApXG4gICAgc2VxdWVuY2VcbiAgICAoY29uZCAoc3RyaW5nPyBzZXF1ZW5jZSkgKC5zdWJzdHIgc2VxdWVuY2UgbilcbiAgICAgICAgICAodmVjdG9yPyBzZXF1ZW5jZSkgKC5zbGljZSBzZXF1ZW5jZSBuKVxuICAgICAgICAgIChsaXN0PyBzZXF1ZW5jZSkgKGRyb3AtZnJvbS1saXN0IG4gc2VxdWVuY2UpXG4gICAgICAgICAgKG5pbD8gc2VxdWVuY2UpICcoKVxuICAgICAgICAgIChsYXp5LXNlcT8gc2VxdWVuY2UpIChkcm9wIG4gKGxhenktc2VxLXZhbHVlIHNlcXVlbmNlKSlcbiAgICAgICAgICA6ZWxzZSAoZHJvcCBuIChzZXEgc2VxdWVuY2UpKSkpKVxuXG5cbihkZWZuLSBjb25qLWxpc3RcbiAgW3NlcXVlbmNlIGl0ZW1zXVxuICAocmVkdWNlIChmbiBbcmVzdWx0IGl0ZW1dIChjb25zIGl0ZW0gcmVzdWx0KSkgc2VxdWVuY2UgaXRlbXMpKVxuXG4oZGVmbiBjb25qXG4gIFtzZXF1ZW5jZSAmIGl0ZW1zXVxuICAoY29uZCAodmVjdG9yPyBzZXF1ZW5jZSkgKC5jb25jYXQgc2VxdWVuY2UgaXRlbXMpXG4gICAgICAgIChzdHJpbmc/IHNlcXVlbmNlKSAoc3RyIHNlcXVlbmNlIChhcHBseSBzdHIgaXRlbXMpKVxuICAgICAgICAobmlsPyBzZXF1ZW5jZSkgKGFwcGx5IGxpc3QgKHJldmVyc2UgaXRlbXMpKVxuICAgICAgICAob3IgKGxpc3Q/IHNlcXVlbmNlKVxuICAgICAgICAgICAgKGxhenktc2VxPykpIChjb25qLWxpc3Qgc2VxdWVuY2UgaXRlbXMpXG4gICAgICAgIChkaWN0aW9uYXJ5PyBzZXF1ZW5jZSkgKG1lcmdlIHNlcXVlbmNlIChhcHBseSBtZXJnZSBpdGVtcykpXG4gICAgICAgIDplbHNlICh0aHJvdyAoVHlwZUVycm9yIChzdHIgXCJUeXBlIGNhbid0IGJlIGNvbmpvaW5lZCBcIiBzZXF1ZW5jZSkpKSkpXG5cbihkZWZuIGFzc29jXG4gIFtzb3VyY2UgJiBrZXktdmFsdWVzXVxuICA7KGFzc2VydCAoZXZlbj8gKGNvdW50IGtleS12YWx1ZXMpKSBcIldyb25nIG51bWJlciBvZiBhcmd1bWVudHNcIilcbiAgOyhhc3NlcnQgKGFuZCAobm90IChzZXE/IHNvdXJjZSkpXG4gIDsgICAgICAgICAgICAgKG5vdCAodmVjdG9yPyBzb3VyY2UpKVxuICA7ICAgICAgICAgICAgIChvYmplY3Q/IHNvdXJjZSkpIFwiQ2FuIG9ubHkgYXNzb2Mgb24gZGljdGlvbmFyaWVzXCIpXG4gIChjb25qIHNvdXJjZSAoYXBwbHkgZGljdGlvbmFyeSBrZXktdmFsdWVzKSkpXG5cbihkZWZuIGNvbmNhdFxuICBcIlJldHVybnMgbGlzdCByZXByZXNlbnRpbmcgdGhlIGNvbmNhdGVuYXRpb24gb2YgdGhlIGVsZW1lbnRzIGluIHRoZVxuICBzdXBwbGllZCBsaXN0cy5cIlxuICBbJiBzZXF1ZW5jZXNdXG4gIChyZXZlcnNlXG4gICAgKHJlZHVjZVxuICAgICAgKGZuIFtyZXN1bHQgc2VxdWVuY2VdXG4gICAgICAgIChyZWR1Y2VcbiAgICAgICAgICAoZm4gW3Jlc3VsdCBpdGVtXSAoY29ucyBpdGVtIHJlc3VsdCkpXG4gICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgKHNlcSBzZXF1ZW5jZSkpKVxuICAgICAgJygpXG4gICAgICBzZXF1ZW5jZXMpKSlcblxuKGRlZm4gc2VxIFtzZXF1ZW5jZV1cbiAgKGNvbmQgKG5pbD8gc2VxdWVuY2UpIG5pbFxuICAgICAgICAob3IgKHZlY3Rvcj8gc2VxdWVuY2UpIChsaXN0PyBzZXF1ZW5jZSkgKGxhenktc2VxPyBzZXF1ZW5jZSkpIHNlcXVlbmNlXG4gICAgICAgIChzdHJpbmc/IHNlcXVlbmNlKSAoLmNhbGwgQXJyYXkucHJvdG90eXBlLnNsaWNlIHNlcXVlbmNlKVxuICAgICAgICAoZGljdGlvbmFyeT8gc2VxdWVuY2UpIChrZXktdmFsdWVzIHNlcXVlbmNlKVxuICAgICAgICA6ZGVmYXVsdCAodGhyb3cgKFR5cGVFcnJvciAoc3RyIFwiQ2FuIG5vdCBzZXEgXCIgc2VxdWVuY2UpKSkpKVxuXG4oZGVmbiBzZXE/IFtzZXF1ZW5jZV1cbiAgKG9yIChsaXN0PyBzZXF1ZW5jZSlcbiAgICAgIChsYXp5LXNlcT8gc2VxdWVuY2UpKSlcblxuKGRlZm4tIGxpc3QtPnZlY3RvciBbc291cmNlXVxuICAobG9vcCBbcmVzdWx0IFtdXG4gICAgICAgICBsaXN0IHNvdXJjZV1cbiAgICAoaWYgKGVtcHR5PyBsaXN0KVxuICAgICAgcmVzdWx0XG4gICAgICAocmVjdXJcbiAgICAgICAgKGRvICgucHVzaCByZXN1bHQgKGZpcnN0IGxpc3QpKSByZXN1bHQpXG4gICAgICAgIChyZXN0IGxpc3QpKSkpKVxuXG4oZGVmbiB2ZWNcbiAgXCJDcmVhdGVzIGEgbmV3IHZlY3RvciBjb250YWluaW5nIHRoZSBjb250ZW50cyBvZiBzZXF1ZW5jZVwiXG4gIFtzZXF1ZW5jZV1cbiAgKGNvbmQgKG5pbD8gc2VxdWVuY2UpIFtdXG4gICAgICAgICh2ZWN0b3I/IHNlcXVlbmNlKSBzZXF1ZW5jZVxuICAgICAgICAob3IgKGxpc3Q/IHNlcXVlbmNlKSAobGF6eS1zZXE/IHNlcXVlbmNlKSkgKGxpc3QtPnZlY3RvciBzZXF1ZW5jZSlcbiAgICAgICAgOmVsc2UgKHZlYyAoc2VxIHNlcXVlbmNlKSkpKVxuXG4oZGVmbiBzb3J0XG4gIFwiUmV0dXJucyBhIHNvcnRlZCBzZXF1ZW5jZSBvZiB0aGUgaXRlbXMgaW4gY29sbC5cbiAgSWYgbm8gY29tcGFyYXRvciBpcyBzdXBwbGllZCwgdXNlcyBjb21wYXJlLlwiXG4gIFtmIGl0ZW1zXVxuICAobGV0IFtoYXMtY29tcGFyYXRvciAoZm4/IGYpXG4gICAgICAgIGl0ZW1zIChpZiAoYW5kIChub3QgaGFzLWNvbXBhcmF0b3IpIChuaWw/IGl0ZW1zKSkgZiBpdGVtcylcbiAgICAgICAgY29tcGFyZSAoaWYgaGFzLWNvbXBhcmF0b3IgKGZuIFthIGJdIChpZiAoZiBhIGIpIDAgMSkpKV1cbiAgICAoY29uZCAobmlsPyBpdGVtcykgJygpXG4gICAgICAgICAgKHZlY3Rvcj8gaXRlbXMpICguc29ydCBpdGVtcyBjb21wYXJlKVxuICAgICAgICAgIChsaXN0PyBpdGVtcykgKGFwcGx5IGxpc3QgKC5zb3J0ICh2ZWMgaXRlbXMpIGNvbXBhcmUpKVxuICAgICAgICAgIChkaWN0aW9uYXJ5PyBpdGVtcykgKC5zb3J0IChzZXEgaXRlbXMpIGNvbXBhcmUpXG4gICAgICAgICAgOmVsc2UgKHNvcnQgZiAoc2VxIGl0ZW1zKSkpKSlcblxuXG4oZGVmbiByZXBlYXRcbiAgXCJSZXR1cm5zIGEgdmVjdG9yIG9mIGdpdmVuIGBuYCBsZW5ndGggd2l0aCBvZiBnaXZlbiBgeGBcbiAgaXRlbXMuIE5vdCBjb21wYXRpYmxlIHdpdGggY2xvanVyZSBhcyBpdCdzIG5vdCBhIGxhenlcbiAgYW5kIG9ubHkgZmluaXRlIHJlcGVhdHMgYXJlIHN1cHBvcnRlZFwiXG4gIFtuIHhdXG4gIChsb29wIFtuIG5cbiAgICAgICAgIHJlc3VsdCBbXV1cbiAgICAoaWYgKDw9IG4gMClcbiAgICAgIHJlc3VsdFxuICAgICAgKHJlY3VyIChkZWMgbilcbiAgICAgICAgICAgICAoY29uaiByZXN1bHQgeCkpKSkpXG5cbihkZWZuIGV2ZXJ5P1xuICBbcHJlZGljYXRlIHNlcXVlbmNlXVxuICAoLmV2ZXJ5ICh2ZWMgc2VxdWVuY2UpICMocHJlZGljYXRlICUpKSlcblxuKGRlZm4gc29tZVxuICBcIlJldHVybnMgdGhlIGZpcnN0IGxvZ2ljYWwgdHJ1ZSB2YWx1ZSBvZiAocHJlZCB4KSBmb3IgYW55IHggaW4gY29sbCxcbiAgZWxzZSBuaWwuICBPbmUgY29tbW9uIGlkaW9tIGlzIHRvIHVzZSBhIHNldCBhcyBwcmVkLCBmb3IgZXhhbXBsZVxuICB0aGlzIHdpbGwgcmV0dXJuIDpmcmVkIGlmIDpmcmVkIGlzIGluIHRoZSBzZXF1ZW5jZSwgb3RoZXJ3aXNlIG5pbDpcbiAgKHNvbWUgZXZlbj8gWzEgM10pID0+IGZhbHNlXG4gIChzb21lIGV2ZW4/IFsxIDIgMyA0XSA9PiB0cnVlXCJcbiAgW3ByZWRpY2F0ZSBzZXF1ZW5jZV1cbiAgKGxvb3AgW2l0ZW1zIHNlcXVlbmNlXVxuICAgIChjb25kIChlbXB0eT8gaXRlbXMpIGZhbHNlXG4gICAgICAgICAgKHByZWRpY2F0ZSAoZmlyc3QgaXRlbXMpKSB0cnVlXG4gICAgICAgICAgOmVsc2UgKHJlY3VyIChyZXN0IGl0ZW1zKSkpKSlcblxuXG4oZGVmbiBwYXJ0aXRpb25cbiAgKFtuIGNvbGxdIChwYXJ0aXRpb24gbiBuIGNvbGwpKVxuICAoW24gc3RlcCBjb2xsXSAocGFydGl0aW9uIG4gc3RlcCBbXSBjb2xsKSlcbiAgKFtuIHN0ZXAgcGFkIGNvbGxdXG4gICAobG9vcCBbcmVzdWx0IFtdXG4gICAgICAgICAgaXRlbXMgKHNlcSBjb2xsKV1cbiAgICAgKGxldCBbY2h1bmsgKHRha2UgbiBpdGVtcylcbiAgICAgICAgICAgc2l6ZSAoY291bnQgY2h1bmspXVxuICAgICAgIChjb25kIChpZGVudGljYWw/IHNpemUgbikgKHJlY3VyIChjb25qIHJlc3VsdCBjaHVuaylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZHJvcCBzdGVwIGl0ZW1zKSlcbiAgICAgICAgICAgICAoaWRlbnRpY2FsPyAwIHNpemUpIHJlc3VsdFxuICAgICAgICAgICAgICg+IG4gKCsgc2l6ZSAoY291bnQgcGFkKSkpIHJlc3VsdFxuICAgICAgICAgICAgIDplbHNlIChjb25qIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0YWtlIG4gKHZlYyAoY29uY2F0IGNodW5rXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkKSkpKSkpKSkpXG5cbihkZWZuIGludGVybGVhdmVcbiAgKFtheCBieF1cbiAgIChsb29wIFtjeCBbXVxuICAgICAgICAgIGF4IGF4XG4gICAgICAgICAgYnggYnhdXG4gICAgIChpZiAob3IgKGVtcHR5PyBheClcbiAgICAgICAgICAgICAoZW1wdHk/IGJ4KSlcbiAgICAgICAoc2VxIGN4KVxuICAgICAgIChyZWN1ciAoY29uaiBjeFxuICAgICAgICAgICAgICAgICAgICAoZmlyc3QgYXgpXG4gICAgICAgICAgICAgICAgICAgIChmaXJzdCBieCkpXG4gICAgICAgICAgICAgIChyZXN0IGF4KVxuICAgICAgICAgICAgICAocmVzdCBieCkpKSkpXG4gIChbJiBzZXF1ZW5jZXNdXG4gICAobG9vcCBbcmVzdWx0IFtdXG4gICAgICAgICAgc2VxdWVuY2VzIHNlcXVlbmNlc11cbiAgICAgKGlmIChzb21lIGVtcHR5PyBzZXF1ZW5jZXMpXG4gICAgICAgcmVzdWx0XG4gICAgICAgKHJlY3VyIChjb25jYXQgcmVzdWx0IChtYXAgZmlyc3Qgc2VxdWVuY2VzKSlcbiAgICAgICAgICAgICAgKG1hcCByZXN0IHNlcXVlbmNlcykpKSkpKVxuXG4oZGVmbiBudGhcbiAgXCJSZXR1cm5zIG50aCBpdGVtIG9mIHRoZSBzZXF1ZW5jZVwiXG4gIFtzZXF1ZW5jZSBpbmRleCBub3QtZm91bmRdXG4gIChjb25kIChuaWw/IHNlcXVlbmNlKSBub3QtZm91bmRcbiAgICAgICAgKGxpc3Q/IHNlcXVlbmNlKSAoaWYgKDwgaW5kZXggKGNvdW50IHNlcXVlbmNlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIChmaXJzdCAoZHJvcCBpbmRleCBzZXF1ZW5jZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBub3QtZm91bmQpXG4gICAgICAgIChvciAodmVjdG9yPyBzZXF1ZW5jZSlcbiAgICAgICAgICAgIChzdHJpbmc/IHNlcXVlbmNlKSkgKGlmICg8IGluZGV4IChjb3VudCBzZXF1ZW5jZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGFnZXQgc2VxdWVuY2UgaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90LWZvdW5kKVxuICAgICAgICAobGF6eS1zZXE/IHNlcXVlbmNlKSAobnRoIChsYXp5LXNlcS12YWx1ZSBzZXF1ZW5jZSkgaW5kZXggbm90LWZvdW5kKVxuICAgICAgICA6ZWxzZSAodGhyb3cgKFR5cGVFcnJvciBcIlVuc3VwcG9ydGVkIHR5cGVcIikpKSlcbiJdfQ==

},{"./runtime":"wcC2X1"}],"wisp/sequence":[function(require,module,exports){
module.exports=require('Mdzbzt');
},{}],"31fh9Q":[function(require,module,exports){
{
    var _ns_ = {
            id: 'wisp.string',
            doc: void 0
        };
    var wisp_runtime = require('./runtime');
    var str = wisp_runtime.str;
    var subs = wisp_runtime.subs;
    var reMatches = wisp_runtime.reMatches;
    var isNil = wisp_runtime.isNil;
    var isString = wisp_runtime.isString;
    var isRePattern = wisp_runtime.isRePattern;
    var wisp_sequence = require('./sequence');
    var vec = wisp_sequence.vec;
    var isEmpty = wisp_sequence.isEmpty;
}
var split = exports.split = function split(string, pattern, limit) {
        return string.split(pattern, limit);
    };
var splitLines = exports.splitLines = function splitLines(s) {
        return split(s, /\n|\r\n/);
    };
var join = exports.join = function join() {
        switch (arguments.length) {
        case 1:
            var coll = arguments[0];
            return str.apply(void 0, vec(coll));
        case 2:
            var separator = arguments[0];
            var coll = arguments[1];
            return vec(coll).join(separator);
        default:
            throw RangeError('Wrong number of arguments passed');
        }
    };
var upperCase = exports.upperCase = function upperCase(string) {
        return string.toUpperCase();
    };
var lowerCase = exports.lowerCase = function lowerCase(string) {
        return string.toLowerCase();
    };
var capitalize = exports.capitalize = function capitalize(s) {
        return count(s) < 2 ? upperCase(s) : '' + upperCase(subs(s, 0, 1)) + lowerCase(subs(s, 1));
    };
var ESCAPE_PATTERN = new RegExp('([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])', 'g');
var patternEscape = exports.patternEscape = function patternEscape(source) {
        return source.replace(ESCAPE_PATTERN, '\\$1').replace(new RegExp('\\x08', 'g'), '\\x08');
    };
var replaceFirst = exports.replaceFirst = function replaceFirst(string, match, replacement) {
        return string.replace(match, replacement);
    };
var replace = exports.replace = function replace(string, match, replacement) {
        return isString(match) ? string.replace(new RegExp(patternEscape(match), 'g'), replacement) : isRePattern(match) ? string.replace(new RegExp(match.source, 'g'), replacement) : 'else' ? (function () {
            throw '' + 'Invalid match arg: ' + match;
        })() : void 0;
    };
var __LEFTSPACES__ = exports.__LEFTSPACES__ = /^\s\s*/;
var __RIGHTSPACES__ = exports.__RIGHTSPACES__ = /\s\s*$/;
var __SPACES__ = exports.__SPACES__ = /^\s\s*$/;
var triml = exports.triml = isNil(''.trimLeft) ? function (string) {
        return string.replace(__LEFTSPACES__, '');
    } : function (string) {
        return string.trimLeft();
    };
var trimr = exports.trimr = isNil(''.trimRight) ? function (string) {
        return string.replace(__RIGHTSPACES__, '');
    } : function (string) {
        return string.trimRight();
    };
var trim = exports.trim = isNil(''.trim) ? function (string) {
        return string.replace(__LEFTSPACES__).replace(__RIGHTSPACES__);
    } : function (string) {
        return string.trim();
    };
var isBlank = exports.isBlank = function isBlank(string) {
        return isNil(string) || isEmpty(string) || reMatches(__SPACES__, string);
    };
var reverse = exports.reverse = function reverse(string) {
        return join('', string.split(/(?:)/).reverse());
    };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFub255bW91cy53aXNwIl0sIm5hbWVzIjpbIl9uc18iLCJpZCIsImRvYyIsInN0ciIsInN1YnMiLCJyZU1hdGNoZXMiLCJpc05pbCIsImlzU3RyaW5nIiwiaXNSZVBhdHRlcm4iLCJ2ZWMiLCJpc0VtcHR5Iiwic3BsaXQiLCJleHBvcnRzIiwic3RyaW5nIiwicGF0dGVybiIsImxpbWl0Iiwic3BsaXRMaW5lcyIsInMiLCJqb2luIiwiY29sbCIsInNlcGFyYXRvciIsInVwcGVyQ2FzZSIsInRvVXBwZXJDYXNlIiwibG93ZXJDYXNlIiwidG9Mb3dlckNhc2UiLCJjYXBpdGFsaXplIiwiY291bnQiLCJFU0NBUEVfUEFUVEVSTiIsInBhdHRlcm5Fc2NhcGUiLCJzb3VyY2UiLCJyZXBsYWNlIiwicmVwbGFjZUZpcnN0IiwibWF0Y2giLCJyZXBsYWNlbWVudCIsIl9fTEVGVFNQQUNFU19fIiwiX19SSUdIVFNQQUNFU19fIiwiX19TUEFDRVNfXyIsInRyaW1sIiwidHJpbUxlZnQiLCJ0cmltciIsInRyaW1SaWdodCIsInRyaW0iLCJpc0JsYW5rIiwicmV2ZXJzZSJdLCJtYXBwaW5ncyI6IjtJQUFBLElBQUNBLEksR0FBRDtBQUFBLFlBQUFDLEUsRUFBSSxhQUFKO0FBQUEsWUFBQUMsRyxFQUFBLEssQ0FBQTtBQUFBLFU7O1FBQ2tDQyxHQUFBLEcsYUFBQUEsRztRQUFJQyxJQUFBLEcsYUFBQUEsSTtRQUFLQyxTQUFBLEcsYUFBQUEsUztRQUFXQyxLQUFBLEcsYUFBQUEsSztRQUFLQyxRQUFBLEcsYUFBQUEsUTtRQUFRQyxXQUFBLEcsYUFBQUEsVzs7UUFDaENDLEdBQUEsRyxjQUFBQSxHO1FBQUlDLE9BQUEsRyxjQUFBQSxPOztBQUV2QyxJQUFNQyxLQUFBLEdBQUFDLE9BQUEsQ0FBQUQsS0FBQSxHQUFOLFNBQU1BLEtBQU4sQ0FHR0UsTUFISCxFQUdVQyxPQUhWLEVBR2tCQyxLQUhsQixFQUlFO0FBQUEsZUFBUUYsTUFBUCxDQUFDRixLQUFGLENBQWVHLE9BQWYs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SUFFS1IsU0FBRCxDQUFZK0IsVUFBWixFQUF1QnZCLE1BQXZCLENBRko7QUFBQSxLQUhGLEM7QUFPQSxJQUFNOEIsT0FBQSxHQUFBL0IsT0FBQSxDQUFBK0IsT0FBQSxHQUFOLFNBQU1BLE9BQU4sQ0FFRzlCLE1BRkgsRUFHRTtBQUFBLGVBQUNLLElBQUQsQ0FBTSxFQUFOLEVBQTJCTCxNQUFQLENBQUNGLEtBQUYsQ0FBZSxNQUFmLENBQVQsQ0FBQ2dDLE9BQUYsRUFBVDtBQUFBLEtBSEYiLCJzb3VyY2VzQ29udGVudCI6WyIobnMgd2lzcC5zdHJpbmdcbiAgKDpyZXF1aXJlIFt3aXNwLnJ1bnRpbWUgOnJlZmVyIFtzdHIgc3VicyByZS1tYXRjaGVzIG5pbD8gc3RyaW5nPyByZS1wYXR0ZXJuP11dXG4gICAgICAgICAgICBbd2lzcC5zZXF1ZW5jZSA6cmVmZXIgW3ZlYyBlbXB0eT9dXSkpXG5cbihkZWZuIHNwbGl0XG4gIFwiU3BsaXRzIHN0cmluZyBvbiBhIHJlZ3VsYXIgZXhwcmVzc2lvbi4gIE9wdGlvbmFsIGFyZ3VtZW50IGxpbWl0IGlzXG4gIHRoZSBtYXhpbXVtIG51bWJlciBvZiBzcGxpdHMuIE5vdCBsYXp5LiBSZXR1cm5zIHZlY3RvciBvZiB0aGUgc3BsaXRzLlwiXG4gIFtzdHJpbmcgcGF0dGVybiBsaW1pdF1cbiAgKC5zcGxpdCBzdHJpbmcgcGF0dGVybiBsaW1pdCkpXG5cbihkZWZuIHNwbGl0LWxpbmVzXG4gIFwiU3BsaXRzIHMgb24gXFxuIG9yIFxcclxcbi5cIlxuICBbc11cbiAgKHNwbGl0IHMgI1wiXFxufFxcclxcblwiKSlcblxuKGRlZm4gam9pblxuICBcIlJldHVybnMgYSBzdHJpbmcgb2YgYWxsIGVsZW1lbnRzIGluIGNvbGwsIGFzIHJldHVybmVkIGJ5IChzZXEgY29sbCksXG4gICBzZXBhcmF0ZWQgYnkgYW4gb3B0aW9uYWwgc2VwYXJhdG9yLlwiXG4gIChbY29sbF1cbiAgICAgKGFwcGx5IHN0ciAodmVjIGNvbGwpKSlcbiAgKFtzZXBhcmF0b3IgY29sbF1cbiAgICAgKC5qb2luICh2ZWMgY29sbCkgc2VwYXJhdG9yKSkpXG5cbihkZWZuIHVwcGVyLWNhc2VcbiAgXCJDb252ZXJ0cyBzdHJpbmcgdG8gYWxsIHVwcGVyLWNhc2UuXCJcbiAgW3N0cmluZ11cbiAgKC50b1VwcGVyQ2FzZSBzdHJpbmcpKVxuXG4oZGVmbiBsb3dlci1jYXNlXG4gIFwiQ29udmVydHMgc3RyaW5nIHRvIGFsbCBsb3dlci1jYXNlLlwiXG4gIFtzdHJpbmddXG4gICgudG9Mb3dlckNhc2Ugc3RyaW5nKSlcblxuKGRlZm4gXlN0cmluZyBjYXBpdGFsaXplXG4gIFwiQ29udmVydHMgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZSBzdHJpbmcgdG8gdXBwZXItY2FzZSwgYWxsIG90aGVyXG4gIGNoYXJhY3RlcnMgdG8gbG93ZXItY2FzZS5cIlxuICBbc11cbiAgKGlmICg8IChjb3VudCBzKSAyKVxuICAgICAgKHVwcGVyLWNhc2UgcylcbiAgICAgIChzdHIgKHVwcGVyLWNhc2UgKHN1YnMgcyAwIDEpKVxuICAgICAgICAgICAobG93ZXItY2FzZSAoc3VicyBzIDEpKSkpKVxuXG4oZGVmIF46cHJpdmF0ZSBFU0NBUEVfUEFUVEVSTlxuICAoUmVnRXhwLiBcIihbLSgpXFxcXFtcXFxcXXt9Kz8qLiRcXFxcXnwsOiM8IVxcXFxcXFxcXSlcIiBcImdcIikpXG5cbihkZWZuIHBhdHRlcm4tZXNjYXBlXG4gIFtzb3VyY2VdXG4gICgucmVwbGFjZSAoLnJlcGxhY2Ugc291cmNlIEVTQ0FQRV9QQVRURVJOIFwiXFxcXCQxXCIpXG4gICAgICAgICAgICAoUmVnRXhwLiBcIlxcXFx4MDhcIiBcImdcIiksIFwiXFxcXHgwOFwiKSlcblxuKGRlZm4gcmVwbGFjZS1maXJzdFxuICBcIlJlcGxhY2VzIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBtYXRjaCB3aXRoIHJlcGxhY2VtZW50IGluIHMuXG4gIG1hdGNoL3JlcGxhY2VtZW50IGNhbiBiZTpcblxuICBzdHJpbmcgLyBzdHJpbmdcbiAgcGF0dGVybiAvIChzdHJpbmcgb3IgZnVuY3Rpb24gb2YgbWF0Y2gpLlwiXG4gIFtzdHJpbmcgbWF0Y2ggcmVwbGFjZW1lbnRdXG4gICgucmVwbGFjZSBzdHJpbmcgbWF0Y2ggcmVwbGFjZW1lbnQpKVxuXG4oZGVmbiByZXBsYWNlXG4gIFwiUmVwbGFjZXMgYWxsIGluc3RhbmNlIG9mIG1hdGNoIHdpdGggcmVwbGFjZW1lbnQgaW4gcy5cblxuICAgbWF0Y2gvcmVwbGFjZW1lbnQgY2FuIGJlOlxuXG4gICBzdHJpbmcgLyBzdHJpbmdcbiAgIGNoYXIgLyBjaGFyXG4gICBwYXR0ZXJuIC8gKHN0cmluZyBvciBmdW5jdGlvbiBvZiBtYXRjaCkuXG5cbiAgIFNlZSBhbHNvIHJlcGxhY2UtZmlyc3QuXCJcbiAgW3N0cmluZyBtYXRjaCByZXBsYWNlbWVudF1cbiAgKGNvbmQgKHN0cmluZz8gbWF0Y2gpXG4gICAgICAgICgucmVwbGFjZSBzdHJpbmcgKFJlZ0V4cC4gKHBhdHRlcm4tZXNjYXBlIG1hdGNoKSBcImdcIikgcmVwbGFjZW1lbnQpXG5cbiAgICAgICAgKHJlLXBhdHRlcm4/IG1hdGNoKVxuICAgICAgICAoLnJlcGxhY2Ugc3RyaW5nIChSZWdFeHAuICguLXNvdXJjZSBtYXRjaCkgXCJnXCIpIHJlcGxhY2VtZW50KVxuXG4gICAgICAgIDplbHNlXG4gICAgICAgICh0aHJvdyAoc3RyIFwiSW52YWxpZCBtYXRjaCBhcmc6IFwiIG1hdGNoKSkpKVxuXG5cbjsoZGVmICoqV0hJVEVTUEFDRSoqIChzdHIgXCJbXFx4MDlcXHgwQVxceDBCXFx4MENcXHgwRFxceDIwXFx4QTBcXHUxNjgwXFx1MTgwRVxcdTIwMDBcIlxuOyAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcXHUyMDAxXFx1MjAwMlxcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFwiXG47ICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXFx1MjAyOFxcdTIwMjlcXHVGRUZGXVwiKSlcbjsoZGVmICoqTEVGVC1TUEFDRVMqKiAocmUtcGF0dGVybiAoc3RyIFwiXlwiICoqV0hJVEVTUEFDRSoqICoqV0hJVEVTUEFDRSoqIFwiKlwiKSkpXG47KGRlZiAqKlJJR0hULVNQQUNFUyoqIChyZS1wYXR0ZXJuIChzdHIgKipXSElURVNQQUNFKiogKipXSElURVNQQUNFKiogXCIqJFwiKSkpXG47KGRlZiAqKlNQQUNFUyoqIChyZS1wYXR0ZXJuIChzdHIgXCJeXCIgKipXSElURVNQQUNFKiogXCIqJFwiKSkpXG5cblxuKGRlZiAqKkxFRlQtU1BBQ0VTKiogI1wiXlxcc1xccypcIilcbihkZWYgKipSSUdIVC1TUEFDRVMqKiAjXCJcXHNcXHMqJFwiKVxuKGRlZiAqKlNQQUNFUyoqICNcIl5cXHNcXHMqJFwiKVxuXG5cbihkZWZcbiAgXns6dGFnIHN0cmluZ1xuICAgIDpkb2MgXCJSZW1vdmVzIHdoaXRlc3BhY2UgZnJvbSB0aGUgbGVmdCBzaWRlIG9mIHN0cmluZy5cIn1cbiAgdHJpbWxcbiAgKGlmIChuaWw/ICguLXRyaW1MZWZ0IFwiXCIpKVxuICAgIChmbiBbc3RyaW5nXSAoLnJlcGxhY2Ugc3RyaW5nICoqTEVGVC1TUEFDRVMqKiBcIlwiKSlcbiAgICAoZm4gW3N0cmluZ10gKC50cmltTGVmdCBzdHJpbmcpKSkpXG5cbihkZWZcbiAgXns6dGFnIHN0cmluZ1xuICAgIDpkb2MgXCJSZW1vdmVzIHdoaXRlc3BhY2UgZnJvbSB0aGUgcmlnaHQgc2lkZSBvZiBzdHJpbmcuXCJ9XG4gIHRyaW1yXG4gIChpZiAobmlsPyAoLi10cmltUmlnaHQgXCJcIikpXG4gICAgKGZuIFtzdHJpbmddICgucmVwbGFjZSBzdHJpbmcgKipSSUdIVC1TUEFDRVMqKiBcIlwiKSlcbiAgICAoZm4gW3N0cmluZ10gKC50cmltUmlnaHQgc3RyaW5nKSkpKVxuXG4oZGVmXG4gIF57OnRhZyBzdHJpbmdcbiAgICA6ZG9jIFwiUmVtb3ZlcyB3aGl0ZXNwYWNlIGZyb20gYm90aCBlbmRzIG9mIHN0cmluZy5cIn1cbiAgdHJpbVxuICAoaWYgKG5pbD8gKC4tdHJpbSBcIlwiKSlcbiAgICAoZm4gW3N0cmluZ10gKC5yZXBsYWNlICgucmVwbGFjZSBzdHJpbmcgKipMRUZULVNQQUNFUyoqKSAqKlJJR0hULVNQQUNFUyoqKSlcbiAgICAoZm4gW3N0cmluZ10gKC50cmltIHN0cmluZykpKSlcblxuKGRlZm4gYmxhbms/XG4gIFwiVHJ1ZSBpZiBzIGlzIG5pbCwgZW1wdHksIG9yIGNvbnRhaW5zIG9ubHkgd2hpdGVzcGFjZS5cIlxuICBbc3RyaW5nXVxuICAob3IgKG5pbD8gc3RyaW5nKVxuICAgICAgKGVtcHR5PyBzdHJpbmcpXG4gICAgICAocmUtbWF0Y2hlcyAqKlNQQUNFUyoqIHN0cmluZykpKVxuXG4oZGVmbiByZXZlcnNlXG4gIFwiUmV0dXJucyBzIHdpdGggaXRzIGNoYXJhY3RlcnMgcmV2ZXJzZWQuXCJcbiAgW3N0cmluZ11cbiAgKGpvaW4gXCJcIiAoLnJldmVyc2UgKC5zcGxpdCBzdHJpbmcgI1wiXCIpKSkpXG4iXX0=

},{"./runtime":"wcC2X1","./sequence":"Mdzbzt"}],"wisp/string":[function(require,module,exports){
module.exports=require('31fh9Q');
},{}]},{},["mP4Wz8"])
;